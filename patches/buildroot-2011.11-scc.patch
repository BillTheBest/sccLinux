diff -urN buildroot-2011.11.orig/bin2obj/bin2obj.c buildroot-2011.11/bin2obj/bin2obj.c
--- buildroot-2011.11.orig/bin2obj/bin2obj.c	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/bin2obj/bin2obj.c	2011-12-21 10:41:24.605900792 +0100
@@ -0,0 +1,147 @@
+#include <stdio.h>
+#include <getopt.h>
+#include <string.h>
+
+
+const char BIN2OBJIDSTRING[] = "$Id: bin2obj.c 8016 2007-11-01 14:24:42Z tlehnig $";
+
+
+long long convertToHex(char *fn, unsigned long origin, FILE *outfile) {
+  FILE *datafile;
+  unsigned char data1, data2, data3, data4;
+  int res = 0;
+  long long count = 0;
+
+  datafile = fopen(fn, "r");
+  if (!datafile) {
+    printf("Datafile >%s< could not be opened, not writing data for this file\n", fn);
+    return -1;
+  }
+
+  printf("Converting file >%s< to .32.obj format at origin 0x%08lx (0x%08lx) ... ",
+	 fn, origin >> 2, origin);
+  fprintf(outfile, "/origin %08lx\n", origin >> 2);
+  
+  do {
+    data1 = 0;
+    data2 = 0;
+    data3 = 0;
+    data4 = 0;
+    
+    res = fscanf(datafile, "%c%c%c%c", &data1, &data2, &data3, &data4);
+    if (res > 0) {
+      count += res;
+
+      fprintf(outfile, "%02x%02x%02x%02x", data4, data3, data2, data1);
+
+      if ((count % 16) == 0)
+	fprintf(outfile, "\n");
+      else
+	fprintf(outfile, " ");
+    }
+
+  } while (res > 0);
+  
+  if ((count % 16) != 0) fprintf(outfile, "\n");
+
+  printf("done with %lli Bytes.\n", count);
+
+  fclose(datafile);
+
+  return count;
+
+}
+
+
+void print_help() {
+  printf("Usage: bin2obj [FLAGS] [OPTIONS]\n");
+  printf("\nFLAGS: -h, -v\n");
+  printf("-h            Print this help\n");
+  printf("-v            Print Version ID\n");
+  printf("\nOPTIONS: -m, -o\n");
+  printf("-m <mapfile>  Defines mapfile to use for bin2obj\n");
+  printf("-o <outfile>  Defines output file to use for bin2obj\n");
+  printf("\nbin2obj converts the binary files defined in the mapfile to a hex based textfile\n");
+  printf("used by MCEMU\n");
+}
+
+
+int main(int argc, char **argv) {
+
+  FILE *mapfile = NULL, *outfile = NULL;
+  unsigned long origin;
+  char datafn[255];
+  char outfn[255] = "output.obj";
+  char mapfn[255] = "load.map";
+  int res = 0; 
+  unsigned long long count = 0;
+  long long thiscount = 0;
+  int retval = 0;
+
+  int c, doOptLoop = 1;
+
+  while (doOptLoop) {
+    c = getopt(argc, argv, "m:o:hv");
+
+    if (c == -1) {
+      doOptLoop = 0;
+      break;
+    }
+
+    switch (c) {
+    case 'h':
+      print_help();
+      return 0;
+      break;
+    case 'v':
+      printf("%s %s\n", argv[0], BIN2OBJIDSTRING);
+      return 0;
+      break;
+    case 'm':
+      printf("Mapfile: >%s<\n", optarg);
+      strncpy(mapfn, optarg, 255);
+      break;
+    case 'o':
+      printf("Outfile: >%s<\n", optarg);
+      strncpy(outfn, optarg, 255);
+      break;
+    default:
+      print_help();
+      return 0;
+    }
+  }
+	    
+
+  mapfile = fopen(mapfn, "r");
+  if (!mapfile) {
+    printf("Mapfile >%s< not found, exiting.\n", mapfn);
+    return -1;
+  }
+
+  outfile = fopen(outfn, "w");
+  if (!outfile) {
+    printf("Outputfile >%s< could not be created, exiting\n", outfn);
+    return -1;
+  }
+
+  //  res = fscanf(mapfile, "%lx %s\n", &origin, datafn);
+  
+  while ((res = fscanf(mapfile, "%lx %s\n", &origin, datafn)) == 2) {
+    //printf("ReadMapFile origin: 0x%08lx, filename: >%s<\n", origin, datafn);
+
+    thiscount = convertToHex(datafn, origin, outfile);
+    if (thiscount < 0) {
+	    retval = -1;
+    }
+    else count += thiscount;
+	    
+  }
+
+  fprintf(outfile, "/eof\n");
+  fclose(mapfile);
+  fclose (outfile);
+
+  printf("Total conversion: %lli Bytes\n", count);
+
+  return retval;
+}
diff -urN buildroot-2011.11.orig/bin2obj/Makefile buildroot-2011.11/bin2obj/Makefile
--- buildroot-2011.11.orig/bin2obj/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/bin2obj/Makefile	2011-12-21 10:41:24.605900792 +0100
@@ -0,0 +1,10 @@
+CC = gcc
+CFLAGS = -Wall -O3 
+
+TARGETS = bin2obj
+
+all: $(TARGETS)
+
+clean:
+	rm -f $(TARGETS) *.o *~
+
diff -urN buildroot-2011.11.orig/board/intel/scc/busybox-1.18.4.config buildroot-2011.11/board/intel/scc/busybox-1.18.4.config
--- buildroot-2011.11.orig/board/intel/scc/busybox-1.18.4.config	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/busybox-1.18.4.config	2011-12-21 10:41:24.605900792 +0100
@@ -0,0 +1,986 @@
+#
+# Automatically generated make config: don't edit
+# Busybox version: 1.18.4
+# Wed Jun  8 09:04:09 2011
+#
+CONFIG_HAVE_DOT_CONFIG=y
+
+#
+# Busybox Settings
+#
+
+#
+# General Configuration
+#
+CONFIG_DESKTOP=y
+# CONFIG_EXTRA_COMPAT is not set
+CONFIG_INCLUDE_SUSv2=y
+# CONFIG_USE_PORTABLE_CODE is not set
+CONFIG_PLATFORM_LINUX=y
+CONFIG_FEATURE_BUFFERS_USE_MALLOC=y
+# CONFIG_FEATURE_BUFFERS_GO_ON_STACK is not set
+# CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
+CONFIG_SHOW_USAGE=y
+CONFIG_FEATURE_VERBOSE_USAGE=y
+# CONFIG_FEATURE_COMPRESS_USAGE is not set
+CONFIG_FEATURE_INSTALLER=y
+# CONFIG_INSTALL_NO_USR is not set
+# CONFIG_LOCALE_SUPPORT is not set
+# CONFIG_UNICODE_SUPPORT is not set
+# CONFIG_UNICODE_USING_LOCALE is not set
+# CONFIG_FEATURE_CHECK_UNICODE_IN_ENV is not set
+CONFIG_SUBST_WCHAR=0
+CONFIG_LAST_SUPPORTED_WCHAR=0
+# CONFIG_UNICODE_COMBINING_WCHARS is not set
+# CONFIG_UNICODE_WIDE_WCHARS is not set
+# CONFIG_UNICODE_BIDI_SUPPORT is not set
+# CONFIG_UNICODE_NEUTRAL_TABLE is not set
+# CONFIG_UNICODE_PRESERVE_BROKEN is not set
+CONFIG_LONG_OPTS=y
+CONFIG_FEATURE_DEVPTS=y
+CONFIG_FEATURE_CLEAN_UP=y
+CONFIG_FEATURE_WTMP=y
+CONFIG_FEATURE_UTMP=y
+# CONFIG_FEATURE_PIDFILE is not set
+CONFIG_FEATURE_SUID=y
+# CONFIG_FEATURE_SUID_CONFIG is not set
+# CONFIG_FEATURE_SUID_CONFIG_QUIET is not set
+# CONFIG_SELINUX is not set
+# CONFIG_FEATURE_PREFER_APPLETS is not set
+CONFIG_BUSYBOX_EXEC_PATH="/proc/self/exe"
+CONFIG_FEATURE_SYSLOG=y
+CONFIG_FEATURE_HAVE_RPC=y
+
+#
+# Build Options
+#
+# CONFIG_STATIC is not set
+# CONFIG_PIE is not set
+# CONFIG_NOMMU is not set
+# CONFIG_BUILD_LIBBUSYBOX is not set
+# CONFIG_FEATURE_INDIVIDUAL is not set
+# CONFIG_FEATURE_SHARED_BUSYBOX is not set
+CONFIG_LFS=y
+CONFIG_CROSS_COMPILER_PREFIX=""
+CONFIG_EXTRA_CFLAGS=""
+
+#
+# Debugging Options
+#
+# CONFIG_DEBUG is not set
+# CONFIG_DEBUG_PESSIMIZE is not set
+# CONFIG_WERROR is not set
+CONFIG_NO_DEBUG_LIB=y
+# CONFIG_DMALLOC is not set
+# CONFIG_EFENCE is not set
+
+#
+# Installation Options ("make install" behavior)
+#
+CONFIG_INSTALL_APPLET_SYMLINKS=y
+# CONFIG_INSTALL_APPLET_HARDLINKS is not set
+# CONFIG_INSTALL_APPLET_SCRIPT_WRAPPERS is not set
+# CONFIG_INSTALL_APPLET_DONT is not set
+# CONFIG_INSTALL_SH_APPLET_SYMLINK is not set
+# CONFIG_INSTALL_SH_APPLET_HARDLINK is not set
+# CONFIG_INSTALL_SH_APPLET_SCRIPT_WRAPPER is not set
+CONFIG_PREFIX="./_install"
+
+#
+# Busybox Library Tuning
+#
+CONFIG_PASSWORD_MINLEN=6
+CONFIG_MD5_SIZE_VS_SPEED=2
+# CONFIG_FEATURE_FAST_TOP is not set
+# CONFIG_FEATURE_ETC_NETWORKS is not set
+CONFIG_FEATURE_USE_TERMIOS=y
+CONFIG_FEATURE_EDITING=y
+CONFIG_FEATURE_EDITING_MAX_LEN=1024
+CONFIG_FEATURE_EDITING_VI=y
+CONFIG_FEATURE_EDITING_HISTORY=999
+CONFIG_FEATURE_EDITING_SAVEHISTORY=y
+CONFIG_FEATURE_TAB_COMPLETION=y
+# CONFIG_FEATURE_USERNAME_COMPLETION is not set
+CONFIG_FEATURE_EDITING_FANCY_PROMPT=y
+# CONFIG_FEATURE_EDITING_ASK_TERMINAL is not set
+CONFIG_FEATURE_NON_POSIX_CP=y
+# CONFIG_FEATURE_VERBOSE_CP_MESSAGE is not set
+CONFIG_FEATURE_COPYBUF_KB=4
+CONFIG_MONOTONIC_SYSCALL=y
+CONFIG_IOCTL_HEX2STR_ERROR=y
+CONFIG_FEATURE_HWIB=y
+
+#
+# Applets
+#
+
+#
+# Archival Utilities
+#
+# CONFIG_FEATURE_SEAMLESS_XZ is not set
+# CONFIG_FEATURE_SEAMLESS_LZMA is not set
+# CONFIG_FEATURE_SEAMLESS_BZ2 is not set
+# CONFIG_FEATURE_SEAMLESS_GZ is not set
+# CONFIG_FEATURE_SEAMLESS_Z is not set
+CONFIG_AR=y
+# CONFIG_FEATURE_AR_LONG_FILENAMES is not set
+CONFIG_FEATURE_AR_CREATE=y
+CONFIG_BUNZIP2=y
+# CONFIG_BZIP2 is not set
+CONFIG_CPIO=y
+# CONFIG_FEATURE_CPIO_O is not set
+# CONFIG_FEATURE_CPIO_P is not set
+# CONFIG_DPKG is not set
+# CONFIG_DPKG_DEB is not set
+# CONFIG_FEATURE_DPKG_DEB_EXTRACT_ONLY is not set
+CONFIG_GUNZIP=y
+CONFIG_GZIP=y
+# CONFIG_FEATURE_GZIP_LONG_OPTIONS is not set
+# CONFIG_LZOP is not set
+# CONFIG_LZOP_COMPR_HIGH is not set
+# CONFIG_RPM2CPIO is not set
+# CONFIG_RPM is not set
+CONFIG_TAR=y
+CONFIG_FEATURE_TAR_CREATE=y
+# CONFIG_FEATURE_TAR_AUTODETECT is not set
+CONFIG_FEATURE_TAR_FROM=y
+# CONFIG_FEATURE_TAR_OLDGNU_COMPATIBILITY is not set
+# CONFIG_FEATURE_TAR_OLDSUN_COMPATIBILITY is not set
+CONFIG_FEATURE_TAR_GNU_EXTENSIONS=y
+CONFIG_FEATURE_TAR_LONG_OPTIONS=y
+CONFIG_FEATURE_TAR_TO_COMMAND=y
+# CONFIG_FEATURE_TAR_UNAME_GNAME is not set
+# CONFIG_FEATURE_TAR_NOPRESERVE_TIME is not set
+# CONFIG_FEATURE_TAR_SELINUX is not set
+# CONFIG_UNCOMPRESS is not set
+CONFIG_UNLZMA=y
+# CONFIG_FEATURE_LZMA_FAST is not set
+CONFIG_LZMA=y
+CONFIG_UNXZ=y
+CONFIG_XZ=y
+CONFIG_UNZIP=y
+
+#
+# Coreutils
+#
+CONFIG_BASENAME=y
+CONFIG_CAT=y
+CONFIG_DATE=y
+CONFIG_FEATURE_DATE_ISOFMT=y
+# CONFIG_FEATURE_DATE_NANO is not set
+CONFIG_FEATURE_DATE_COMPAT=y
+CONFIG_TEST=y
+CONFIG_FEATURE_TEST_64=y
+CONFIG_TR=y
+CONFIG_FEATURE_TR_CLASSES=y
+CONFIG_FEATURE_TR_EQUIV=y
+# CONFIG_BASE64 is not set
+# CONFIG_CAL is not set
+CONFIG_CATV=y
+CONFIG_CHGRP=y
+CONFIG_CHMOD=y
+CONFIG_CHOWN=y
+# CONFIG_FEATURE_CHOWN_LONG_OPTIONS is not set
+CONFIG_CHROOT=y
+CONFIG_CKSUM=y
+# CONFIG_COMM is not set
+CONFIG_CP=y
+# CONFIG_FEATURE_CP_LONG_OPTIONS is not set
+CONFIG_CUT=y
+CONFIG_DD=y
+CONFIG_FEATURE_DD_SIGNAL_HANDLING=y
+# CONFIG_FEATURE_DD_THIRD_STATUS_LINE is not set
+CONFIG_FEATURE_DD_IBS_OBS=y
+CONFIG_DF=y
+# CONFIG_FEATURE_DF_FANCY is not set
+CONFIG_DIRNAME=y
+CONFIG_DOS2UNIX=y
+CONFIG_UNIX2DOS=y
+CONFIG_DU=y
+CONFIG_FEATURE_DU_DEFAULT_BLOCKSIZE_1K=y
+CONFIG_ECHO=y
+CONFIG_FEATURE_FANCY_ECHO=y
+CONFIG_ENV=y
+# CONFIG_FEATURE_ENV_LONG_OPTIONS is not set
+# CONFIG_EXPAND is not set
+# CONFIG_FEATURE_EXPAND_LONG_OPTIONS is not set
+CONFIG_EXPR=y
+CONFIG_EXPR_MATH_SUPPORT_64=y
+CONFIG_FALSE=y
+CONFIG_FOLD=y
+# CONFIG_FSYNC is not set
+CONFIG_HEAD=y
+CONFIG_FEATURE_FANCY_HEAD=y
+CONFIG_HOSTID=y
+CONFIG_ID=y
+CONFIG_INSTALL=y
+CONFIG_FEATURE_INSTALL_LONG_OPTIONS=y
+CONFIG_LENGTH=y
+CONFIG_LN=y
+CONFIG_LOGNAME=y
+CONFIG_LS=y
+CONFIG_FEATURE_LS_FILETYPES=y
+CONFIG_FEATURE_LS_FOLLOWLINKS=y
+CONFIG_FEATURE_LS_RECURSIVE=y
+CONFIG_FEATURE_LS_SORTFILES=y
+CONFIG_FEATURE_LS_TIMESTAMPS=y
+CONFIG_FEATURE_LS_USERNAME=y
+CONFIG_FEATURE_LS_COLOR=y
+CONFIG_FEATURE_LS_COLOR_IS_DEFAULT=y
+CONFIG_MD5SUM=y
+CONFIG_MKDIR=y
+CONFIG_FEATURE_MKDIR_LONG_OPTIONS=y
+CONFIG_MKFIFO=y
+CONFIG_MKNOD=y
+CONFIG_MV=y
+CONFIG_FEATURE_MV_LONG_OPTIONS=y
+CONFIG_NICE=y
+CONFIG_NOHUP=y
+CONFIG_OD=y
+CONFIG_PRINTENV=y
+CONFIG_PRINTF=y
+CONFIG_PWD=y
+CONFIG_READLINK=y
+CONFIG_FEATURE_READLINK_FOLLOW=y
+CONFIG_REALPATH=y
+CONFIG_RM=y
+CONFIG_RMDIR=y
+# CONFIG_FEATURE_RMDIR_LONG_OPTIONS is not set
+CONFIG_SEQ=y
+CONFIG_SHA1SUM=y
+CONFIG_SHA256SUM=y
+CONFIG_SHA512SUM=y
+CONFIG_SLEEP=y
+# CONFIG_FEATURE_FANCY_SLEEP is not set
+# CONFIG_FEATURE_FLOAT_SLEEP is not set
+CONFIG_SORT=y
+CONFIG_FEATURE_SORT_BIG=y
+# CONFIG_SPLIT is not set
+# CONFIG_FEATURE_SPLIT_FANCY is not set
+# CONFIG_STAT is not set
+# CONFIG_FEATURE_STAT_FORMAT is not set
+CONFIG_STTY=y
+# CONFIG_SUM is not set
+CONFIG_SYNC=y
+# CONFIG_TAC is not set
+CONFIG_TAIL=y
+CONFIG_FEATURE_FANCY_TAIL=y
+CONFIG_TEE=y
+CONFIG_FEATURE_TEE_USE_BLOCK_IO=y
+CONFIG_TOUCH=y
+CONFIG_TRUE=y
+CONFIG_TTY=y
+CONFIG_UNAME=y
+# CONFIG_UNEXPAND is not set
+# CONFIG_FEATURE_UNEXPAND_LONG_OPTIONS is not set
+CONFIG_UNIQ=y
+CONFIG_USLEEP=y
+CONFIG_UUDECODE=y
+CONFIG_UUENCODE=y
+CONFIG_WC=y
+# CONFIG_FEATURE_WC_LARGE is not set
+CONFIG_WHO=y
+CONFIG_WHOAMI=y
+CONFIG_YES=y
+
+#
+# Common options for cp and mv
+#
+CONFIG_FEATURE_PRESERVE_HARDLINKS=y
+
+#
+# Common options for ls, more and telnet
+#
+CONFIG_FEATURE_AUTOWIDTH=y
+
+#
+# Common options for df, du, ls
+#
+CONFIG_FEATURE_HUMAN_READABLE=y
+
+#
+# Common options for md5sum, sha1sum, sha256sum, sha512sum
+#
+CONFIG_FEATURE_MD5_SHA1_SUM_CHECK=y
+
+#
+# Console Utilities
+#
+CONFIG_CHVT=y
+# CONFIG_FGCONSOLE is not set
+CONFIG_CLEAR=y
+CONFIG_DEALLOCVT=y
+CONFIG_DUMPKMAP=y
+# CONFIG_KBD_MODE is not set
+CONFIG_LOADFONT=y
+CONFIG_LOADKMAP=y
+CONFIG_OPENVT=y
+CONFIG_RESET=y
+CONFIG_RESIZE=y
+CONFIG_FEATURE_RESIZE_PRINT=y
+CONFIG_SETCONSOLE=y
+# CONFIG_FEATURE_SETCONSOLE_LONG_OPTIONS is not set
+# CONFIG_SETFONT is not set
+# CONFIG_FEATURE_SETFONT_TEXTUAL_MAP is not set
+CONFIG_DEFAULT_SETFONT_DIR=""
+CONFIG_SETKEYCODES=y
+CONFIG_SETLOGCONS=y
+# CONFIG_SHOWKEY is not set
+
+#
+# Common options for loadfont and setfont
+#
+CONFIG_FEATURE_LOADFONT_PSF2=y
+CONFIG_FEATURE_LOADFONT_RAW=y
+
+#
+# Debian Utilities
+#
+CONFIG_MKTEMP=y
+CONFIG_PIPE_PROGRESS=y
+CONFIG_RUN_PARTS=y
+CONFIG_FEATURE_RUN_PARTS_LONG_OPTIONS=y
+# CONFIG_FEATURE_RUN_PARTS_FANCY is not set
+CONFIG_START_STOP_DAEMON=y
+CONFIG_FEATURE_START_STOP_DAEMON_FANCY=y
+CONFIG_FEATURE_START_STOP_DAEMON_LONG_OPTIONS=y
+CONFIG_WHICH=y
+
+#
+# Editors
+#
+CONFIG_PATCH=y
+CONFIG_AWK=y
+# CONFIG_FEATURE_AWK_LIBM is not set
+CONFIG_CMP=y
+CONFIG_DIFF=y
+# CONFIG_FEATURE_DIFF_LONG_OPTIONS is not set
+CONFIG_FEATURE_DIFF_DIR=y
+# CONFIG_ED is not set
+CONFIG_SED=y
+CONFIG_VI=y
+CONFIG_FEATURE_VI_MAX_LEN=4096
+CONFIG_FEATURE_VI_8BIT=y
+CONFIG_FEATURE_VI_COLON=y
+CONFIG_FEATURE_VI_YANKMARK=y
+CONFIG_FEATURE_VI_SEARCH=y
+CONFIG_FEATURE_VI_USE_SIGNALS=y
+CONFIG_FEATURE_VI_DOT_CMD=y
+CONFIG_FEATURE_VI_READONLY=y
+CONFIG_FEATURE_VI_SETOPTS=y
+CONFIG_FEATURE_VI_SET=y
+CONFIG_FEATURE_VI_WIN_RESIZE=y
+CONFIG_FEATURE_VI_ASK_TERMINAL=y
+CONFIG_FEATURE_VI_OPTIMIZE_CURSOR=y
+CONFIG_FEATURE_ALLOW_EXEC=y
+
+#
+# Finding Utilities
+#
+CONFIG_FIND=y
+CONFIG_FEATURE_FIND_PRINT0=y
+CONFIG_FEATURE_FIND_MTIME=y
+CONFIG_FEATURE_FIND_MMIN=y
+CONFIG_FEATURE_FIND_PERM=y
+CONFIG_FEATURE_FIND_TYPE=y
+CONFIG_FEATURE_FIND_XDEV=y
+CONFIG_FEATURE_FIND_MAXDEPTH=y
+CONFIG_FEATURE_FIND_NEWER=y
+# CONFIG_FEATURE_FIND_INUM is not set
+CONFIG_FEATURE_FIND_EXEC=y
+CONFIG_FEATURE_FIND_USER=y
+CONFIG_FEATURE_FIND_GROUP=y
+CONFIG_FEATURE_FIND_NOT=y
+CONFIG_FEATURE_FIND_DEPTH=y
+CONFIG_FEATURE_FIND_PAREN=y
+CONFIG_FEATURE_FIND_SIZE=y
+CONFIG_FEATURE_FIND_PRUNE=y
+# CONFIG_FEATURE_FIND_DELETE is not set
+CONFIG_FEATURE_FIND_PATH=y
+CONFIG_FEATURE_FIND_REGEX=y
+# CONFIG_FEATURE_FIND_CONTEXT is not set
+# CONFIG_FEATURE_FIND_LINKS is not set
+CONFIG_GREP=y
+CONFIG_FEATURE_GREP_EGREP_ALIAS=y
+CONFIG_FEATURE_GREP_FGREP_ALIAS=y
+CONFIG_FEATURE_GREP_CONTEXT=y
+CONFIG_XARGS=y
+# CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION is not set
+CONFIG_FEATURE_XARGS_SUPPORT_QUOTES=y
+CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT=y
+CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM=y
+
+#
+# Init Utilities
+#
+# CONFIG_BOOTCHARTD is not set
+# CONFIG_FEATURE_BOOTCHARTD_BLOATED_HEADER is not set
+# CONFIG_FEATURE_BOOTCHARTD_CONFIG_FILE is not set
+CONFIG_HALT=y
+# CONFIG_FEATURE_CALL_TELINIT is not set
+CONFIG_TELINIT_PATH=""
+CONFIG_INIT=y
+CONFIG_FEATURE_USE_INITTAB=y
+CONFIG_FEATURE_KILL_REMOVED=y
+CONFIG_FEATURE_KILL_DELAY=0
+CONFIG_FEATURE_INIT_SCTTY=y
+CONFIG_FEATURE_INIT_SYSLOG=y
+CONFIG_FEATURE_EXTRA_QUIET=y
+# CONFIG_FEATURE_INIT_COREDUMPS is not set
+CONFIG_FEATURE_INITRD=y
+CONFIG_INIT_TERMINAL_TYPE="linux"
+CONFIG_MESG=y
+
+#
+# Login/Password Management Utilities
+#
+# CONFIG_ADD_SHELL is not set
+# CONFIG_REMOVE_SHELL is not set
+CONFIG_FEATURE_SHADOWPASSWDS=y
+# CONFIG_USE_BB_PWD_GRP is not set
+# CONFIG_USE_BB_SHADOW is not set
+CONFIG_USE_BB_CRYPT=y
+# CONFIG_USE_BB_CRYPT_SHA is not set
+CONFIG_ADDUSER=y
+# CONFIG_FEATURE_ADDUSER_LONG_OPTIONS is not set
+# CONFIG_FEATURE_CHECK_NAMES is not set
+CONFIG_FIRST_SYSTEM_ID=100
+CONFIG_LAST_SYSTEM_ID=999
+CONFIG_ADDGROUP=y
+# CONFIG_FEATURE_ADDGROUP_LONG_OPTIONS is not set
+# CONFIG_FEATURE_ADDUSER_TO_GROUP is not set
+CONFIG_DELUSER=y
+CONFIG_DELGROUP=y
+# CONFIG_FEATURE_DEL_USER_FROM_GROUP is not set
+CONFIG_GETTY=y
+CONFIG_LOGIN=y
+# CONFIG_PAM is not set
+# CONFIG_LOGIN_SCRIPTS is not set
+CONFIG_FEATURE_NOLOGIN=y
+CONFIG_FEATURE_SECURETTY=y
+CONFIG_PASSWD=y
+CONFIG_FEATURE_PASSWD_WEAK_CHECK=y
+# CONFIG_CRYPTPW is not set
+# CONFIG_CHPASSWD is not set
+CONFIG_SU=y
+CONFIG_FEATURE_SU_SYSLOG=y
+CONFIG_FEATURE_SU_CHECKS_SHELLS=y
+CONFIG_SULOGIN=y
+CONFIG_VLOCK=y
+
+#
+# Linux Ext2 FS Progs
+#
+CONFIG_CHATTR=y
+CONFIG_FSCK=y
+CONFIG_LSATTR=y
+# CONFIG_TUNE2FS is not set
+
+#
+# Linux Module Utilities
+#
+# CONFIG_MODINFO is not set
+# CONFIG_MODPROBE_SMALL is not set
+# CONFIG_FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE is not set
+# CONFIG_FEATURE_MODPROBE_SMALL_CHECK_ALREADY_LOADED is not set
+CONFIG_INSMOD=y
+CONFIG_RMMOD=y
+CONFIG_LSMOD=y
+CONFIG_FEATURE_LSMOD_PRETTY_2_6_OUTPUT=y
+CONFIG_MODPROBE=y
+# CONFIG_FEATURE_MODPROBE_BLACKLIST is not set
+# CONFIG_DEPMOD is not set
+
+#
+# Options common to multiple modutils
+#
+# CONFIG_FEATURE_2_4_MODULES is not set
+# CONFIG_FEATURE_INSMOD_TRY_MMAP is not set
+# CONFIG_FEATURE_INSMOD_VERSION_CHECKING is not set
+# CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS is not set
+# CONFIG_FEATURE_INSMOD_LOADINKMEM is not set
+# CONFIG_FEATURE_INSMOD_LOAD_MAP is not set
+# CONFIG_FEATURE_INSMOD_LOAD_MAP_FULL is not set
+CONFIG_FEATURE_CHECK_TAINTED_MODULE=y
+CONFIG_FEATURE_MODUTILS_ALIAS=y
+CONFIG_FEATURE_MODUTILS_SYMBOLS=y
+CONFIG_DEFAULT_MODULES_DIR="/lib/modules"
+CONFIG_DEFAULT_DEPMOD_FILE="modules.dep"
+
+#
+# Linux System Utilities
+#
+# CONFIG_BLOCKDEV is not set
+# CONFIG_REV is not set
+# CONFIG_ACPID is not set
+# CONFIG_FEATURE_ACPID_COMPAT is not set
+# CONFIG_BLKID is not set
+CONFIG_DMESG=y
+CONFIG_FEATURE_DMESG_PRETTY=y
+# CONFIG_FBSET is not set
+# CONFIG_FEATURE_FBSET_FANCY is not set
+# CONFIG_FEATURE_FBSET_READMODE is not set
+CONFIG_FDFLUSH=y
+CONFIG_FDFORMAT=y
+# CONFIG_FDISK is not set
+CONFIG_FDISK_SUPPORT_LARGE_DISKS=y
+# CONFIG_FEATURE_FDISK_WRITABLE is not set
+# CONFIG_FEATURE_AIX_LABEL is not set
+# CONFIG_FEATURE_SGI_LABEL is not set
+# CONFIG_FEATURE_SUN_LABEL is not set
+# CONFIG_FEATURE_OSF_LABEL is not set
+# CONFIG_FEATURE_GPT_LABEL is not set
+# CONFIG_FEATURE_FDISK_ADVANCED is not set
+# CONFIG_FINDFS is not set
+# CONFIG_FLOCK is not set
+CONFIG_FREERAMDISK=y
+# CONFIG_FSCK_MINIX is not set
+# CONFIG_MKFS_EXT2 is not set
+# CONFIG_MKFS_MINIX is not set
+# CONFIG_FEATURE_MINIX2 is not set
+# CONFIG_MKFS_REISER is not set
+# CONFIG_MKFS_VFAT is not set
+CONFIG_GETOPT=y
+CONFIG_FEATURE_GETOPT_LONG=y
+CONFIG_HEXDUMP=y
+# CONFIG_FEATURE_HEXDUMP_REVERSE is not set
+# CONFIG_HD is not set
+CONFIG_HWCLOCK=y
+CONFIG_FEATURE_HWCLOCK_LONG_OPTIONS=y
+CONFIG_FEATURE_HWCLOCK_ADJTIME_FHS=y
+CONFIG_IPCRM=y
+CONFIG_IPCS=y
+CONFIG_LOSETUP=y
+CONFIG_LSPCI=y
+CONFIG_LSUSB=y
+CONFIG_MDEV=y
+CONFIG_FEATURE_MDEV_CONF=y
+# CONFIG_FEATURE_MDEV_RENAME is not set
+# CONFIG_FEATURE_MDEV_RENAME_REGEXP is not set
+CONFIG_FEATURE_MDEV_EXEC=y
+# CONFIG_FEATURE_MDEV_LOAD_FIRMWARE is not set
+CONFIG_MKSWAP=y
+# CONFIG_FEATURE_MKSWAP_UUID is not set
+CONFIG_MORE=y
+CONFIG_MOUNT=y
+# CONFIG_FEATURE_MOUNT_FAKE is not set
+# CONFIG_FEATURE_MOUNT_VERBOSE is not set
+# CONFIG_FEATURE_MOUNT_HELPERS is not set
+# CONFIG_FEATURE_MOUNT_LABEL is not set
+CONFIG_FEATURE_MOUNT_NFS=y
+CONFIG_FEATURE_MOUNT_CIFS=y
+CONFIG_FEATURE_MOUNT_FLAGS=y
+CONFIG_FEATURE_MOUNT_FSTAB=y
+CONFIG_PIVOT_ROOT=y
+CONFIG_RDATE=y
+# CONFIG_RDEV is not set
+CONFIG_READPROFILE=y
+# CONFIG_RTCWAKE is not set
+# CONFIG_SCRIPT is not set
+# CONFIG_SCRIPTREPLAY is not set
+CONFIG_SETARCH=y
+CONFIG_SWAPONOFF=y
+# CONFIG_FEATURE_SWAPON_PRI is not set
+CONFIG_SWITCH_ROOT=y
+CONFIG_UMOUNT=y
+CONFIG_FEATURE_UMOUNT_ALL=y
+
+#
+# Common options for mount/umount
+#
+CONFIG_FEATURE_MOUNT_LOOP=y
+CONFIG_FEATURE_MOUNT_LOOP_CREATE=y
+# CONFIG_FEATURE_MTAB_SUPPORT is not set
+# CONFIG_VOLUMEID is not set
+# CONFIG_FEATURE_VOLUMEID_EXT is not set
+# CONFIG_FEATURE_VOLUMEID_BTRFS is not set
+# CONFIG_FEATURE_VOLUMEID_REISERFS is not set
+# CONFIG_FEATURE_VOLUMEID_FAT is not set
+# CONFIG_FEATURE_VOLUMEID_HFS is not set
+# CONFIG_FEATURE_VOLUMEID_JFS is not set
+# CONFIG_FEATURE_VOLUMEID_XFS is not set
+# CONFIG_FEATURE_VOLUMEID_NTFS is not set
+# CONFIG_FEATURE_VOLUMEID_ISO9660 is not set
+# CONFIG_FEATURE_VOLUMEID_UDF is not set
+# CONFIG_FEATURE_VOLUMEID_LUKS is not set
+# CONFIG_FEATURE_VOLUMEID_LINUXSWAP is not set
+# CONFIG_FEATURE_VOLUMEID_CRAMFS is not set
+# CONFIG_FEATURE_VOLUMEID_ROMFS is not set
+# CONFIG_FEATURE_VOLUMEID_SYSV is not set
+# CONFIG_FEATURE_VOLUMEID_OCFS2 is not set
+# CONFIG_FEATURE_VOLUMEID_LINUXRAID is not set
+
+#
+# Miscellaneous Utilities
+#
+# CONFIG_CONSPY is not set
+# CONFIG_NANDWRITE is not set
+# CONFIG_NANDDUMP is not set
+# CONFIG_UBIATTACH is not set
+# CONFIG_UBIDETACH is not set
+# CONFIG_ADJTIMEX is not set
+# CONFIG_BBCONFIG is not set
+# CONFIG_FEATURE_COMPRESS_BBCONFIG is not set
+# CONFIG_BEEP is not set
+CONFIG_FEATURE_BEEP_FREQ=0
+CONFIG_FEATURE_BEEP_LENGTH_MS=0
+# CONFIG_CHAT is not set
+# CONFIG_FEATURE_CHAT_NOFAIL is not set
+# CONFIG_FEATURE_CHAT_TTY_HIFI is not set
+# CONFIG_FEATURE_CHAT_IMPLICIT_CR is not set
+# CONFIG_FEATURE_CHAT_SWALLOW_OPTS is not set
+# CONFIG_FEATURE_CHAT_SEND_ESCAPES is not set
+# CONFIG_FEATURE_CHAT_VAR_ABORT_LEN is not set
+# CONFIG_FEATURE_CHAT_CLR_ABORT is not set
+CONFIG_CHRT=y
+CONFIG_CROND=y
+# CONFIG_FEATURE_CROND_D is not set
+# CONFIG_FEATURE_CROND_CALL_SENDMAIL is not set
+CONFIG_FEATURE_CROND_DIR="/var/spool/cron"
+CONFIG_CRONTAB=y
+CONFIG_DC=y
+# CONFIG_FEATURE_DC_LIBM is not set
+# CONFIG_DEVFSD is not set
+# CONFIG_DEVFSD_MODLOAD is not set
+# CONFIG_DEVFSD_FG_NP is not set
+# CONFIG_DEVFSD_VERBOSE is not set
+# CONFIG_FEATURE_DEVFS is not set
+CONFIG_DEVMEM=y
+CONFIG_EJECT=y
+# CONFIG_FEATURE_EJECT_SCSI is not set
+# CONFIG_FBSPLASH is not set
+# CONFIG_FLASHCP is not set
+# CONFIG_FLASH_LOCK is not set
+# CONFIG_FLASH_UNLOCK is not set
+# CONFIG_FLASH_ERASEALL is not set
+# CONFIG_IONICE is not set
+# CONFIG_INOTIFYD is not set
+CONFIG_LAST=y
+CONFIG_FEATURE_LAST_SMALL=y
+# CONFIG_FEATURE_LAST_FANCY is not set
+CONFIG_LESS=y
+CONFIG_FEATURE_LESS_MAXLINES=9999999
+CONFIG_FEATURE_LESS_BRACKETS=y
+CONFIG_FEATURE_LESS_FLAGS=y
+# CONFIG_FEATURE_LESS_MARKS is not set
+CONFIG_FEATURE_LESS_REGEXP=y
+# CONFIG_FEATURE_LESS_WINCH is not set
+# CONFIG_FEATURE_LESS_DASHCMD is not set
+# CONFIG_FEATURE_LESS_LINENUMS is not set
+CONFIG_HDPARM=y
+CONFIG_FEATURE_HDPARM_GET_IDENTITY=y
+# CONFIG_FEATURE_HDPARM_HDIO_SCAN_HWIF is not set
+# CONFIG_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF is not set
+# CONFIG_FEATURE_HDPARM_HDIO_DRIVE_RESET is not set
+# CONFIG_FEATURE_HDPARM_HDIO_TRISTATE_HWIF is not set
+# CONFIG_FEATURE_HDPARM_HDIO_GETSET_DMA is not set
+CONFIG_MAKEDEVS=y
+# CONFIG_FEATURE_MAKEDEVS_LEAF is not set
+CONFIG_FEATURE_MAKEDEVS_TABLE=y
+# CONFIG_MAN is not set
+CONFIG_MICROCOM=y
+CONFIG_MOUNTPOINT=y
+CONFIG_MT=y
+# CONFIG_RAIDAUTORUN is not set
+# CONFIG_READAHEAD is not set
+# CONFIG_RFKILL is not set
+CONFIG_RUNLEVEL=y
+# CONFIG_RX is not set
+CONFIG_SETSID=y
+CONFIG_STRINGS=y
+# CONFIG_TASKSET is not set
+# CONFIG_FEATURE_TASKSET_FANCY is not set
+CONFIG_TIME=y
+# CONFIG_TIMEOUT is not set
+# CONFIG_TTYSIZE is not set
+# CONFIG_VOLNAME is not set
+# CONFIG_WALL is not set
+CONFIG_WATCHDOG=y
+
+#
+# Networking Utilities
+#
+# CONFIG_NBDCLIENT is not set
+# CONFIG_NC is not set
+# CONFIG_NC_SERVER is not set
+# CONFIG_NC_EXTRA is not set
+# CONFIG_NC_110_COMPAT is not set
+CONFIG_FEATURE_IPV6=y
+# CONFIG_FEATURE_UNIX_LOCAL is not set
+# CONFIG_FEATURE_PREFER_IPV4_ADDRESS is not set
+# CONFIG_VERBOSE_RESOLUTION_ERRORS is not set
+# CONFIG_ARP is not set
+CONFIG_ARPING=y
+# CONFIG_BRCTL is not set
+# CONFIG_FEATURE_BRCTL_FANCY is not set
+# CONFIG_FEATURE_BRCTL_SHOW is not set
+CONFIG_DNSD=y
+CONFIG_ETHER_WAKE=y
+# CONFIG_FAKEIDENTD is not set
+# CONFIG_FTPD is not set
+# CONFIG_FEATURE_FTP_WRITE is not set
+# CONFIG_FEATURE_FTPD_ACCEPT_BROKEN_LIST is not set
+# CONFIG_FTPGET is not set
+# CONFIG_FTPPUT is not set
+# CONFIG_FEATURE_FTPGETPUT_LONG_OPTIONS is not set
+CONFIG_HOSTNAME=y
+# CONFIG_HTTPD is not set
+# CONFIG_FEATURE_HTTPD_RANGES is not set
+# CONFIG_FEATURE_HTTPD_USE_SENDFILE is not set
+# CONFIG_FEATURE_HTTPD_SETUID is not set
+# CONFIG_FEATURE_HTTPD_BASIC_AUTH is not set
+# CONFIG_FEATURE_HTTPD_AUTH_MD5 is not set
+# CONFIG_FEATURE_HTTPD_CGI is not set
+# CONFIG_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR is not set
+# CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV is not set
+# CONFIG_FEATURE_HTTPD_ENCODE_URL_STR is not set
+# CONFIG_FEATURE_HTTPD_ERROR_PAGES is not set
+# CONFIG_FEATURE_HTTPD_PROXY is not set
+# CONFIG_FEATURE_HTTPD_GZIP is not set
+CONFIG_IFCONFIG=y
+CONFIG_FEATURE_IFCONFIG_STATUS=y
+CONFIG_FEATURE_IFCONFIG_SLIP=y
+CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ=y
+CONFIG_FEATURE_IFCONFIG_HW=y
+# CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS is not set
+# CONFIG_IFENSLAVE is not set
+# CONFIG_IFPLUGD is not set
+CONFIG_IFUPDOWN=y
+CONFIG_IFUPDOWN_IFSTATE_PATH="/var/run/ifstate"
+CONFIG_FEATURE_IFUPDOWN_IP=y
+# CONFIG_FEATURE_IFUPDOWN_IP_BUILTIN is not set
+# CONFIG_FEATURE_IFUPDOWN_IFCONFIG_BUILTIN is not set
+CONFIG_FEATURE_IFUPDOWN_IPV4=y
+CONFIG_FEATURE_IFUPDOWN_IPV6=y
+CONFIG_FEATURE_IFUPDOWN_MAPPING=y
+# CONFIG_FEATURE_IFUPDOWN_EXTERNAL_DHCP is not set
+CONFIG_INETD=y
+CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_ECHO=y
+CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD=y
+CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_TIME=y
+CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME=y
+CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN=y
+# CONFIG_FEATURE_INETD_RPC is not set
+CONFIG_IP=y
+CONFIG_FEATURE_IP_ADDRESS=y
+CONFIG_FEATURE_IP_LINK=y
+CONFIG_FEATURE_IP_ROUTE=y
+CONFIG_FEATURE_IP_TUNNEL=y
+CONFIG_FEATURE_IP_RULE=y
+CONFIG_FEATURE_IP_SHORT_FORMS=y
+# CONFIG_FEATURE_IP_RARE_PROTOCOLS is not set
+CONFIG_IPADDR=y
+CONFIG_IPLINK=y
+CONFIG_IPROUTE=y
+CONFIG_IPTUNNEL=y
+CONFIG_IPRULE=y
+# CONFIG_IPCALC is not set
+# CONFIG_FEATURE_IPCALC_FANCY is not set
+# CONFIG_FEATURE_IPCALC_LONG_OPTIONS is not set
+CONFIG_NAMEIF=y
+# CONFIG_FEATURE_NAMEIF_EXTENDED is not set
+CONFIG_NETSTAT=y
+# CONFIG_FEATURE_NETSTAT_WIDE is not set
+# CONFIG_FEATURE_NETSTAT_PRG is not set
+CONFIG_NSLOOKUP=y
+# CONFIG_NTPD is not set
+# CONFIG_FEATURE_NTPD_SERVER is not set
+CONFIG_PING=y
+# CONFIG_PING6 is not set
+CONFIG_FEATURE_FANCY_PING=y
+# CONFIG_PSCAN is not set
+CONFIG_ROUTE=y
+# CONFIG_SLATTACH is not set
+# CONFIG_TCPSVD is not set
+CONFIG_TELNET=y
+CONFIG_FEATURE_TELNET_TTYPE=y
+CONFIG_FEATURE_TELNET_AUTOLOGIN=y
+# CONFIG_TELNETD is not set
+# CONFIG_FEATURE_TELNETD_STANDALONE is not set
+# CONFIG_FEATURE_TELNETD_INETD_WAIT is not set
+CONFIG_TFTP=y
+# CONFIG_TFTPD is not set
+
+#
+# Common options for tftp/tftpd
+#
+CONFIG_FEATURE_TFTP_GET=y
+CONFIG_FEATURE_TFTP_PUT=y
+CONFIG_FEATURE_TFTP_BLOCKSIZE=y
+# CONFIG_FEATURE_TFTP_PROGRESS_BAR is not set
+# CONFIG_TFTP_DEBUG is not set
+CONFIG_TRACEROUTE=y
+# CONFIG_TRACEROUTE6 is not set
+# CONFIG_FEATURE_TRACEROUTE_VERBOSE is not set
+# CONFIG_FEATURE_TRACEROUTE_SOURCE_ROUTE is not set
+# CONFIG_FEATURE_TRACEROUTE_USE_ICMP is not set
+# CONFIG_TUNCTL is not set
+# CONFIG_FEATURE_TUNCTL_UG is not set
+# CONFIG_UDHCPD is not set
+# CONFIG_DHCPRELAY is not set
+# CONFIG_DUMPLEASES is not set
+# CONFIG_FEATURE_UDHCPD_WRITE_LEASES_EARLY is not set
+CONFIG_DHCPD_LEASES_FILE=""
+CONFIG_UDHCPC=y
+CONFIG_FEATURE_UDHCPC_ARPING=y
+# CONFIG_FEATURE_UDHCP_PORT is not set
+CONFIG_UDHCP_DEBUG=0
+# CONFIG_FEATURE_UDHCP_RFC3397 is not set
+CONFIG_UDHCPC_DEFAULT_SCRIPT="/usr/share/udhcpc/default.script"
+CONFIG_UDHCPC_SLACK_FOR_BUGGY_SERVERS=80
+CONFIG_IFUPDOWN_UDHCPC_CMD_OPTIONS="-R -n"
+# CONFIG_UDPSVD is not set
+CONFIG_VCONFIG=y
+CONFIG_WGET=y
+CONFIG_FEATURE_WGET_STATUSBAR=y
+CONFIG_FEATURE_WGET_AUTHENTICATION=y
+CONFIG_FEATURE_WGET_LONG_OPTIONS=y
+CONFIG_FEATURE_WGET_TIMEOUT=y
+# CONFIG_ZCIP is not set
+
+#
+# Print Utilities
+#
+# CONFIG_LPD is not set
+# CONFIG_LPR is not set
+# CONFIG_LPQ is not set
+
+#
+# Mail Utilities
+#
+# CONFIG_MAKEMIME is not set
+CONFIG_FEATURE_MIME_CHARSET=""
+# CONFIG_POPMAILDIR is not set
+# CONFIG_FEATURE_POPMAILDIR_DELIVERY is not set
+# CONFIG_REFORMIME is not set
+# CONFIG_FEATURE_REFORMIME_COMPAT is not set
+# CONFIG_SENDMAIL is not set
+
+#
+# Process Utilities
+#
+# CONFIG_IOSTAT is not set
+# CONFIG_MPSTAT is not set
+# CONFIG_PMAP is not set
+# CONFIG_POWERTOP is not set
+# CONFIG_SMEMCAP is not set
+CONFIG_FREE=y
+CONFIG_FUSER=y
+CONFIG_KILL=y
+CONFIG_KILLALL=y
+CONFIG_KILLALL5=y
+# CONFIG_NMETER is not set
+# CONFIG_PGREP is not set
+CONFIG_PIDOF=y
+CONFIG_FEATURE_PIDOF_SINGLE=y
+CONFIG_FEATURE_PIDOF_OMIT=y
+# CONFIG_PKILL is not set
+CONFIG_PS=y
+CONFIG_FEATURE_PS_WIDE=y
+# CONFIG_FEATURE_PS_TIME is not set
+# CONFIG_FEATURE_PS_ADDITIONAL_COLUMNS is not set
+# CONFIG_FEATURE_PS_UNUSUAL_SYSTEMS is not set
+CONFIG_RENICE=y
+CONFIG_BB_SYSCTL=y
+CONFIG_TOP=y
+CONFIG_FEATURE_TOP_CPU_USAGE_PERCENTAGE=y
+CONFIG_FEATURE_TOP_CPU_GLOBAL_PERCENTS=y
+# CONFIG_FEATURE_TOP_SMP_CPU is not set
+# CONFIG_FEATURE_TOP_DECIMALS is not set
+# CONFIG_FEATURE_TOP_SMP_PROCESS is not set
+# CONFIG_FEATURE_TOPMEM is not set
+# CONFIG_FEATURE_SHOW_THREADS is not set
+CONFIG_UPTIME=y
+CONFIG_WATCH=y
+
+#
+# Runit Utilities
+#
+# CONFIG_RUNSV is not set
+# CONFIG_RUNSVDIR is not set
+# CONFIG_FEATURE_RUNSVDIR_LOG is not set
+# CONFIG_SV is not set
+CONFIG_SV_DEFAULT_SERVICE_DIR=""
+# CONFIG_SVLOGD is not set
+# CONFIG_CHPST is not set
+# CONFIG_SETUIDGID is not set
+# CONFIG_ENVUIDGID is not set
+# CONFIG_ENVDIR is not set
+# CONFIG_SOFTLIMIT is not set
+# CONFIG_CHCON is not set
+# CONFIG_FEATURE_CHCON_LONG_OPTIONS is not set
+# CONFIG_GETENFORCE is not set
+# CONFIG_GETSEBOOL is not set
+# CONFIG_LOAD_POLICY is not set
+# CONFIG_MATCHPATHCON is not set
+# CONFIG_RESTORECON is not set
+# CONFIG_RUNCON is not set
+# CONFIG_FEATURE_RUNCON_LONG_OPTIONS is not set
+# CONFIG_SELINUXENABLED is not set
+# CONFIG_SETENFORCE is not set
+# CONFIG_SETFILES is not set
+# CONFIG_FEATURE_SETFILES_CHECK_OPTION is not set
+# CONFIG_SETSEBOOL is not set
+# CONFIG_SESTATUS is not set
+
+#
+# Shells
+#
+CONFIG_ASH=y
+CONFIG_ASH_BASH_COMPAT=y
+CONFIG_ASH_JOB_CONTROL=y
+CONFIG_ASH_ALIAS=y
+CONFIG_ASH_GETOPTS=y
+CONFIG_ASH_BUILTIN_ECHO=y
+CONFIG_ASH_BUILTIN_PRINTF=y
+CONFIG_ASH_BUILTIN_TEST=y
+CONFIG_ASH_CMDCMD=y
+# CONFIG_ASH_MAIL is not set
+CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
+CONFIG_ASH_RANDOM_SUPPORT=y
+CONFIG_ASH_EXPAND_PRMT=y
+# CONFIG_CTTYHACK is not set
+# CONFIG_HUSH is not set
+# CONFIG_HUSH_BASH_COMPAT is not set
+# CONFIG_HUSH_BRACE_EXPANSION is not set
+# CONFIG_HUSH_HELP is not set
+# CONFIG_HUSH_INTERACTIVE is not set
+# CONFIG_HUSH_SAVEHISTORY is not set
+# CONFIG_HUSH_JOB is not set
+# CONFIG_HUSH_TICK is not set
+# CONFIG_HUSH_IF is not set
+# CONFIG_HUSH_LOOPS is not set
+# CONFIG_HUSH_CASE is not set
+# CONFIG_HUSH_FUNCTIONS is not set
+# CONFIG_HUSH_LOCAL is not set
+# CONFIG_HUSH_RANDOM_SUPPORT is not set
+# CONFIG_HUSH_EXPORT_N is not set
+# CONFIG_HUSH_MODE_X is not set
+# CONFIG_MSH is not set
+CONFIG_FEATURE_SH_IS_ASH=y
+# CONFIG_FEATURE_SH_IS_HUSH is not set
+# CONFIG_FEATURE_SH_IS_NONE is not set
+# CONFIG_FEATURE_BASH_IS_ASH is not set
+# CONFIG_FEATURE_BASH_IS_HUSH is not set
+CONFIG_FEATURE_BASH_IS_NONE=y
+CONFIG_SH_MATH_SUPPORT=y
+# CONFIG_SH_MATH_SUPPORT_64 is not set
+CONFIG_FEATURE_SH_EXTRA_QUIET=y
+# CONFIG_FEATURE_SH_STANDALONE is not set
+# CONFIG_FEATURE_SH_NOFORK is not set
+
+#
+# System Logging Utilities
+#
+CONFIG_SYSLOGD=y
+CONFIG_FEATURE_ROTATE_LOGFILE=y
+CONFIG_FEATURE_REMOTE_LOG=y
+# CONFIG_FEATURE_SYSLOGD_DUP is not set
+CONFIG_FEATURE_SYSLOGD_READ_BUFFER_SIZE=256
+# CONFIG_FEATURE_IPC_SYSLOG is not set
+CONFIG_FEATURE_IPC_SYSLOG_BUFFER_SIZE=0
+# CONFIG_LOGREAD is not set
+# CONFIG_FEATURE_LOGREAD_REDUCED_LOCKING is not set
+CONFIG_KLOGD=y
+CONFIG_FEATURE_KLOGD_KLOGCTL=y
+CONFIG_LOGGER=y
diff -urN buildroot-2011.11.orig/board/intel/scc/Config.in buildroot-2011.11/board/intel/scc/Config.in
--- buildroot-2011.11.orig/board/intel/scc/Config.in	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/Config.in	2011-12-21 10:41:24.605900792 +0100
@@ -0,0 +1,26 @@
+menuconfig BR2_TARGET_SCC
+	bool "Single-chip cloud computer Board"
+	depends on BR2_i386
+	help
+	  Board based on SCC - Rocky Lake
+
+if BR2_TARGET_SCC
+
+config BR2_BOARD_NAME
+	string "Board name"
+	default "scc"
+
+config BR2_BOARD_PATH
+	string "Board Path"
+	default "target/device/scc/"
+
+config BR2_LINUX_KERNEL_PATCH
+	string "Linux kernel patch directory"
+	default "target/device/scc/kernel-patches/"
+
+config BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG
+	string "Linux kernel configuration file"
+	default "target/device/scc/$(BR2_BOARD_NAME)-linux-$(BR2_LINUX_KERNEL_VERSION).config"
+
+endif
+
diff -urN buildroot-2011.11.orig/board/intel/scc/crosstool-ng.config buildroot-2011.11/board/intel/scc/crosstool-ng.config
--- buildroot-2011.11.orig/board/intel/scc/crosstool-ng.config	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/crosstool-ng.config	2011-12-21 10:41:24.605900792 +0100
@@ -0,0 +1,426 @@
+#
+# Automatically generated make config: don't edit
+# crosstool-NG 1.13.2 Configuration
+# Thu Dec  8 10:39:08 2011
+#
+CT_CONFIGURE_has_xzutils=y
+CT_CONFIGURE_has_cvs=y
+CT_CONFIGURE_has_svn=y
+CT_BACKEND=y
+CT_MODULES=y
+
+#
+# Paths and misc options
+#
+
+#
+# crosstool-NG behavior
+#
+# CT_OBSOLETE is not set
+CT_EXPERIMENTAL=y
+
+#
+# Paths
+#
+CT_LOCAL_TARBALLS_DIR="/home.local/jbrummer/sccLinux/buildroot-2011.11/dl"
+CT_SAVE_TARBALLS=y
+CT_WORK_DIR="${CT_TOP_DIR}/.build"
+CT_PREFIX_DIR="/home/jbrummer/sccLinux/buildroot-2011.11/output/host/usr"
+CT_INSTALL_DIR="${CT_PREFIX_DIR}"
+CT_REMOVE_DOCS=y
+# CT_INSTALL_DIR_RO is not set
+CT_STRIP_ALL_TOOLCHAIN_EXECUTABLES=y
+
+#
+# Downloading
+#
+# CT_FORBID_DOWNLOAD is not set
+# CT_FORCE_DOWNLOAD is not set
+CT_CONNECT_TIMEOUT=10
+# CT_ONLY_DOWNLOAD is not set
+# CT_USE_MIRROR is not set
+
+#
+# Extracting
+#
+# CT_FORCE_EXTRACT is not set
+CT_OVERIDE_CONFIG_GUESS_SUB=y
+# CT_ONLY_EXTRACT is not set
+CT_PATCH_BUNDLED=y
+# CT_PATCH_LOCAL is not set
+# CT_PATCH_BUNDLED_LOCAL is not set
+# CT_PATCH_LOCAL_BUNDLED is not set
+# CT_PATCH_BUNDLED_FALLBACK_LOCAL is not set
+# CT_PATCH_LOCAL_FALLBACK_BUNDLED is not set
+# CT_PATCH_NONE is not set
+CT_PATCH_ORDER="bundled"
+
+#
+# Build behavior
+#
+
+#
+# Build options hiden
+#
+CT_PARALLEL_JOBS=0
+CT_LOAD=0
+CT_USE_PIPES=y
+CT_EXTRA_FLAGS_FOR_HOST=""
+CT_CONFIG_SHELL_CUSTOM_PATH="/bin/sh"
+CT_CONFIG_SHELL="/bin/sh"
+
+#
+# Logging
+#
+# CT_LOG_ERROR is not set
+# CT_LOG_WARN is not set
+CT_LOG_INFO=y
+# CT_LOG_EXTRA is not set
+# CT_LOG_ALL is not set
+# CT_LOG_DEBUG is not set
+CT_LOG_LEVEL_MAX="INFO"
+# CT_LOG_SEE_TOOLS_WARN is not set
+CT_LOG_PROGRESS_BAR=y
+CT_LOG_TO_FILE=y
+CT_LOG_FILE_COMPRESS=y
+
+#
+# Target options
+#
+CT_ARCH="x86"
+CT_ARCH_SUPPORTS_32=y
+CT_ARCH_SUPPORTS_64=y
+CT_ARCH_SUPPORT_ARCH=y
+CT_ARCH_SUPPORT_CPU=y
+CT_ARCH_SUPPORT_TUNE=y
+CT_ARCH_DEFAULT_32=y
+CT_ARCH_ARCH="i586"
+CT_ARCH_CPU="pentium"
+CT_ARCH_TUNE="i586"
+CT_ARCH_32=y
+# CT_ARCH_64 is not set
+CT_ARCH_BITNESS=32
+CT_ARCH_FLOAT_HW=y
+# CT_ARCH_FLOAT_SW is not set
+CT_TARGET_CFLAGS="-march=pentium"
+CT_TARGET_LDFLAGS=""
+CT_ARCH_x86=y
+CT_ARCH_x86_AVAILABLE=y
+
+#
+# Generic target options
+#
+CT_ARCH_USE_MMU=y
+
+#
+# Target optimisations
+#
+
+#
+# Toolchain options
+#
+
+#
+# General toolchain options
+#
+CT_FORCE_SYSROOT=y
+CT_USE_SYSROOT=y
+CT_SYSROOT_NAME="sysroot"
+CT_SYSROOT_DIR_PREFIX=""
+CT_WANTS_STATIC_LINK=y
+# CT_STATIC_TOOLCHAIN is not set
+CT_TOOLCHAIN_PKGVERSION="buildroot 2011.11"
+CT_TOOLCHAIN_BUGURL=""
+
+#
+# Tuple completion and aliasing
+#
+CT_TARGET_VENDOR="unknown"
+CT_TARGET_ALIAS_SED_EXPR=""
+CT_TARGET_ALIAS="i586-linux"
+
+#
+# Toolchain type
+#
+# CT_NATIVE is not set
+CT_CROSS=y
+# CT_CROSS_NATIVE is not set
+# CT_CANADIAN is not set
+CT_TOOLCHAIN_TYPE="cross"
+
+#
+# Build system
+#
+CT_BUILD=""
+CT_BUILD_PREFIX=""
+CT_BUILD_SUFFIX=""
+
+#
+# Operating System
+#
+CT_KERNEL_SUPPORTS_SHARED_LIBS=y
+CT_KERNEL="linux"
+CT_KERNEL_VERSION="3.0.4"
+CT_KERNEL_linux=y
+CT_KERNEL_linux_AVAILABLE=y
+CT_KERNEL_V_3_0_4=y
+# CT_KERNEL_V_3_0_3 is not set
+# CT_KERNEL_V_3_0_2 is not set
+# CT_KERNEL_V_3_0_1 is not set
+# CT_KERNEL_V_3_0 is not set
+# CT_KERNEL_V_2_6_39_4 is not set
+# CT_KERNEL_V_2_6_38_8 is not set
+# CT_KERNEL_V_2_6_37_6 is not set
+# CT_KERNEL_V_2_6_36_4 is not set
+# CT_KERNEL_V_2_6_35_14 is not set
+# CT_KERNEL_V_2_6_34_10 is not set
+# CT_KERNEL_V_2_6_33_19 is not set
+# CT_KERNEL_V_2_6_32_46 is not set
+# CT_KERNEL_V_2_6_31_14 is not set
+# CT_KERNEL_V_2_6_27_59 is not set
+# CT_KERNEL_LINUX_CUSTOM is not set
+
+#
+# Common kernel options
+#
+CT_SHARED_LIBS=y
+
+#
+# linux other options
+#
+CT_KERNEL_LINUX_VERBOSITY_0=y
+# CT_KERNEL_LINUX_VERBOSITY_1 is not set
+# CT_KERNEL_LINUX_VERBOSITY_2 is not set
+CT_KERNEL_LINUX_VERBOSE_LEVEL=0
+CT_KERNEL_LINUX_INSTALL_CHECK=y
+
+#
+# Binary utilities
+#
+CT_ARCH_BINFMT_ELF=y
+
+#
+# GNU binutils
+#
+# CT_BINUTILS_V_2_21_53 is not set
+CT_BINUTILS_V_2_21_1a=y
+# CT_BINUTILS_V_2_20_1a is not set
+# CT_BINUTILS_V_2_19_1a is not set
+# CT_BINUTILS_V_2_18a is not set
+CT_BINUTILS_VERSION="2.21.1a"
+CT_BINUTILS_2_21_or_later=y
+CT_BINUTILS_2_20_or_later=y
+CT_BINUTILS_2_19_or_later=y
+CT_BINUTILS_2_18_or_later=y
+CT_BINUTILS_HAS_GOLD=y
+CT_BINUTILS_GOLD_SUPPORTS_ARCH=y
+CT_BINUTILS_HAS_PLUGINS=y
+CT_BINUTILS_HAS_PKGVERSION_BUGURL=y
+CT_BINUTILS_FORCE_LD_BFD=y
+CT_BINUTILS_LINKER_LD=y
+# CT_BINUTILS_LINKER_LD_GOLD is not set
+# CT_BINUTILS_LINKER_GOLD_LD is not set
+CT_BINUTILS_LINKERS_LIST="ld"
+CT_BINUTILS_LINKER_DEFAULT="bfd"
+CT_BINUTILS_PLUGINS=y
+CT_BINUTILS_EXTRA_CONFIG_ARRAY=""
+
+#
+# C compiler
+#
+CT_CC="gcc"
+CT_CC_VERSION="4.4.6"
+CT_CC_gcc=y
+# CT_CC_GCC_SHOW_LINARO is not set
+# CT_CC_V_4_6_1 is not set
+# CT_CC_V_4_6_0 is not set
+# CT_CC_V_4_5_3 is not set
+# CT_CC_V_4_5_2 is not set
+# CT_CC_V_4_5_1 is not set
+# CT_CC_V_4_5_0 is not set
+CT_CC_V_4_4_6=y
+# CT_CC_V_4_4_5 is not set
+# CT_CC_V_4_4_4 is not set
+# CT_CC_V_4_4_3 is not set
+# CT_CC_V_4_4_2 is not set
+# CT_CC_V_4_4_1 is not set
+# CT_CC_V_4_4_0 is not set
+# CT_CC_V_4_3_6 is not set
+# CT_CC_V_4_3_5 is not set
+# CT_CC_V_4_3_4 is not set
+# CT_CC_V_4_3_3 is not set
+# CT_CC_V_4_3_2 is not set
+# CT_CC_V_4_3_1 is not set
+# CT_CC_V_4_2_4 is not set
+# CT_CC_V_4_2_2 is not set
+CT_CC_GCC_4_2_or_later=y
+CT_CC_GCC_4_3_or_later=y
+CT_CC_GCC_4_4=y
+CT_CC_GCC_4_4_or_later=y
+CT_CC_GCC_HAS_GRAPHITE=y
+CT_CC_GCC_HAS_PKGVERSION_BUGURL=y
+CT_CC_GCC_ENABLE_PLUGINS=y
+CT_CC_GCC_USE_GMP_MPFR=y
+CT_CC_GCC_USE_PPL_CLOOG=y
+CT_CC_LANG_FORTRAN=y
+CT_CC_SUPPORT_CXX=y
+CT_CC_SUPPORT_FORTRAN=y
+CT_CC_SUPPORT_JAVA=y
+CT_CC_SUPPORT_ADA=y
+CT_CC_SUPPORT_OBJC=y
+CT_CC_SUPPORT_OBJCXX=y
+
+#
+# Additional supported languages:
+#
+CT_CC_LANG_CXX=y
+# CT_CC_LANG_JAVA is not set
+# CT_CC_LANG_ADA is not set
+# CT_CC_LANG_OBJC is not set
+# CT_CC_LANG_OBJCXX is not set
+CT_CC_LANG_OTHERS=""
+
+#
+# gcc other options
+#
+CT_CC_ENABLE_CXX_FLAGS=""
+CT_CC_CORE_EXTRA_CONFIG_ARRAY=""
+CT_CC_EXTRA_CONFIG_ARRAY=""
+CT_CC_STATIC_LIBSTDCXX=y
+
+#
+# Optimisation features
+#
+CT_CC_GCC_USE_GRAPHITE=y
+
+#
+# Settings for libraries running on target
+#
+# CT_CC_GCC_ENABLE_TARGET_OPTSPACE is not set
+# CT_CC_GCC_LIBMUDFLAP is not set
+# CT_CC_GCC_LIBGOMP is not set
+# CT_CC_GCC_LIBSSP is not set
+
+#
+# Misc. obscure options.
+#
+CT_CC_CXA_ATEXIT=y
+# CT_CC_GCC_DISABLE_PCH is not set
+CT_CC_GCC_SJLJ_EXCEPTIONS=m
+CT_CC_GCC_LDBL_128=y
+
+#
+# C-library
+#
+CT_LIBC="glibc"
+CT_LIBC_VERSION="2.9"
+CT_LIBC_glibc=y
+CT_LIBC_glibc_AVAILABLE=y
+CT_LIBC_GLIBC_TARBALL=y
+# CT_LIBC_GLIBC_V_2_14 is not set
+# CT_LIBC_GLIBC_V_2_13 is not set
+# CT_LIBC_GLIBC_V_2_12_2 is not set
+# CT_LIBC_GLIBC_V_2_12_1 is not set
+# CT_LIBC_GLIBC_V_2_11_1 is not set
+# CT_LIBC_GLIBC_V_2_11 is not set
+# CT_LIBC_GLIBC_V_2_10_1 is not set
+CT_LIBC_GLIBC_V_2_9=y
+# CT_LIBC_GLIBC_V_2_8 is not set
+CT_LIBC_SUPPORT_THREADS_ANY=y
+CT_LIBC_SUPPORT_NPTL=y
+CT_THREADS="nptl"
+
+#
+# Common C library options
+#
+CT_THREADS_NPTL=y
+CT_LIBC_XLDD=y
+CT_LIBC_glibc_familly=y
+CT_LIBC_GLIBC_EXTRA_CONFIG_ARRAY=""
+CT_LIBC_GLIBC_CONFIGPARMS=""
+CT_LIBC_GLIBC_EXTRA_CFLAGS=""
+CT_LIBC_EXTRA_CC_ARGS=""
+# CT_LIBC_ENABLE_FORTIFIED_BUILD is not set
+# CT_LIBC_DISABLE_VERSIONING is not set
+CT_LIBC_OLDEST_ABI=""
+CT_LIBC_GLIBC_FORCE_UNWIND=y
+# CT_LIBC_GLIBC_USE_PORTS is not set
+CT_LIBC_ADDONS_LIST=""
+# CT_LIBC_LOCALES is not set
+# CT_LIBC_GLIBC_KERNEL_VERSION_NONE is not set
+CT_LIBC_GLIBC_KERNEL_VERSION_AS_HEADERS=y
+# CT_LIBC_GLIBC_KERNEL_VERSION_CHOSEN is not set
+CT_LIBC_GLIBC_MIN_KERNEL="3.0.4"
+
+#
+# glibc other options
+#
+
+#
+# Debug facilities
+#
+# CT_DEBUG_gdb is not set
+
+#
+# Companion libraries
+#
+CT_COMPLIBS_NEEDED=y
+CT_GMP_NEEDED=y
+CT_MPFR_NEEDED=y
+CT_PPL_NEEDED=y
+CT_CLOOG_NEEDED=y
+CT_COMPLIBS=y
+CT_GMP=y
+CT_MPFR=y
+CT_PPL=y
+CT_CLOOG=y
+# CT_GMP_V_5_0_2 is not set
+# CT_GMP_V_5_0_1 is not set
+CT_GMP_V_4_3_2=y
+# CT_GMP_V_4_3_1 is not set
+# CT_GMP_V_4_3_0 is not set
+CT_GMP_VERSION="4.3.2"
+# CT_MPFR_V_3_0_1 is not set
+CT_MPFR_V_3_0_0=y
+# CT_MPFR_V_2_4_2 is not set
+# CT_MPFR_V_2_4_1 is not set
+# CT_MPFR_V_2_4_0 is not set
+CT_MPFR_VERSION="3.0.0"
+# CT_PPL_V_0_11_2 is not set
+# CT_PPL_V_0_11_1 is not set
+# CT_PPL_V_0_11 is not set
+CT_PPL_V_0_10_2=y
+CT_PPL_VERSION="0.10.2"
+# CT_CLOOG_V_0_15_11 is not set
+CT_CLOOG_V_0_15_10=y
+# CT_CLOOG_V_0_15_9 is not set
+# CT_CLOOG_V_0_15_8 is not set
+# CT_CLOOG_V_0_15_7 is not set
+# CT_CLOOG_V_0_15_6 is not set
+CT_CLOOG_VERSION="0.15.10"
+CT_CLOOG_0_15_1x=y
+CT_CLOOG_NEEDS_AUTORECONF=y
+
+#
+# Companion libraries common options
+#
+# CT_COMPLIBS_CHECK is not set
+
+#
+# Companion tools
+#
+
+#
+# READ HELP before you say 'Y' below !!!
+#
+CT_COMP_TOOLS=y
+CT_COMP_TOOLS_make=y
+CT_COMP_TOOLS_m4=y
+CT_COMP_TOOLS_autoconf=y
+CT_COMP_TOOLS_automake=y
+CT_COMP_TOOLS_libtool=y
+
+#
+# Test suite
+#
+# CT_TEST_SUITE_GCC is not set
diff -urN buildroot-2011.11.orig/board/intel/scc/device_table.txt buildroot-2011.11/board/intel/scc/device_table.txt
--- buildroot-2011.11.orig/board/intel/scc/device_table.txt	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/device_table.txt	2011-12-21 10:41:24.605900792 +0100
@@ -0,0 +1,86 @@
+# When building a target filesystem, it is desirable to not have to become
+# root and then run 'mknod' a thousand times. Using a device table you can
+# create device nodes and directories "on the fly".
+#
+# This is a sample device table file for use with genext2fs. You can do all
+# sorts of interesting things with a device table file.  For example, if you
+# want to adjust the permissions on a particular file you can just add an
+# entry like:
+#   /sbin/foobar        f       2755    0       0       -       -       -       -       -
+# and (assuming the file /sbin/foobar exists) it will be made setuid root
+# (regardless of what its permissions are on the host filesystem.
+# Furthermore, you can use a single table entry to create a many device
+# minors. For example, if I wanted to create /dev/hda and /dev/hda[0-15] I
+# could just use the following two table entries:
+#   /dev/hda    b       640     0       0       3       0       0       0       -
+#   /dev/hda    b       640     0       0       3       1       1       1       15
+#
+# Device table entries take the form of:
+# <name>    <type>      <mode>  <uid>   <gid>   <major> <minor> <start> <inc>   <count>
+# where name is the file name,  type can be one of:
+#       f       A regular file
+#       d       Directory
+#       c       Character special device file
+#       b       Block special device file
+#       p       Fifo (named pipe)
+# uid is the user id for the target file, gid is the group id for the target
+# file.  The rest of the entries (major, minor, etc) apply only to device
+# special files.
+
+#<name>		<type>	<mode>	<uid>	<gid>	<major>	<minor>	<start>	<inc>	<count>
+/dev		d	755	0	0	-	-	-	-	-
+/dev/null	c	666	0	0	1	3	0	0	-
+/dev/console	c	666	0	0	5	1	-	-	-
+
+/dev/rckncm	c	644	0	0	222	0	-	-	-
+/dev/rckmpb	c	644	0	0	222	1	-	-	-
+/dev/rckdcm	c	644	0	0	222	2	-	-	-
+
+/tmp		d	1777	0	0	-	-	-	-	-
+/etc		d	755	0	0	-	-	-	-	-
+/sys		d	755	0	0	-	-	-	-	-
+/proc		d	755	0	0	-	-	-	-	-
+/lost+found	d	700	0	0	-	-	-	-	-
+/var/lock	d	1777	0	0	-	-	-	-	-
+/var/log	d	755	0	0	-	-	-	-	-
+/var/run	d	1777	0	0	-	-	-	-	-
+/var/tmp	d	1777	0	0	-	-	-	-	-
+/shared		d	755	0	0	-	-	-	-	-
+
+#<name>					<type>	<mode>	<uid>	<gid>	<major>	<minor>	<start>	<inc>	<count>
+/bin/busybox				f	4755	0	0	-	-	-	-	-
+/etc/shadow				f	600	0	0	-	-	-	-	-
+/etc/passwd				f	644	0	0	-	-	-	-	-
+/etc/network/if-up.d			d	755	0	0	-	-	-	-	-
+/etc/network/if-pre-up.d		d	755	0	0	-	-	-	-	-
+/etc/network/if-down.d			d	755	0	0	-	-	-	-	-
+/etc/network/if-post-down.d		d	755	0	0	-	-	-	-	-
+
+/etc/init.d/rcS			f	755	0	0	-	-	-	-	-
+
+/etc/init.d/S01hotplug	f	755	0	0	-	-	-	-	-
+/etc/init.d/S02hostname	f	755	0	0	-	-	-	-	-
+/etc/init.d/S08syslog	f	755	0	0	-	-	-	-	-
+/etc/init.d/S09klog		f	755	0	0	-	-	-	-	-
+/etc/init.d/S20urandom	f	755	0	0	-	-	-	-	-
+/etc/init.d/S40network	f	755	0	0	-	-	-	-	-
+/etc/init.d/S41scc-network	f	755	0	0	-	-	-	-	-
+/etc/init.d/S42mount	f	755	0	0	-	-	-	-	-
+/etc/init.d/S45rhid		f	755	0	0	-	-	-	-	-
+/etc/init.d/S55gpm		f	755	0	0	-	-	-	-	-
+/etc/init.d/S60cpuutil	f	755	0	0	-	-	-	-	-
+
+/etc/ssh_host_dsa_key	f	600	0	0	-	-	-	-	-
+/etc/ssh_host_ecdsa_key	f	600	0	0	-	-	-	-	-
+/etc/ssh_host_rsa_key	f	600	0	0	-	-	-	-	-
+/etc/ssh_host_key		f	600	0	0	-	-	-	-	-
+
+/root/.ssh/id_rsa		f	600	0	0	-	-	-	-	-
+/root/.ssh/known_hosts	f	600	0	0	-	-	-	-	-
+
+/usr/bin/sccdsp			f	755	0	0	-	-	-	-	-
+/usr/share  	                f	755	0	0	-	-	-	-	-
+/usr/share/games                f	755	0	0	-	-	-	-	-
+/usr/share/games/imaze  	f	755	0	0	-	-	-	-	-
+/usr/bin/imaze			f	755	0	0	-	-	-	-	-
+/usr/games			f	755	0	0	-	-	-	-	-
diff -urN buildroot-2011.11.orig/board/intel/scc/kernel-patches/linux-3.1.4-100-scc.patch buildroot-2011.11/board/intel/scc/kernel-patches/linux-3.1.4-100-scc.patch
--- buildroot-2011.11.orig/board/intel/scc/kernel-patches/linux-3.1.4-100-scc.patch	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/kernel-patches/linux-3.1.4-100-scc.patch	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,10189 @@
+diff -urN linux-3.1.4/arch/x86/boot/compressed/Makefile linux-3.1.4-scc/arch/x86/boot/compressed/Makefile
+--- linux-3.1.4/arch/x86/boot/compressed/Makefile	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/boot/compressed/Makefile	2011-12-20 15:27:07.565882437 +0100
+@@ -23,9 +23,15 @@
+ 
+ hostprogs-y	:= mkpiggy
+ 
++ifeq ($(CONFIG_KERNEL_NONE),y)
++OBJCOPYFLAGS_vmlinux :=
++$(obj)/vmlinux: vmlinux FORCE
++	$(call if_changed,objcopy)
++else
+ $(obj)/vmlinux: $(obj)/vmlinux.lds $(obj)/head_$(BITS).o $(obj)/misc.o $(obj)/string.o $(obj)/cmdline.o $(obj)/early_serial_console.o $(obj)/piggy.o FORCE
+ 	$(call if_changed,ld)
+ 	@:
++endif
+ 
+ OBJCOPYFLAGS_vmlinux.bin :=  -R .comment -S
+ $(obj)/vmlinux.bin: vmlinux FORCE
+diff -urN linux-3.1.4/arch/x86/boot/header.S linux-3.1.4-scc/arch/x86/boot/header.S
+--- linux-3.1.4/arch/x86/boot/header.S	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/boot/header.S	2011-12-20 15:27:07.565882437 +0100
+@@ -217,8 +217,14 @@
+ 
+ hardware_subarch_data:	.quad 0
+ 
++#ifdef CONFIG_KERNEL_NONE
++# We do not have a compressed payload when using an uncompressed kernel.
++payload_offset:		.long 0
++payload_length:		.long 0
++#else
+ payload_offset:		.long ZO_input_data
+ payload_length:		.long ZO_z_input_len
++#endif
+ 
+ setup_data:		.quad 0			# 64-bit physical pointer to
+ 						# single linked list of
+diff -urN linux-3.1.4/arch/x86/boot/pm.c linux-3.1.4-scc/arch/x86/boot/pm.c
+--- linux-3.1.4/arch/x86/boot/pm.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/boot/pm.c	2011-12-20 15:27:07.565882437 +0100
+@@ -103,6 +103,9 @@
+  */
+ void go_to_protected_mode(void)
+ {
++#ifdef CONFIG_X86_SCC
++	asm("cli");
++#else
+ 	/* Hook before leaving real mode, also disables interrupts */
+ 	realmode_switch_hook();
+ 
+@@ -117,6 +120,7 @@
+ 
+ 	/* Mask all interrupts in the PIC */
+ 	mask_all_interrupts();
++#endif
+ 
+ 	/* Actual transition to protected mode... */
+ 	setup_idt();
+diff -urN linux-3.1.4/arch/x86/boot/tty.c linux-3.1.4-scc/arch/x86/boot/tty.c
+--- linux-3.1.4/arch/x86/boot/tty.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/boot/tty.c	2011-12-20 15:27:07.565882437 +0100
+@@ -54,10 +54,16 @@
+ 	if (ch == '\n')
+ 		putchar('\r');	/* \n -> \r\n */
+ 
++#ifdef CONFIG_X86_SCC
++#ifdef CONFIG_SCC_BOOT_DEBUG
++	outb(ch & 0xFF, 0x80);
++#endif
++#else
+ 	bios_putchar(ch);
+ 
+ 	if (early_serial_base != 0)
+ 		serial_putchar(ch);
++#endif
+ }
+ 
+ void __attribute__((section(".inittext"))) puts(const char *str)
+diff -urN linux-3.1.4/arch/x86/include/asm/bootparam.h linux-3.1.4-scc/arch/x86/include/asm/bootparam.h
+--- linux-3.1.4/arch/x86/include/asm/bootparam.h	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/include/asm/bootparam.h	2011-12-20 15:27:07.565882437 +0100
+@@ -126,6 +126,7 @@
+ 	X86_SUBARCH_XEN,
+ 	X86_SUBARCH_MRST,
+ 	X86_SUBARCH_CE4100,
++	X86_SUBARCH_SCC,
+ 	X86_NR_SUBARCHS,
+ };
+ 
+diff -urN linux-3.1.4/arch/x86/include/asm/cacheflush.h linux-3.1.4-scc/arch/x86/include/asm/cacheflush.h
+--- linux-3.1.4/arch/x86/include/asm/cacheflush.h	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/include/asm/cacheflush.h	2011-12-20 15:27:07.565882437 +0100
+@@ -97,6 +97,10 @@
+ int set_memory_uc(unsigned long addr, int numpages);
+ int set_memory_wc(unsigned long addr, int numpages);
+ int set_memory_wb(unsigned long addr, int numpages);
++#ifdef CONFIG_X86_SCC
++int set_memory_mpbt(unsigned long addr, int numpages);
++int set_memory_wt_mpbt(unsigned long addr, int numpages);
++#endif
+ int set_memory_x(unsigned long addr, int numpages);
+ int set_memory_nx(unsigned long addr, int numpages);
+ int set_memory_ro(unsigned long addr, int numpages);
+@@ -133,6 +137,10 @@
+  */
+ 
+ int set_pages_uc(struct page *page, int numpages);
++#ifdef CONFIG_X86_SCC
++int set_pages_mpbt(struct page *page, int numpages);
++int set_pages_wt_mpbt(struct page *page, int numpages);
++#endif
+ int set_pages_wb(struct page *page, int numpages);
+ int set_pages_x(struct page *page, int numpages);
+ int set_pages_nx(struct page *page, int numpages);
+diff -urN linux-3.1.4/arch/x86/include/asm/io.h linux-3.1.4-scc/arch/x86/include/asm/io.h
+--- linux-3.1.4/arch/x86/include/asm/io.h	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/include/asm/io.h	2011-12-20 15:27:07.565882437 +0100
+@@ -175,6 +175,7 @@
+ extern void __iomem *ioremap_cache(resource_size_t offset, unsigned long size);
+ extern void __iomem *ioremap_prot(resource_size_t offset, unsigned long size,
+ 				unsigned long prot_val);
++extern void __iomem *ioremap_mpbt(resource_size_t offset, unsigned long size);
+ 
+ /*
+  * The default ioremap() behavior is non-cached:
+@@ -325,6 +326,8 @@
+ extern void early_ioremap_reset(void);
+ extern void __iomem *early_ioremap(resource_size_t phys_addr,
+ 				   unsigned long size);
++extern void __iomem *early_ioremap_nocache(resource_size_t phys_addr,
++					   unsigned long size);
+ extern void __iomem *early_memremap(resource_size_t phys_addr,
+ 				    unsigned long size);
+ extern void early_iounmap(void __iomem *addr, unsigned long size);
+diff -urN linux-3.1.4/arch/x86/include/asm/lapic.h linux-3.1.4-scc/arch/x86/include/asm/lapic.h
+--- linux-3.1.4/arch/x86/include/asm/lapic.h	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/include/asm/lapic.h	2011-12-20 15:27:07.565882437 +0100
+@@ -0,0 +1,21 @@
++#ifndef __ASM_LAPIC_H
++#define __ASM_LAPIC_H
++
++#include <asm/apic.h>
++
++static __inline void set_lapic_mask(unsigned long reg, unsigned int irq)
++{
++  unsigned long v;
++  v = apic_read(reg);
++  apic_write(reg, v | APIC_LVT_MASKED);
++}
++
++// unset_lapic_mask enables interrupt
++static __inline void unset_lapic_mask(unsigned long reg, unsigned int irq)
++{
++  unsigned long v;
++  v = apic_read(reg);
++  apic_write(reg, v & ~APIC_LVT_MASKED);
++}
++
++#endif /* __ASM_LAPIC_H */
+diff -urN linux-3.1.4/arch/x86/include/asm/pgtable_types.h linux-3.1.4-scc/arch/x86/include/asm/pgtable_types.h
+--- linux-3.1.4/arch/x86/include/asm/pgtable_types.h	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/include/asm/pgtable_types.h	2011-12-20 15:27:07.565882437 +0100
+@@ -15,6 +15,9 @@
+ #define _PAGE_BIT_DIRTY		6	/* was written to (raised by CPU) */
+ #define _PAGE_BIT_PSE		7	/* 4 MB (or 2MB) page */
+ #define _PAGE_BIT_PAT		7	/* on 4KB pages */
++#ifdef CONFIG_X86_SCC
++#define _PAGE_BIT_PMB		7	/* on 4KB pages if CR4 has (!PSE && MBE) */
++#endif
+ #define _PAGE_BIT_GLOBAL	8	/* Global TLB entry PPro+ */
+ #define _PAGE_BIT_UNUSED1	9	/* available for programmer */
+ #define _PAGE_BIT_IOMAP		10	/* flag used to indicate IO mapping */
+@@ -39,6 +42,9 @@
+ #define _PAGE_ACCESSED	(_AT(pteval_t, 1) << _PAGE_BIT_ACCESSED)
+ #define _PAGE_DIRTY	(_AT(pteval_t, 1) << _PAGE_BIT_DIRTY)
+ #define _PAGE_PSE	(_AT(pteval_t, 1) << _PAGE_BIT_PSE)
++#ifdef CONFIG_X86_SCC
++#define _PAGE_PMB	(_AT(pteval_t, 1) << _PAGE_BIT_PMB)
++#endif
+ #define _PAGE_GLOBAL	(_AT(pteval_t, 1) << _PAGE_BIT_GLOBAL)
+ #define _PAGE_UNUSED1	(_AT(pteval_t, 1) << _PAGE_BIT_UNUSED1)
+ #define _PAGE_IOMAP	(_AT(pteval_t, 1) << _PAGE_BIT_IOMAP)
+diff -urN linux-3.1.4/arch/x86/include/asm/processor-flags.h linux-3.1.4-scc/arch/x86/include/asm/processor-flags.h
+--- linux-3.1.4/arch/x86/include/asm/processor-flags.h	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/include/asm/processor-flags.h	2011-12-20 15:27:07.565882437 +0100
+@@ -58,6 +58,9 @@
+ #define X86_CR4_PCE	0x00000100 /* enable performance counters at ipl 3 */
+ #define X86_CR4_OSFXSR	0x00000200 /* enable fast FPU save and restore */
+ #define X86_CR4_OSXMMEXCPT 0x00000400 /* enable unmasked SSE exceptions */
++#ifdef CONFIG_X86_SCC
++#define X86_CR4_MPE	0x00000800 /* SCC: enable MPBT caching */
++#endif
+ #define X86_CR4_VMXE	0x00002000 /* enable VMX virtualization */
+ #define X86_CR4_RDWRGSFS 0x00010000 /* enable RDWRGSFS support */
+ #define X86_CR4_OSXSAVE 0x00040000 /* enable xsave and xrestore */
+diff -urN linux-3.1.4/arch/x86/include/asm/serial.h linux-3.1.4-scc/arch/x86/include/asm/serial.h
+--- linux-3.1.4/arch/x86/include/asm/serial.h	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/include/asm/serial.h	2011-12-20 15:27:07.565882437 +0100
+@@ -19,11 +19,21 @@
+ #define STD_COM4_FLAGS ASYNC_BOOT_AUTOCONF
+ #endif
+ 
++#ifdef CONFIG_X86_SCC
++#define SERIAL_PORT_DFNS			\
++	/* UART CLK   PORT IRQ     FLAGS        */			\
++	{ 0, BASE_BAUD, 0x3F8, 0, STD_COM_FLAGS },	/* ttyS0 */	\
++	{ 0, BASE_BAUD, 0x2F8, 0, STD_COM_FLAGS },	/* ttyS1 */	\
++	{ 0, BASE_BAUD, 0x3E8, 0, STD_COM_FLAGS },	/* ttyS2 */	\
++	{ 0, BASE_BAUD, 0x2E8, 0, STD_COM4_FLAGS },	/* ttyS3 */
++#else
++
+ #define SERIAL_PORT_DFNS			\
+ 	/* UART CLK   PORT IRQ     FLAGS        */			\
+ 	{ 0, BASE_BAUD, 0x3F8, 4, STD_COM_FLAGS },	/* ttyS0 */	\
+ 	{ 0, BASE_BAUD, 0x2F8, 3, STD_COM_FLAGS },	/* ttyS1 */	\
+ 	{ 0, BASE_BAUD, 0x3E8, 4, STD_COM_FLAGS },	/* ttyS2 */	\
+ 	{ 0, BASE_BAUD, 0x2E8, 3, STD_COM4_FLAGS },	/* ttyS3 */
++#endif
+ 
+ #endif /* _ASM_X86_SERIAL_H */
+diff -urN linux-3.1.4/arch/x86/include/asm/setup.h linux-3.1.4-scc/arch/x86/include/asm/setup.h
+--- linux-3.1.4/arch/x86/include/asm/setup.h	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/include/asm/setup.h	2011-12-20 15:27:07.565882437 +0100
+@@ -53,6 +53,12 @@
+ static inline void x86_mrst_early_setup(void) { }
+ #endif
+ 
++#ifdef CONFIG_X86_SCC
++extern void x86_scc_early_setup(void);
++#else
++static inline void x86_scc_early_setup(void) { }
++#endif
++
+ #ifdef CONFIG_X86_INTEL_CE
+ extern void x86_ce4100_early_setup(void);
+ #else
+diff -urN linux-3.1.4/arch/x86/Kconfig linux-3.1.4-scc/arch/x86/Kconfig
+--- linux-3.1.4/arch/x86/Kconfig	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/Kconfig	2011-12-20 15:27:07.565882437 +0100
+@@ -53,6 +53,7 @@
+ 	select HAVE_KERNEL_LZMA
+ 	select HAVE_KERNEL_XZ
+ 	select HAVE_KERNEL_LZO
++	select HAVE_KERNEL_NONE
+ 	select HAVE_HW_BREAKPOINT
+ 	select HAVE_MIXED_BREAKPOINTS_REGS
+ 	select PERF_EVENTS
+@@ -422,6 +423,106 @@
+ 
+ endif
+ 
++config X86_SCC
++	bool "Single-Chip Cloud Computer (SCC)"
++	 depends on X86_32
++	 depends on X86_EXTENDED_PLATFORM
++	---help---
++	  This enables certain tweaks for running the kernel on SCC cores.
++
++config SCC_BUSCLOCK
++	int "Frequency of SCC FSB clock in Hz"
++	default 533000000
++	depends on X86_SCC
++	range 1000000 2000000000
++	---help---
++	  SCC core clock frequency used to calculate configuration for LAPIC
++	  timer setup.
++
++config SCC_QUERY_FREQUENCY_FROM_FPGA
++	bool "Get real SCC FSB clock from FPGA"
++	default y
++	depends on X86_SCC
++	---help---
++	  Read the real SCC FSB clock frequency from the FPGA's global
++	  configuration register bank (GRB) during boot. If this option is
++	  enabled and a valid frequency is read, it overwrites the statically-
++	  configured value. If this option is disabled or the value read from
++	  the FPGA is obviously wrong (e.g., a FASTCLOCK of zero), the
++	  configured value is used instead.
++
++config X86_SCC_LAPIC_TRACK_CPU_FREQ
++	bool "LAPIC timer: Track CPU frequency changes"
++	default y
++	depends on X86_SCC
++	depends on X86_LOCAL_APIC
++	depends on CPU_FREQ
++	---help---
++	  Make the LAPIC timer track changes to the CPU core frequency via the
++	  sccfreq driver.
++
++	  If this option is enabled, the clock divisor used by the LAPIC timer
++	  is adjusted automatically whenever the core frequency is changed, thus
++	  allowing the frequency of the LAPIC timer interrupts to stay the same.
++	  This setting allows the "jiffies" clock source to report correct
++	  (real) time.
++
++	  If this option is disabled, the clock divisor is set once during boot,
++	  based on the detected or statically-configured bus frequency.
++	  This setting results in the "jiffies" clock source reporting time
++	  relative to the ratio of the current and boot frequency.
++
++config X86_SCC_TSC_TRACK_CPU_FREQ
++	bool "TSC: Track CPU frequency changes"
++	default y
++	depends on X86_SCC
++	depends on CPU_FREQ
++	---help---
++	  Make the TSC clock source track changes to the CPU core frequency via
++	  the sccfreq driver.
++
++	  If this option is enabled, the frequency of the TSC clock source is
++	  adjusted automatically whenever the core frequency is changed.
++	  This setting allows the "tsc" clock source to report correct (real)
++	  time.
++
++	  If this option is disabled, the frequency of the TSC clock source is
++	  set once during boot, based on the detected or statically-configured
++	  bus frequency. This results in the "tsc" clock source reporting time
++	  relative to the ratio of the current and boot frequency.
++
++config SCCSYS
++	bool "SCC System Driver"
++	depends on X86_SCC
++	default y
++	---help---
++	  SCC system driver. This driver provides access to the
++	  architecture-specific configuration register banks (CRB) of the tile,
++	  and the global configuration register bank (GRB) of the FPGA, and is
++	  also responsible for initializing message-passing buffers and the
++	  MPBT (message-passing buffer type) caching type.
++	  This driver is a prerequisite for using other SCC-specific drivers
++	  like SCCMEM (the SCC memory driver providing devices like /dev/rckncm)
++	  or SCCMB, SCCPC or SCCEMAC (the network drivers for on-die and off-die
++	  communication).
++
++config SCCSYS_FPGA_CLOCK
++	bool "Use global timestamp counter as clock source"
++	default y
++	depends on SCCSYS
++	---help---
++	  Register a clocksource backed by the global timestamp counter in the
++	  FPGA. The counter runs at a frequency of 125MHz and is independent of
++	  changes to the core and mesh frequencies, thus providing a reliable
++	  walltime to the core.
++
++config SCCSYS_RECURSIVE_PID_LOCK
++	bool "Recursive PID locks"
++	default y
++	depends on SCCSYS
++	---help---
++	  Allow acquiring the core-specific test&set registers recursively.
++
+ config X86_RDC321X
+ 	bool "RDC R-321x SoC"
+ 	depends on X86_32
+diff -urN linux-3.1.4/arch/x86/kernel/apic/apic.c linux-3.1.4-scc/arch/x86/kernel/apic/apic.c
+--- linux-3.1.4/arch/x86/kernel/apic/apic.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/kernel/apic/apic.c	2011-12-20 15:27:07.565882437 +0100
+@@ -54,6 +54,12 @@
+ #include <asm/tsc.h>
+ #include <asm/hypervisor.h>
+ 
++#ifdef CONFIG_X86_SCC
++#include <linux/sccsys.h>	/* scc_get_boot_busclock() */
++#include <linux/cpufreq.h>
++#include <linux/percpu.h>
++#endif
++
+ unsigned int num_processors;
+ 
+ unsigned disabled_cpus __cpuinitdata;
+@@ -436,6 +442,16 @@
+ 	return 0;
+ }
+ 
++#ifdef CONFIG_X86_SCC_LAPIC_TRACK_CPU_FREQ
++static DEFINE_PER_CPU(enum clock_event_mode, last_APIC_timer_mode);
++static inline void __save_APIC_timer_setup(enum clock_event_mode mode)
++{
++	percpu_write(last_APIC_timer_mode, mode);
++}
++#else // CONFIG_X86_SCC_LAPIC_TRACK_CPU_FREQ
++static inline void __save_APIC_timer_setup(enum clock_event_mode) {}
++#endif // !CONFIG_X86_SCC_LAPIC_TRACK_CPU_FREQ
++
+ /*
+  * Setup the lapic timer in periodic or oneshot mode
+  */
+@@ -451,6 +467,8 @@
+ 
+ 	local_irq_save(flags);
+ 
++	__save_APIC_timer_setup(mode);
++
+ 	switch (mode) {
+ 	case CLOCK_EVT_MODE_PERIODIC:
+ 	case CLOCK_EVT_MODE_ONESHOT:
+@@ -516,6 +534,7 @@
+ 	memcpy(levt, &lapic_clockevent, sizeof(*levt));
+ 	levt->cpumask = cpumask_of(smp_processor_id());
+ 
++	__save_APIC_timer_setup(CLOCK_EVT_MODE_UNUSED);
+ 	clockevents_register_device(levt);
+ }
+ 
+@@ -632,6 +651,7 @@
+ 
+ static int __init calibrate_APIC_clock(void)
+ {
++#ifndef CONFIG_X86_SCC
+ 	struct clock_event_device *levt = &__get_cpu_var(lapic_events);
+ 	void (*real_handler)(struct clock_event_device *dev);
+ 	unsigned long deltaj;
+@@ -748,10 +768,111 @@
+ 		pr_warning("APIC timer disabled due to verification failure\n");
+ 			return -1;
+ 	}
++#else // CONFIG_X86_SCC
++	long delta;
+ 
++	/*
++	 * No calibration possible since it is based on another clock we don't
++	 * have. On the SCC, the LAPIC timer *is* the primary clock source, so
++	 * we need to fake a calibration result by referring to the configured
++	 * bus clock.
++         */
++
++	calibration_result = scc_get_boot_busclock() / HZ;
++	printk("SCC: Setting APIC timer based on configured Bus clock of %u.%04u MHz.\n",
++		calibration_result/(1000000/HZ), calibration_result%(1000000/HZ));
++
++	/* Calculate the scaled math multiplication factor. In the regular path,
++	 * this is done by first getting the delta value based on the hardware
++	 * reference clock, then calculating calibration_result. As we specify
++	 * calibration_result directly, we go the other way around and calculate
++	 * delta now, as it is used to set the lapic_clockevent parameters. */
++	delta = calibration_result * LAPIC_CAL_LOOPS / APIC_DIVISOR;
++
++	/* We have a delta value, so this code can simply be copied from the
++	 * above calibration routine. */
++	lapic_clockevent.mult = div_sc(delta, TICK_NSEC * LAPIC_CAL_LOOPS,
++				       lapic_clockevent.shift);
++	lapic_clockevent.max_delta_ns =
++		clockevent_delta2ns(0x7FFFFFFF, &lapic_clockevent);
++	lapic_clockevent.min_delta_ns =
++		clockevent_delta2ns(0xF, &lapic_clockevent);
++#endif // CONFIG_X86_SCC
+ 	return 0;
+ }
+ 
++#if defined(CONFIG_CPU_FREQ) && defined(CONFIG_X86_SCC_LAPIC_TRACK_CPU_FREQ)
++/* Update the specified APIC timer device to use a new frequency base.
++ * The routine must be invoked on the CPU the specified APIC timer device
++ * belongs to. */
++static inline void __updatefreq_APIC_timer(struct clock_event_device* evt)
++{
++	if (evt->features & CLOCK_EVT_FEAT_DUMMY) {
++		return;
++	}
++
++	/* Configure the APIC timer with the new calibration value. We simply
++	 * re-apply the last timer mode, which also sets the new clock divider.
++	 * The initial counter value in APIC_TMICT does not need to be updated,
++	 * as the counter frequency itself does not change. */
++	evt->set_mode(percpu_read(last_APIC_timer_mode), evt);
++}
++
++static unsigned int  ref_freq;
++static unsigned long calibration_ref;
++
++static int lapic_cpufreq_notifier(struct notifier_block *nb, unsigned long val,
++				void *data)
++{
++	struct cpufreq_freqs *freq = data;
++	unsigned int new_calibration;
++
++	if (cpu_has(&cpu_data(freq->cpu), X86_FEATURE_CONSTANT_TSC))
++		return 0;
++
++	if (lapic_clockevent.features & CLOCK_EVT_FEAT_DUMMY)
++		return 0;
++
++	if (!ref_freq) {
++		ref_freq = freq->old;
++		calibration_ref = calibration_result;
++	}
++	if ((val == CPUFREQ_PRECHANGE  && freq->old < freq->new) ||
++			(val == CPUFREQ_POSTCHANGE && freq->old > freq->new) ||
++			(val == CPUFREQ_RESUMECHANGE)) {
++		new_calibration = cpufreq_scale(calibration_ref, ref_freq, freq->new);
++	} else {
++		new_calibration = calibration_result;
++	}
++
++	if (new_calibration != calibration_result) {
++		struct clock_event_device *levt = &__get_cpu_var(lapic_events);
++
++		calibration_result = new_calibration;
++		__updatefreq_APIC_timer(levt);
++	}
++
++	return 0;
++}
++
++static struct notifier_block lapic_cpufreq_notifier_block = {
++	.notifier_call  = lapic_cpufreq_notifier
++};
++
++static int __init cpufreq_lapic(void)
++{
++	if (!cpu_has_tsc)
++		return 0;
++	if (boot_cpu_has(X86_FEATURE_CONSTANT_TSC))
++		return 0;
++	cpufreq_register_notifier(&lapic_cpufreq_notifier_block,
++				CPUFREQ_TRANSITION_NOTIFIER);
++	return 0;
++}
++
++core_initcall(cpufreq_lapic);
++#endif // CONFIG_CPU_FREQ && CONFIG_X86_SCC_LAPIC_TRACK_CPU_FREQ
++
+ /*
+  * Setup the boot APIC
+  *
+@@ -1559,9 +1680,17 @@
+ 	mp_lapic_addr = APIC_DEFAULT_PHYS_BASE;
+ 
+ 	/* The BIOS may have set up the APIC at some other address */
+-	rdmsr(MSR_IA32_APICBASE, l, h);
+-	if (l & MSR_IA32_APICBASE_ENABLE)
+-		mp_lapic_addr = l & MSR_IA32_APICBASE_BASE;
++	if (boot_cpu_data.x86 != 5) {
++		/*
++		 * Only P6 and later cores implement the MSR_IA32_APICBASE. For
++		 * all previous ones, we need to rely on the APIC residing at
++		 * its default address.
++		 */
++
++		rdmsr(MSR_IA32_APICBASE, l, h);
++		if (l & MSR_IA32_APICBASE_ENABLE)
++			mp_lapic_addr = l & MSR_IA32_APICBASE_BASE;
++	}
+ 
+ 	pr_info("Found and enabled local APIC!\n");
+ 	return 0;
+diff -urN linux-3.1.4/arch/x86/kernel/cpu/common.c linux-3.1.4-scc/arch/x86/kernel/cpu/common.c
+--- linux-3.1.4/arch/x86/kernel/cpu/common.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/kernel/cpu/common.c	2011-12-20 15:27:07.578352779 +0100
+@@ -439,8 +439,10 @@
+ 		l2size = this_cpu->c_size_cache(c, l2size);
+ 
+ 	/* Allow user to override all this if necessary. */
+-	if (cachesize_override != -1)
+-		l2size = cachesize_override;
++	//if (cachesize_override != -1)
++	//	l2size = cachesize_override;
++	printk(KERN_INFO "Setting l2size\n");
++	l2size = 0x3FC00;
+ 
+ 	if (l2size == 0)
+ 		return;		/* Again, no L2 cache is possible */
+diff -urN linux-3.1.4/arch/x86/kernel/cpu/intel_cacheinfo.c linux-3.1.4-scc/arch/x86/kernel/cpu/intel_cacheinfo.c
+--- linux-3.1.4/arch/x86/kernel/cpu/intel_cacheinfo.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/kernel/cpu/intel_cacheinfo.c	2011-12-20 15:27:07.578352779 +0100
+@@ -736,6 +736,13 @@
+ #endif
+ 	}
+ 
++#ifdef CONFIG_X86_SCC
++	l3 = 0;
++	l2 = 256;
++	l1i = 16;
++	l1d = 0;
++#endif
++
+ 	c->x86_cache_size = l3 ? l3 : (l2 ? l2 : (l1i+l1d));
+ 
+ 	return l2;
+diff -urN linux-3.1.4/arch/x86/kernel/cpu/Makefile linux-3.1.4-scc/arch/x86/kernel/cpu/Makefile
+--- linux-3.1.4/arch/x86/kernel/cpu/Makefile	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/kernel/cpu/Makefile	2011-12-20 15:27:07.578352779 +0100
+@@ -30,6 +30,7 @@
+ 
+ obj-$(CONFIG_X86_MCE)			+= mcheck/
+ obj-$(CONFIG_MTRR)			+= mtrr/
++obj-$(CONFIG_SCCSYS)			+= sccsys.o
+ 
+ obj-$(CONFIG_X86_LOCAL_APIC)		+= perfctr-watchdog.o
+ 
+diff -urN linux-3.1.4/arch/x86/kernel/cpu/sccsys.c linux-3.1.4-scc/arch/x86/kernel/cpu/sccsys.c
+--- linux-3.1.4/arch/x86/kernel/cpu/sccsys.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/kernel/cpu/sccsys.c	2011-12-20 15:27:07.578352779 +0100
+@@ -0,0 +1,657 @@
++/*
++ *  linux/arch/x86/kernel/cpu/sccsys.c
++ *
++ *  SCC system driver, partially based on the original sccmem.c driver
++ *  distributed as part of SCC Linux.
++ */
++
++#include <linux/module.h>
++#ifdef MODVERSIONS
++#  include <linux/modversions.h>
++#endif
++#include <linux/spinlock.h>
++#include <linux/clocksource.h>
++#include <asm/io.h>
++
++#include <linux/sccsys.h>
++
++/* DEBUG messages */
++#define DEBUG_MSG 0
++#define PRINTD(format, args...) if (DEBUG_MSG) { printk(format, ##args); }
++
++/* Symbols */
++#define FIRST_MPB   0xc0000000
++#define MPBADDRBITS 13
++#define MPBSIZE     (1<<MPBADDRBITS)
++
++
++/* Module parameters */
++static int crb_offset = 0xE0000000;
++module_param(crb_offset, int, 0644);
++MODULE_PARM_DESC(crb_offset, "Physical start address of the register bank memory range");
++
++static int grb_offset = 0xF9000000;
++module_param(grb_offset, int, 0644);
++MODULE_PARM_DESC(grb_offset, "Start address of the global register bank");
++
++static int local_crb_offset = 0xF8000000;
++module_param(local_crb_offset, int, 0644);
++MODULE_PARM_DESC(local_crb_offset, "Start address of the local register bank");
++
++static int disable_locking = 0;
++module_param(disable_locking, int, 0644);
++MODULE_PARM_DESC(disable_locking, "Enable/disable use of the test&set bits");
++
++/* SCC System Context */
++struct sccsys {
++	void*			grb;
++	void*			own_crb;
++	int			own_tileid;
++	scc_coord_t		own_coord;
++	int			own_pid;
++	void*			crb[SCC_TILECOUNT];
++#ifdef CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++	spinlock_t		lock[SCC_CORECOUNT];
++	unsigned int		lock_count[SCC_CORECOUNT];
++#endif // CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++};
++
++static struct sccsys		sccsys_buffer;
++static struct sccsys*		sccsys = &sccsys_buffer;
++
++
++#ifdef CONFIG_SCCSYS_FPGA_CLOCK
++/* clocksource */
++static struct clocksource clocksource_scc;
++
++static cycle_t sccsys_read_clock(struct clocksource *cs)
++{
++	unsigned long lo, hi;
++
++	/* Read global timestamp counter from GRB address space. We read the two
++	 * halves separately, then check whether the high word has changed in
++	 * between: if it has, the low word has overflowed, so we retry the
++	 * operation. Otherwise, we are guaranteed to get a consistent pair of
++	 * low and high word, and can construct a cycle_t from it. */
++	do {
++		hi = sccsys_read_grb_entry(0x8228);
++		lo = sccsys_read_grb_entry(0x8224);
++	} while (hi != sccsys_read_grb_entry(0x8228));
++
++	return (cycle_t)(((unsigned long long)hi << 32) | lo);
++}
++
++static void sccsys_resume_clock(struct clocksource *cs)
++{
++	clocksource_scc.cycle_last = 0;
++}
++
++static struct clocksource clocksource_scc = {
++	.name                   = "scc",
++	.rating                 = 500,
++	.read                   = sccsys_read_clock,
++	.resume			= sccsys_resume_clock,
++	.mask                   = CLOCKSOURCE_MASK(64),
++	.flags                  = CLOCK_SOURCE_IS_CONTINUOUS,
++};
++#endif
++
++/* cleanup */
++static void sccsys_cleanup(void) {
++	int i;
++
++	for (i = 0; i < SCC_TILECOUNT; i++) {
++		if (sccsys->crb[i]) {
++			iounmap(sccsys->crb[i]);
++			sccsys->crb[i] = NULL;
++		}
++	}
++	if (sccsys->own_crb) {
++		iounmap(sccsys->own_crb);
++		sccsys->own_crb = NULL;
++	}
++	if (sccsys->grb) {
++		iounmap(sccsys->grb);
++		sccsys->grb = NULL;
++	}
++}
++
++/* module initialization - called at module load time */
++static int __init sccsys_init(void) {
++	int i;
++	void* own_mpb;
++	int loopMPB;
++
++	PRINTD(KERN_INFO "Starting up SCC system driver...\n");
++
++	/* Zero out the sccsys structure */
++	memset(sccsys, 0, sizeof(struct sccsys));
++
++#ifdef CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++	for (i = 0; i < SCC_CORECOUNT; i++) {
++		spin_lock_init(&sccsys->lock[i]);
++	}
++#endif // CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++
++
++	/* Begin with some sanity checks.
++	 * *) We need to be running on a GaussLake CPU, which looks like a
++	 *    regular P54C by its CPUID.
++	 * *) The kernel must not have enabled PSE, as our MB bit shares its
++	 *    location in the page tables with the PS bit. Enabling both
++	 *    architectural extensions at the same time is not possible, neither
++	 *    is to tell the kernel that PSE is not usable afterwards.
++	 * *) We are running in a bare-metal environment, not paravirtualized
++	 */
++	if (!(boot_cpu_data.x86 == 5 && boot_cpu_data.x86_model == 2)) {
++		printk(KERN_ERR "sccsys: Unknown CPU (%d:%d). This driver can only be used on GaussLake cores.\n",
++			boot_cpu_data.x86,
++			boot_cpu_data.x86_model);
++		return -EINVAL;
++	}
++	if (read_cr4() & X86_CR4_PSE) {
++		printk(KERN_ERR "sccsys: Unable to activate GaussLake extensions because the kernel has set CR4.PSE.\n");
++		return -EINVAL;
++	}
++	if (!scc_bare_metal()) {
++		printk(KERN_INFO "sccsys: Running on paravirtualized kernel.\n");
++		return -EINVAL;
++	}
++
++	/* Map our own configuration registers and read the tileid */
++	sccsys->own_crb = ioremap_nocache(local_crb_offset, SCC_CRB_SIZE);
++	if (!sccsys->own_crb) {
++		printk(KERN_ERR "sccsys: unable to map own CRB @%08x\n", local_crb_offset);
++		return -ENOMEM;
++	}
++
++	sccsys->own_tileid = readl(sccsys->own_crb + SCC_TILEID);
++	sccsys->own_coord  = scc_tileid_to_coord(sccsys->own_tileid);
++	sccsys->own_pid    = scc_tileid_to_pid(sccsys->own_tileid);
++	PRINTD(KERN_INFO "sccsys_init: starting on pid %02d (x=%d, y=%d, z=%d)\n",
++		sccsys->own_pid,
++		sccsys->own_coord.x, sccsys->own_coord.y, sccsys->own_coord.z);
++
++	/* Map configuration registers of other tiles */
++	for (i = 0; i < SCC_TILECOUNT; i++) {
++		int crb_address = crb_offset + SCC_TILE_SIZE*i;
++		sccsys->crb[i] = ioremap_nocache(crb_address, SCC_CRB_SIZE);
++		if (!sccsys->crb[i]) {
++			printk(KERN_ERR "sccsys: unable to map CRB of tile %d @%08x\n", i, crb_address);
++			sccsys_cleanup();
++			return -ENOMEM;
++		}
++	}
++
++	/* Map global configuration registers */
++	sccsys->grb = ioremap_nocache(grb_offset, SCC_GRB_SIZE);
++	if (!sccsys->grb) {
++		printk(KERN_ERR "sccsys: unable to map GRB @%08x\n", grb_offset);
++		sccsys_cleanup();
++		return -ENOMEM;
++	}
++
++	/* Initialize own message passing buffer */
++	own_mpb = ioremap_nocache(FIRST_MPB+(sccsys->own_coord.x*0x01000000)+(sccsys->own_coord.y*0x06000000), 2*MPBSIZE);
++	if (!own_mpb) {
++		printk(KERN_ERR "sccsys: unable to map own MPB. GaussLake extensions will NOT be enabled on this core.\n");
++		sccsys_cleanup();
++		return -ENOMEM;
++	}
++
++	for (loopMPB = sccsys->own_coord.z*MPBSIZE; loopMPB < ((sccsys->own_coord.z+1)*MPBSIZE); loopMPB += 4) {
++		writel(0, own_mpb + loopMPB);
++	}
++	iounmap(own_mpb);
++
++	/* Enable GaussLake extensions. */
++	PRINTD(KERN_INFO "sccsys_init: about to set CR4.MPE (%08x)\n", X86_CR4_MPE);
++	set_in_cr4(X86_CR4_MPE);
++	//__supported_pte_mask |= _PAGE_PMB;
++	printk(KERN_INFO "sccsys_init: GaussLake extensions enabled.\n");
++
++#ifdef CONFIG_SCCSYS_FPGA_CLOCK
++	/* Register SCC clocksource */
++	clocksource_register_khz(&clocksource_scc, 125000);
++#endif
++
++	return 0;
++}
++
++/* module unload */
++static void __exit sccsys_exit(void)
++{
++	PRINTD(KERN_INFO "sccsys_exit: Shutting down SCC system driver...\n");
++	sccsys_cleanup();
++}
++
++
++/*
++ * Functions exported to other modules
++ */
++
++/* Get address of configuration register for a tile identified by a pid.
++ * This routine is intended for tile-global registers that do not depend on
++ * the target processor number. If a per-cpu configuration register is needed,
++ * you can use sccsys_get_crb_entry_for_pid instead.
++ */
++static void* sccsys_get_crb_entry_for_tile_of_pid(scc_pid_t pid, int offset)
++{
++	void* address;
++
++	if (pid < 0 || pid >= SCC_CORECOUNT) {
++		printk(KERN_ERR "sccsys: get_crb_entry: invalid pid %02d\n", pid);
++		BUG_ON(1);
++		return NULL;
++	}
++
++	address = sccsys->crb[pid / 2];
++	if (!address) {
++		printk(KERN_ERR "sccsys: get_crb_entry: crb of pid %02d not mapped\n", pid);
++		BUG_ON(1);
++		return NULL;
++	}
++
++	return address + offset;
++}
++
++/* Get address of configuration register for the specified processor.
++ * This routine is intended for per-cpu registers, so it takes two offsets.
++ * cpu0_offset is used for the first processor of the tile (z=0),
++ * cpu1_offset is used for the second one.
++ */
++static void* sccsys_get_crb_entry_for_pid(scc_pid_t pid, int cpu0_offset, int cpu1_offset)
++{
++	void* address;
++
++	address = sccsys_get_crb_entry_for_tile_of_pid(pid, 0);
++	if (!address) {
++		return NULL;
++	}
++
++	if ((pid % 2) == 0) {
++		return address + cpu0_offset;
++	} else {
++		return address + cpu1_offset;
++	}
++}
++
++
++/* Get value of own tileid. The format is 0...0_00000yyy_yxxxxzzz (in bits).
++ * Tile IDs are not consecutive; if a consecutive number is needed, consider
++ * using the PID instead.
++ */
++int sccsys_get_tileid(void)
++{
++	return sccsys->own_tileid;
++}
++EXPORT_SYMBOL(sccsys_get_tileid);
++
++/* Get own processor id. This is a consecutive number from 0 to SCC_CORECOUNT-1.
++ */
++scc_pid_t sccsys_get_pid(void)
++{
++	return sccsys->own_pid;
++}
++EXPORT_SYMBOL(sccsys_get_pid);
++
++/* Get own coordinates. This is the decoded version of the TILEID returned by
++ * sccsys_get_tileid. */
++scc_coord_t sccsys_get_coord(void)
++{
++	return sccsys->own_coord;
++}
++EXPORT_SYMBOL(sccsys_get_coord);
++
++/* Get logically next processor id. This is a consecutive number from 0 to
++ * SCC_CORECOUNT-1, but is not neccessarily ((pid+1) % SCC_CORECOUNT). The
++ * number is usually chosen to reflect the adjacent core having the shortest
++ * distance, although it guarantees that the cycle closes after exactly
++ * SCC_CORECOUNT invocations.
++ */
++scc_pid_t sccsys_get_next_pid(scc_pid_t pid)
++{
++#if SCC_CORECOUNT == 48
++	if (pid >= 0 && pid < 11) {
++		return pid + 1;
++	} else if (pid == 11) {
++		return 22;
++	} else if ((pid == 12) || (pid >= 14 && pid <= 23)) {
++		return (pid % 2) ? (pid - 3) : (pid + 1);
++	} else if (pid == 13) {
++		return 24;
++	} else if (pid >= 24 && pid < 35) {
++		return pid + 1;
++	} else if (pid == 35) {
++		return 46;
++	} else if ((pid == 36) || (pid >= 38 && pid <= 47)) {
++		return (pid % 2) ? (pid - 3) : (pid + 1);
++	} else if (pid == 37) {
++		return 0;
++	} else {
++		BUG();
++	}
++#else
++	#error Unknown value for SCC_CORECOUNT.
++#endif
++}
++EXPORT_SYMBOL(sccsys_get_next_pid);
++
++/* Acquire the test&set register of the specified PID. This call returns 1 if
++ * the lock has successfully been acquired, or 0 otherwise.
++ *
++ * In the current implementation, the call does only fail if the PID is invalid
++ * (i.e., outside of the range from 0 to SCC_CORECOUNT-1) or mapping of the
++ * configuration registers has failed.
++ */
++int sccsys_acquire_pid_lock(scc_pid_t pid)
++{
++#ifdef CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++	unsigned long flags;
++#endif // CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++
++	void* lock_address;
++
++	/* Simply ignore the test&set register if locking is disabled */
++	if (disable_locking) {
++		return 1;
++	}
++  
++	/* Get address of test&set register for target  */
++	lock_address = sccsys_get_crb_entry_for_pid(pid, SCC_LOCK0, SCC_LOCK1);
++	if (!lock_address) {
++		return 0;
++	}
++
++#ifdef CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++	spin_lock_irqsave(&sccsys->lock[pid], flags);
++
++	/* Check for recursive acquire */
++	if (++sccsys->lock_count[pid] != 1) {
++		spin_unlock_irqrestore(&sccsys->lock[pid], flags);
++		return 1;
++	}
++#endif // CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++
++	/* The LOCK bit is clear-on-read i.e. we have exclusive access when
++	 * reading a '1'.
++	 */
++	while (!(readb((void*)lock_address) & 0x1)) cpu_relax();
++
++#ifdef CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++	/* Release the spinlock after acquiring the PID lock, to guard against
++	 * simultaneous calls from different threads. */
++	spin_unlock_irqrestore(&sccsys->lock[pid], flags);
++#endif // CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++
++	return 1;
++}
++EXPORT_SYMBOL(sccsys_acquire_pid_lock);
++
++/* Release the test&set register of the specified PID. This call returns 1 if
++ * the lock has successfully been released, or 0 otherwise.
++ *
++ * In the current implementation, the call does only fail if the PID is invalid
++ * (i.e., outside of the range from 0 to SCC_CORECOUNT-1) or mapping of the
++ * configuration registers has failed.
++ */
++int sccsys_release_pid_lock(scc_pid_t pid)
++{
++#ifdef CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++	unsigned long flags;
++#endif // CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++
++	void* lock_address;
++
++	/* Simply ignore the test&set register if locking is disabled */
++	if (disable_locking) {
++		return 1;
++	}
++  
++	/* Get address of test&set register for target  */
++	lock_address = sccsys_get_crb_entry_for_pid(pid, SCC_LOCK0, SCC_LOCK1);
++	if (!lock_address) {
++		return 0;
++	}
++
++#ifdef CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++	spin_lock_irqsave(&sccsys->lock[pid], flags);
++
++	/* Check for recursive release */
++	if (--sccsys->lock_count[pid] != 0) {
++		spin_unlock_irqrestore(&sccsys->lock[pid], flags);
++		return 1;
++	}
++#endif // CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++
++	/* The LOCK bit can be set by writing an arbitrary value to the
++	   register.
++	 */
++	writeb(0, lock_address);
++
++#ifdef CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++	/* Release the spinlock after releasing the PID lock, to guard against
++	 * simultaneous calls from different threads. */
++	spin_unlock_irqrestore(&sccsys->lock[pid], flags);
++#endif // CONFIG_SCCSYS_RECURSIVE_PID_LOCK
++
++	return 1;
++}
++EXPORT_SYMBOL(sccsys_release_pid_lock);
++
++#define SCCSYS_TRIGGER_MODE_SET		0
++#define SCCSYS_TRIGGER_MODE_EDGE_IRQ	1
++#define SCCSYS_TRIGGER_MODE_LEVEL_IRQ	2
++
++/* Trigger a bit in a core's configuration register */
++static int sccsys_trigger_config_bits(scc_pid_t pid, unsigned int bits, unsigned int irq_clear_mask, int mode)
++{
++	void* conf_address;
++	unsigned int value;
++
++	/* Get address of per-cpu configuration register */
++	conf_address = sccsys_get_crb_entry_for_pid(pid, SCC_GLCFG0, SCC_GLCFG1);
++	if (!conf_address) {
++		return 0;
++	}
++
++	/* Acquire the lock */
++	if (!sccsys_acquire_pid_lock(pid)) {
++		return 0;
++	}
++
++	value = readl(conf_address);
++	if ((mode == SCCSYS_TRIGGER_MODE_LEVEL_IRQ) && (value & bits)) {
++		value &= ~irq_clear_mask;
++		writel(value, conf_address);
++	}
++
++	value |= bits;
++	writel(value, conf_address);
++
++	if (mode == SCCSYS_TRIGGER_MODE_EDGE_IRQ) {
++		value &= ~irq_clear_mask;
++		writel(value, conf_address);
++	}
++
++	/* Release the lock */
++	sccsys_release_pid_lock(pid);
++
++	return 1;
++}
++
++/* Set a bit in a core's configuration register */
++int sccsys_set_config_bits(scc_pid_t pid, unsigned int bits)
++{
++	return sccsys_trigger_config_bits(pid, bits, 0, SCCSYS_TRIGGER_MODE_SET);
++}
++EXPORT_SYMBOL(sccsys_set_config_bits);
++
++/* Trigger an interrupt to a core (directly via the configuration register) */
++int sccsys_trigger_irq_direct(scc_pid_t pid, unsigned int bits, int edgeIrq)
++{
++	return sccsys_trigger_config_bits(pid, bits,
++		SCC_INTR_MASK | SCC_NMI_MASK,
++		edgeIrq ? SCCSYS_TRIGGER_MODE_EDGE_IRQ :
++			  SCCSYS_TRIGGER_MODE_LEVEL_IRQ);
++}
++EXPORT_SYMBOL(sccsys_trigger_irq_direct);
++
++/* Clear a bit for a core's configuration register */
++int sccsys_clear_config_bits(scc_pid_t pid, unsigned int bits)
++{
++	void* conf_address;
++
++	/* Get address of per-cpu configuration register */
++	conf_address = sccsys_get_crb_entry_for_pid(pid, SCC_GLCFG0, SCC_GLCFG1);
++	if (!conf_address) {
++		return 0;
++	}
++
++	/* Acquire the lock */
++	if (!sccsys_acquire_pid_lock(pid)) {
++		return 0;
++	}
++
++	/* Clear the bits */
++	writel(readl(conf_address) & ~bits, conf_address);
++
++	/* Release the lock */
++	sccsys_release_pid_lock(pid);
++
++	return 1;
++}
++EXPORT_SYMBOL(sccsys_clear_config_bits);
++
++/* Clear an interrupt request bit for a processor identified by pid. */
++int sccsys_clear_irq_direct(scc_pid_t pid, unsigned int bits)
++{
++	return sccsys_clear_config_bits(pid, bits);
++}
++EXPORT_SYMBOL(sccsys_clear_irq_direct);
++
++/* Read LUT entry */
++scc_lut_t sccsys_read_lut_entry(scc_pid_t pid, unsigned int index)
++{
++	void* lut_address;
++	scc_lut_t lut;
++
++	lut.raw = 0;
++	if (index > 255) {
++		return lut;
++	}
++
++	/* Get address of per-cpu configuration register */
++	lut_address = sccsys_get_crb_entry_for_pid(pid, SCC_LUT0, SCC_LUT1);
++	if (!lut_address) {
++		return lut;
++	}
++
++	lut.raw = readl(lut_address + SCC_LUT_STRIDE * index);
++	return lut;
++}
++EXPORT_SYMBOL(sccsys_read_lut_entry);
++
++/* Write LUT entry */
++int sccsys_write_lut_entry(scc_pid_t pid, unsigned int index, scc_lut_t lut)
++{
++	void* lut_address;
++
++	if (index > 255) {
++		return 0;
++	}
++
++	/* Get address of per-cpu configuration register */
++	lut_address = sccsys_get_crb_entry_for_pid(pid, SCC_LUT0, SCC_LUT1);
++	if (!lut_address) {
++		return 0;
++	}
++
++	writel(lut.raw, lut_address + SCC_LUT_STRIDE * index);
++	return 1;
++}
++EXPORT_SYMBOL(sccsys_write_lut_entry);
++
++/* Read Global Clock Unit (GCU) configuration register */
++scc_gckcfg_t sccsys_read_gcbcfg(scc_pid_t pid)
++{
++	void* address;
++	scc_gckcfg_t value;
++
++	address = sccsys_get_crb_entry_for_tile_of_pid(pid, SCC_GCBCFG);
++	if (!address) {
++		value.raw = 0;
++	} else {
++		value.raw = readl(address);
++	}
++
++	return value;
++}
++EXPORT_SYMBOL(sccsys_read_gcbcfg);
++
++/* Write Global Clock Unit (GCU) configuration register */
++int sccsys_write_gcbcfg(scc_pid_t pid, scc_gckcfg_t cfg)
++{
++	void* address;
++
++	address = sccsys_get_crb_entry_for_tile_of_pid(pid, SCC_GCBCFG);
++	if (!address) {
++		return 0;
++	}
++
++	writel(cfg.raw, address);
++	return 1;
++}
++EXPORT_SYMBOL(sccsys_write_gcbcfg);
++
++/* Get address of mapped global configuration register bank */
++void* sccsys_get_grb(void)
++{
++	return sccsys->grb;
++}
++EXPORT_SYMBOL(sccsys_get_grb);
++
++/* Read global configuration register */
++unsigned sccsys_read_grb_entry(unsigned int offset)
++{
++	return readl(sccsys->grb + offset);
++}
++EXPORT_SYMBOL(sccsys_read_grb_entry);
++
++/* Write global configuration register */
++void sccsys_write_grb_entry(unsigned int offset, unsigned value)
++{
++	writel(value, sccsys->grb + offset);
++}
++EXPORT_SYMBOL(sccsys_write_grb_entry);
++
++/* Convert a node-local physical address into a system address */
++scc_addr_t sccsys_physical_to_system(scc_pid_t pid, unsigned long pa)
++{
++	unsigned int lut_index = (pa >> 24) & 0xFF;
++	scc_lut_t lut = sccsys_read_lut_entry(pid, lut_index);
++	scc_addr_t sccaddr;
++
++	sccaddr.bypass = lut.bypass;
++	sccaddr.y = lut.y;
++	sccaddr.x = lut.x;
++	sccaddr.subdest = lut.subdest;
++	sccaddr.address = lut.address;
++	sccaddr.offset = pa & 0x00FFFFFF;
++
++	return sccaddr;
++}
++EXPORT_SYMBOL(sccsys_physical_to_system);
++
++/* Read frequency of the fast clock from the global configuration register bank */
++unsigned short sccsys_read_grb_fastclock(void)
++{
++	return (unsigned short)(sccsys_read_grb_entry(SCCGRB_CLKFREQ) & 0xFFFF);
++}
++EXPORT_SYMBOL(sccsys_read_grb_fastclock);
++
++module_init(sccsys_init);
++module_exit(sccsys_exit);
++MODULE_DESCRIPTION("SCC system driver");
++MODULE_AUTHOR("Jan-Arne Sobania <jan-arne.sobania@hpi.uni-potsdam.de>");
++
+diff -urN linux-3.1.4/arch/x86/kernel/early_printk.c linux-3.1.4-scc/arch/x86/kernel/early_printk.c
+--- linux-3.1.4/arch/x86/kernel/early_printk.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/kernel/early_printk.c	2011-12-20 15:27:07.578352779 +0100
+@@ -169,6 +169,37 @@
+ 	.index =	-1,
+ };
+ 
++#ifdef CONFIG_X86_SCC
++spinlock_t scclock;
++
++static int scc_putc(unsigned char ch)
++{
++	unsigned long flags;
++
++	spin_lock_irqsave(&scclock, flags);
++	outb(ch, 0x80);
++	spin_unlock_irqrestore(&scclock, flags);
++	return 0;
++}
++
++static void scc_write(struct console *con, const char *s, unsigned n)
++{
++	while (*s && n-- > 0) {
++		if (*s == '\n')
++			scc_putc('\r');
++		scc_putc(*s);
++		s++;
++	}
++}
++
++static struct console scc_console = {
++	.name =		"scccon",
++	.write =	scc_write,
++	.flags =	CON_PRINTBUFFER,
++	.index =	-1,
++};
++#endif
++
+ /* Direct interface for emergencies */
+ static struct console *early_console = &early_vga_console;
+ static int __initdata early_console_initialized;
+@@ -251,6 +282,10 @@
+ 			early_console_register(&early_hsu_console, keep);
+ 		}
+ #endif
++#ifdef CONFIG_X86_SCC
++		if (!strncmp(buf, "scc", 3))
++			early_console_register(&scc_console, keep);
++#endif
+ 		buf++;
+ 	}
+ 	return 0;
+diff -urN linux-3.1.4/arch/x86/kernel/head32.c linux-3.1.4-scc/arch/x86/kernel/head32.c
+--- linux-3.1.4/arch/x86/kernel/head32.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/kernel/head32.c	2011-12-20 15:27:07.578352779 +0100
+@@ -54,6 +54,9 @@
+ 	case X86_SUBARCH_CE4100:
+ 		x86_ce4100_early_setup();
+ 		break;
++	case X86_SUBARCH_SCC:
++		x86_scc_early_setup();
++		break;
+ 	default:
+ 		i386_default_early_setup();
+ 		break;
+diff -urN linux-3.1.4/arch/x86/kernel/head_32.S linux-3.1.4-scc/arch/x86/kernel/head_32.S
+--- linux-3.1.4/arch/x86/kernel/head_32.S	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/kernel/head_32.S	2011-12-20 15:27:07.578352779 +0100
+@@ -259,6 +259,8 @@
+ 	.long lguest_entry		/* lguest hypervisor */
+ 	.long xen_entry			/* Xen hypervisor */
+ 	.long default_entry		/* Moorestown MID */
++	.long default_entry		/* CE4100 */
++	.long default_entry		/* SCC */
+ num_subarch_entries = (. - subarch_entries) / 4
+ .previous
+ #else
+diff -urN linux-3.1.4/arch/x86/kernel/rtc.c linux-3.1.4-scc/arch/x86/kernel/rtc.c
+--- linux-3.1.4/arch/x86/kernel/rtc.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/kernel/rtc.c	2011-12-20 15:27:07.578352779 +0100
+@@ -157,6 +157,7 @@
+ /* Routines for accessing the CMOS RAM/RTC. */
+ unsigned char rtc_cmos_read(unsigned char addr)
+ {
++#ifndef CONFIG_X86_SCC
+ 	unsigned char val;
+ 
+ 	lock_cmos_prefix(addr);
+@@ -165,15 +166,20 @@
+ 	lock_cmos_suffix(addr);
+ 
+ 	return val;
++#else
++	return 0;
++#endif
+ }
+ EXPORT_SYMBOL(rtc_cmos_read);
+ 
+ void rtc_cmos_write(unsigned char val, unsigned char addr)
+ {
++#ifndef CONFIG_X86_SCC
+ 	lock_cmos_prefix(addr);
+ 	outb(addr, RTC_PORT(0));
+ 	outb(val, RTC_PORT(1));
+ 	lock_cmos_suffix(addr);
++#endif
+ }
+ EXPORT_SYMBOL(rtc_cmos_write);
+ 
+diff -urN linux-3.1.4/arch/x86/kernel/tsc.c linux-3.1.4-scc/arch/x86/kernel/tsc.c
+--- linux-3.1.4/arch/x86/kernel/tsc.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/kernel/tsc.c	2011-12-20 15:27:07.578352779 +0100
+@@ -668,6 +668,9 @@
+ }
+ 
+ #ifdef CONFIG_CPU_FREQ
++#ifdef CONFIG_X86_SCC_TSC_TRACK_CPU_FREQ
++static struct clocksource clocksource_tsc;
++#endif
+ 
+ /* Frequency scaling support. Adjust the TSC based timer when the cpu frequency
+  * changes.
+@@ -716,6 +719,20 @@
+ 
+ 	set_cyc2ns_scale(tsc_khz, freq->cpu);
+ 
++#ifdef CONFIG_X86_SCC_TSC_TRACK_CPU_FREQ
++	/* Update the clocksource with the new TSC frequency. */
++	__clocksource_updatefreq_khz(&clocksource_tsc, tsc_khz);
++
++	/* If the clock source is currently being used, simply updating its
++	 * frequency will not make the timekeeper honor the new values. Instead,
++	 * we need to switch to another time source (which can be anything),
++	 * then switch back to the TSC. */
++	if (timekeeping_get_clock() == &clocksource_tsc) {
++		timekeeping_notify(clocksource_default_clock());
++		timekeeping_notify(&clocksource_tsc);
++	}
++#endif // CONFIG_X86_SCC_TSC_TRACK_CPU_FREQ
++
+ 	return 0;
+ }
+ 
+diff -urN linux-3.1.4/arch/x86/mm/dump_pagetables.c linux-3.1.4-scc/arch/x86/mm/dump_pagetables.c
+--- linux-3.1.4/arch/x86/mm/dump_pagetables.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/mm/dump_pagetables.c	2011-12-20 15:27:07.578352779 +0100
+@@ -124,6 +124,14 @@
+ 				seq_printf(m, "PSE ");
+ 			else
+ 				seq_printf(m, "    ");
++#ifdef CONFIG_X86_SCC
++		} else if ((level == 4) && ((read_cr4() & (X86_CR4_PSE |
++			X86_CR4_MPE)) == X86_CR4_MPE))  {
++			if (pr & _PAGE_PMB)
++				seq_printf(m, "PMB ");
++			else
++				seq_printf(m, "    ");
++#endif
+ 		} else {
+ 			if (pr & _PAGE_PAT)
+ 				seq_printf(m, "pat ");
+diff -urN linux-3.1.4/arch/x86/mm/ioremap.c linux-3.1.4-scc/arch/x86/mm/ioremap.c
+--- linux-3.1.4/arch/x86/mm/ioremap.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/mm/ioremap.c	2011-12-20 15:27:07.578352779 +0100
+@@ -71,6 +71,7 @@
+ 	pgprot_t prot;
+ 	int retval;
+ 	void __iomem *ret_addr;
++	int mpbt_flag = (prot_val & _PAGE_PSE) != 0;
+ 
+ 	/* Don't allow wraparound or zero size */
+ 	last_addr = phys_addr + size - 1;
+@@ -145,6 +146,11 @@
+ 		break;
+ 	}
+ 
++	/* SCC: set the MPBT flag if it has been requested before */
++	if (mpbt_flag) {
++		prot = __pgprot(pgprot_val(prot) | _PAGE_PSE);
++	}
++
+ 	/*
+ 	 * Ok, go for it..
+ 	 */
+@@ -250,6 +256,13 @@
+ }
+ EXPORT_SYMBOL(ioremap_prot);
+ 
++void __iomem *ioremap_mpbt(resource_size_t phys_addr, unsigned long size)
++{
++	return __ioremap_caller(phys_addr, size, _PAGE_PSE | _PAGE_CACHE_WC,
++				__builtin_return_address(0));
++}
++EXPORT_SYMBOL(ioremap_mpbt);
++
+ /**
+  * iounmap - Free a IO remapping
+  * @addr: virtual address from ioremap_*
+@@ -567,6 +580,13 @@
+ 	return __early_ioremap(phys_addr, size, PAGE_KERNEL_IO);
+ }
+ 
++/* Remap an IO device (without caching) */
++void __init __iomem *
++early_ioremap_nocache(resource_size_t phys_addr, unsigned long size)
++{
++	return __early_ioremap(phys_addr, size, PAGE_KERNEL_IO_NOCACHE);
++}
++
+ /* Remap memory */
+ void __init __iomem *
+ early_memremap(resource_size_t phys_addr, unsigned long size)
+diff -urN linux-3.1.4/arch/x86/mm/pageattr.c linux-3.1.4-scc/arch/x86/mm/pageattr.c
+--- linux-3.1.4/arch/x86/mm/pageattr.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/mm/pageattr.c	2011-12-20 15:27:07.578352779 +0100
+@@ -998,6 +998,37 @@
+ }
+ EXPORT_SYMBOL(set_memory_uc);
+ 
++#ifdef CONFIG_X86_SCC
++int set_memory_mpbt(unsigned long start, int numpages)
++{
++	unsigned int i, level;
++	unsigned long addr;
++
++	BUG_ON(irqs_disabled());
++	WARN_ON(PAGE_ALIGN(start) != start);
++
++	on_each_cpu(__cpa_flush_range, NULL, 1);
++
++	for (i = 0, addr = start; i < numpages; i++, addr += PAGE_SIZE) {
++		pte_t *pte = lookup_address(addr, &level);
++
++		if (pte) {
++			pte_mkhuge(*pte);
++		}
++	}
++	return 0;
++	//return change_page_attr_set(&start, numpages, __pgprot(_PAGE_PSE), 0);
++}
++EXPORT_SYMBOL(set_memory_mpbt);
++
++int set_memory_wt_mpbt(unsigned long addr, int numpages)
++{
++	return change_page_attr_set(&addr, numpages,
++				    __pgprot(_PAGE_CACHE_WC | _PAGE_PMB), 0);
++}
++EXPORT_SYMBOL(set_memory_wt_mpbt);
++#endif
++
+ int _set_memory_array(unsigned long *addr, int addrinarray,
+ 		unsigned long new_type)
+ {
+@@ -1172,6 +1203,24 @@
+ }
+ EXPORT_SYMBOL(set_pages_uc);
+ 
++#ifdef CONFIG_X86_SCC
++int set_pages_mpbt(struct page *page, int numpages)
++{
++	unsigned long addr = (unsigned long)page_address(page);
++
++	return set_memory_mpbt(addr, numpages);
++}
++EXPORT_SYMBOL(set_pages_mpbt);
++
++int set_pages_wt_mpbt(struct page *page, int numpages)
++{
++	unsigned long addr = (unsigned long)page_address(page);
++
++	return set_memory_wt_mpbt(addr, numpages);
++}
++EXPORT_SYMBOL(set_pages_wt_mpbt);
++#endif
++
+ static int _set_pages_array(struct page **pages, int addrinarray,
+ 		unsigned long new_type)
+ {
+diff -urN linux-3.1.4/arch/x86/platform/Makefile linux-3.1.4-scc/arch/x86/platform/Makefile
+--- linux-3.1.4/arch/x86/platform/Makefile	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/platform/Makefile	2011-12-20 15:27:07.578352779 +0100
+@@ -8,3 +8,4 @@
+ obj-y	+= sfi/
+ obj-y	+= visws/
+ obj-y	+= uv/
++obj-y	+= scc/
+diff -urN linux-3.1.4/arch/x86/platform/scc/Makefile linux-3.1.4-scc/arch/x86/platform/scc/Makefile
+--- linux-3.1.4/arch/x86/platform/scc/Makefile	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/platform/scc/Makefile	2011-12-20 15:27:07.578352779 +0100
+@@ -0,0 +1 @@
++obj-$(CONFIG_X86_SCC)		+= scc.o
+diff -urN linux-3.1.4/arch/x86/platform/scc/scc.c linux-3.1.4-scc/arch/x86/platform/scc/scc.c
+--- linux-3.1.4/arch/x86/platform/scc/scc.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/arch/x86/platform/scc/scc.c	2011-12-20 15:27:07.578352779 +0100
+@@ -0,0 +1,290 @@
++/*
++ * scc.c: SCC platform specific setup code
++ *
++ * (C) Copyright 2011 Jan-Arne Sobania, Hasso-Plattner-Institut
++ * Author: Jan-Arne Sobania (jan-arne.sobania@hpi.uni-potsdam.de)
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; version 2
++ * of the License.
++ */
++#include <linux/init.h>
++#include <linux/kernel.h>
++#include <linux/irq.h>
++#include <linux/interrupt.h>
++#include <linux/module.h>
++#include <linux/mm_types.h>
++
++#include <asm/setup.h>
++#include <asm/apic.h>
++#include <asm/lapic.h>
++#include <asm/io.h>
++#include <asm/i8259.h>
++#include <asm/e820.h>
++#include <asm/paravirt.h>
++
++#include <linux/sccsys.h>	/* for CRB/GRB definitions only */
++
++
++static int scc_subarch_enabled = 0;
++static unsigned long scc_boot_busclock = CONFIG_SCC_BUSCLOCK;
++
++/*
++ * Here we do all the Local APIC initialization and stuff required to get the wormhole
++ * IRQ delivered through LINT0 / 1
++ *
++ * LINT 0 services the UART at address 0x3f8 using IRQ4,
++ * LINT 1 services the UART at address 0x2f8 using IRQ3.
++ */
++
++struct sccirq_entry {
++	u32 reg;
++	const char* name;
++};
++
++struct sccirq_entry sccirqs[] = {
++	{ APIC_LVT1, "LINT1" },
++	{ APIC_LVT0, "LINT0" }
++};
++
++#define SCCIRQ_FIRST_VECTOR	3
++#define SCCIRQ_LAST_VECTOR	4
++
++#define LVT0_IRQ 4
++#define LVT1_IRQ 3
++
++static struct sccirq_entry* sccirq_get_entry(int irq)
++{
++	if (irq >= SCCIRQ_FIRST_VECTOR && irq <= SCCIRQ_LAST_VECTOR) {
++		return &sccirqs[irq - SCCIRQ_FIRST_VECTOR];
++	} else {
++		panic("SCC: unable to map irq %d to LVT register.\n", irq);
++	}
++}
++
++static void sccirq_mask_lapic(struct irq_data *data)
++{
++	set_lapic_mask(sccirq_get_entry(data->irq)->reg, data->irq);
++}
++
++static void sccirq_unmask_lapic(struct irq_data *data)
++{
++	unset_lapic_mask(sccirq_get_entry(data->irq)->reg, data->irq);
++}
++
++static void sccirq_ack_lapic(struct irq_data *data)
++{
++	ack_APIC_irq();
++}
++
++static struct irq_chip sccirq_lapic_chip __read_mostly = {
++	.name		= "LAPIC-WORMHOLE",
++	.irq_mask	= sccirq_mask_lapic,
++	.irq_unmask	= sccirq_unmask_lapic,
++	.irq_ack	= sccirq_ack_lapic,
++	.irq_disable    = sccirq_mask_lapic,
++};
++
++
++void __init scc_setup_local_APIC_LINT(void)
++{
++	// set up LVT0 and LVT1 to point to IRQ4/3 vector
++	// set up LINT 0 and LINT 1 IRQ handling through LAPIC
++	apic_write(APIC_LVT0, (IRQ0_VECTOR + LVT0_IRQ) | APIC_LVT_MASKED | (APIC_MODE_FIXED << 8));
++	apic_write(APIC_LVT1, (IRQ0_VECTOR + LVT1_IRQ) | APIC_LVT_MASKED | (APIC_MODE_FIXED << 8));
++}
++
++#ifdef CONFIG_SCC_QUERY_FREQUENCY_FROM_FPGA
++/*
++ * Read a single unsigned int from a physical address. This routine maps the
++ * page of physical memory using a non-caching version of early_ioremap, so it
++ * should be called sparingly, and only until the full ioremap is available. */
++static unsigned int __init scc_early_readl_phys(unsigned int phys)
++{
++	unsigned int phys_page = phys & ~(PAGE_SIZE - 1);
++	unsigned int phys_offset = phys - phys_page;
++	unsigned int value;
++	void* base;
++
++	base = early_ioremap_nocache(phys_page, PAGE_SIZE);
++	value = readl(base + phys_offset);
++	early_iounmap(base, PAGE_SIZE);
++
++	return value;
++}
++
++/*
++ * Query tile clock. This code is an exact duplicate of the one from sccfreq,
++ * but we need to include it here because the driver is not initialized at this
++ * point, or may never be loaded at all.
++ */
++static unsigned int __init scc_early_query_tile_frequency(void)
++{
++	unsigned int fastclock = 0;
++	unsigned int divider = 0;
++	unsigned int freq = 0;
++
++	/* Get fastclock */
++	fastclock = scc_early_readl_phys(0xF9000000 + SCCGRB_CLKFREQ) & 0xFFFF;
++
++	/* Get core divider */
++	divider = scc_early_readl_phys(0xF8000000 + SCC_GCBCFG);
++	divider = (divider >> 8) & 0xF;
++	divider++;
++
++	/* Fallback to 533MHz */
++	if (!divider || !fastclock) {
++		freq = 533000;
++	} else {
++		/* Calculate new frequency */
++		freq = fastclock / divider * 1000;
++	}
++
++	/* return frequency */
++	return freq;
++}
++#endif // CONFIG_SCC_QUERY_FREQUENCY_FROM_FPGA
++
++/*
++ * SCC architecture initialization.
++ */
++static void __init scc_arch_setup(void)
++{
++	unsigned long real_busclock_khz;
++
++	if (boot_cpu_data.x86 == 5 && boot_cpu_data.x86_model == 2) {
++		printk(KERN_NOTICE "SCC: Intel GaussLake/P54C identified\n");
++
++#ifdef CONFIG_SCC_QUERY_FREQUENCY_FROM_FPGA
++		/* Read busclock from FPGA */
++		real_busclock_khz = scc_early_query_tile_frequency();
++
++		if (scc_boot_busclock == real_busclock_khz * 1000) {
++			printk(KERN_NOTICE "     Configured busclock of %lu.%03lu mHz matches detected busclock.\n",
++				scc_boot_busclock / 1000000,
++				(scc_boot_busclock / 1000) % 1000);
++		} else {
++			printk(KERN_NOTICE "     Overwriting configured busclock of %lu.%03lu mHz with detected busclock of %lu.%03lu mHz.\n",
++				scc_boot_busclock / 1000000,
++				(scc_boot_busclock / 1000) % 1000,
++				real_busclock_khz / 1000,
++				real_busclock_khz % 1000);
++			scc_boot_busclock = real_busclock_khz * 1000;
++		}
++#endif // CONFIG_SCC_QUERY_FREQUENCY_FROM_FPGA
++	} else
++		printk(KERN_NOTICE "SCC: Unknown CPU (%d:%d)\n",
++			boot_cpu_data.x86,
++			boot_cpu_data.x86_model);
++}
++
++/* Get bus frequency at boot time. */
++unsigned long scc_get_boot_busclock(void)
++{
++	return scc_boot_busclock;
++}
++EXPORT_SYMBOL_GPL(scc_get_boot_busclock);
++
++/*
++ * There is no legacy interrupt controller in the system, so there is also no
++ * need to perform initialization of ISA interrupts.
++ */
++static void __init scc_pre_vector_init(void)
++{
++	int irq;
++
++	/* Register wormhole interrupts. */
++	for (irq = SCCIRQ_FIRST_VECTOR; irq <= SCCIRQ_LAST_VECTOR; irq++) {
++		/* Add vector to IRQ mapping */
++		per_cpu(vector_irq, 0)[IRQ0_VECTOR + irq] = irq;
++
++		/* Set flags and install handler */
++		irq_clear_status_flags(irq, IRQ_LEVEL);
++		irq_set_chip_and_handler_name(irq, &sccirq_lapic_chip,
++			handle_edge_irq, sccirq_get_entry(irq)->name);
++	}
++}
++
++/*
++ * The per-cpu clock source is the LAPIC clock. However, this routine also gets
++ * called just in time to complete initialization of the wormhole interrupts.
++ */
++static void __init scc_setup_boot_cpu_clockev(void)
++{
++	scc_setup_local_APIC_LINT();
++	setup_boot_APIC_clock();
++}
++
++/*
++ * SCC systems don't have a secondary clock source, so we cannot perform the
++ * default calibration protocol for the TSC. Instead, we rely on the kernel
++ * configuration specifying the real bus block.
++ */
++static unsigned long __init scc_calibrate_tsc(void)
++{
++	unsigned long tsc_khz = scc_boot_busclock / 1000; /* in kHz */
++
++	printk(KERN_INFO "SCC: TSC calibration skipped. Returning pre-configured BUSCLOCK value of %lu.%03lu mHz.\n",
++		tsc_khz / 1000, tsc_khz % 1000);
++
++	return tsc_khz;
++}
++
++/* SCC systems don't have an i8042 controller */
++static int scc_i8042_detect(void)
++{
++	return 0;
++}
++
++/* Check whether we are running on the lowest layer on SCC hardware */
++int scc_bare_metal(void)
++{
++	return scc_subarch_enabled && !paravirt_enabled();
++}
++EXPORT_SYMBOL(scc_bare_metal);
++
++/*
++ * SCC specific x86_init function overrides and early setup
++ * calls.
++ */
++void __init x86_scc_early_setup(void)
++{
++	/* We are about to use the SCC sub-architecture */
++	scc_subarch_enabled = 1;
++
++	/* Architecture initialization */
++	x86_init.oem.arch_setup = scc_arch_setup;
++
++	/* Static configuration of interrupt vectors */
++	x86_init.irqs.pre_vector_init = scc_pre_vector_init;
++	legacy_pic = &null_legacy_pic;
++
++	/* Calibrate timestamp counter */
++	x86_platform.calibrate_tsc = scc_calibrate_tsc;
++
++	/* Timer. NOPed to prevent the legacy PIT from being initialized.
++	 * Please note that legacy_pic->nr_legacy_itqs must be equal to 0,
++	 * or io_apic.c!print_PIC will try to access PIT registers anyway.
++	 */
++	x86_init.timers.timer_init = x86_init_noop;
++
++	/* Per-CPU clock source. This eventually delegates to the default
++	 * routine of setup_boot_APIC_clock, but we need to complete LAPIC
++	 * initialization first by registering the wormhole interrupts.
++	 */
++	x86_init.timers.setup_percpu_clockev = scc_setup_boot_cpu_clockev;
++
++	/* Detect 8042 (keyboard controller). NOPed. */
++	x86_platform.i8042_detect = scc_i8042_detect;
++
++	/* Avoid searching for BIOS MP tables */
++	x86_init.mpparse.find_smp_config = x86_init_noop;
++	x86_init.mpparse.get_smp_config = x86_init_uint_noop;
++
++	/* Avoid searching for extension ROMs */
++	x86_init.resources.probe_roms = x86_init_noop;
++
++	/* Avoid reserving legacy PC resources */
++	x86_init.resources.reserve_resources = x86_init_noop;
++}
+diff -urN linux-3.1.4/drivers/char/Kconfig linux-3.1.4-scc/drivers/char/Kconfig
+--- linux-3.1.4/drivers/char/Kconfig	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/drivers/char/Kconfig	2011-12-20 15:27:07.578352779 +0100
+@@ -4,6 +4,31 @@
+ 
+ menu "Character devices"
+ 
++config SCCMEM
++	bool "SCC system memory driver"
++	default n
++	depends on SCCSYS
++	---help---
++	  SCC memory driver. This driver provides the rckncm, rckmpb and
++	  rckdcm devices to applications.
++
++config SCCPERF
++	tristate "SCC performance meter driver"
++	default n
++	depends on SCCSYS
++	---help---
++	  This driver reports the core's CPU utilization to the MCPC via shared
++	  memory. It can be enabled if using the modified cpuutil program is
++	  not desired.
++
++config SCCPROC
++	bool "SCC procfs driver"
++	default n
++	depends on SCCSYS
++	---help---
++	  This driver provides SCC-specific entries in the /proc file
++	  system.
++
+ source "drivers/tty/Kconfig"
+ 
+ config DEVKMEM
+diff -urN linux-3.1.4/drivers/char/Makefile linux-3.1.4-scc/drivers/char/Makefile
+--- linux-3.1.4/drivers/char/Makefile	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/drivers/char/Makefile	2011-12-20 15:27:07.578352779 +0100
+@@ -2,6 +2,10 @@
+ # Makefile for the kernel character device drivers.
+ #
+ 
++obj-$(CONFIG_SCCMEM)		+= sccmem.o
++obj-$(CONFIG_SCCPERF)		+= sccperf.o
++obj-y				+= sccproc/
++
+ obj-y				+= mem.o random.o
+ obj-$(CONFIG_TTY_PRINTK)	+= ttyprintk.o
+ obj-y				+= misc.o
+diff -urN linux-3.1.4/drivers/char/sccmem.c linux-3.1.4-scc/drivers/char/sccmem.c
+--- linux-3.1.4/drivers/char/sccmem.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/char/sccmem.c	2011-12-20 15:27:07.578352779 +0100
+@@ -0,0 +1,498 @@
++/*
++ *  linux/drivers/char/sccmem.c
++ *  
++ *  -> derived from:
++ *  linux/drivers/char/mem.c
++ *
++ *  Copyright (C) 1991, 1992  Linus Torvalds
++ *
++ *  Added devfs support. 
++ *    Jan-11-1998, C. Scott Ananian <cananian@alumni.princeton.edu>
++ *  Shared /dev/zero mmaping support, Feb 2000, Kanoj Sarcar <kanoj@sgi.com>
++ */
++
++#include <linux/version.h>
++#include <linux/init.h>
++#include <linux/module.h>
++#include <linux/fs.h>
++#include <linux/cdev.h>
++#include <linux/slab.h>
++#include <linux/vmalloc.h>
++#include <linux/mm.h>
++#include <linux/miscdevice.h>
++#include <linux/highmem.h>
++
++#ifdef MODVERSIONS
++#  include <linux/modversions.h>
++#endif
++#include <asm/io.h>
++
++#include <linux/sccsys.h>
++
++/* DEBUG messages */
++#define DEBUG_MSG 0
++#define MAJOR_ADDR 222
++#define PRINTD(format, args...) if (DEBUG_MSG) { printk(format, ##args); }
++
++/* Symbols */
++#define OWN_MPB     0xd8000000
++
++#define MPBADDRBITS 13
++#define MPBSIZE     (1<<MPBADDRBITS)
++
++/* PSE bit for Pentium+ equals MPE (message buffer enable) flag in SCC! So, use it to create _PAGE_MPB symbol... */
++#define _PAGE_MPE _PAGE_PSE
++
++/* In order to force write-backs of modified data from the L2 cache we have
++ * to read new lines into every way. At 256kB, 4-way, 32B/line there are
++ * 2048 sets, i.e. the distances between addresses in a pair of ways is
++ * 2048*32B = 64kB.
++ */
++#define L2_LINESIZE 32UL
++#define L2_WAYS     4UL
++#define L2_CAPACITY (256*1024UL)
++#define L2_WBSTRIDE (L2_CAPACITY/L2_WAYS)
++
++/* Enable this to have the L2 flush routine execute a 'wbinvd'
++ * instruction before doing the actual flush. */
++// #define FLUSH_USES_WBINVD
++
++
++/* Virtual address and current offset in our flush-data block,
++ * which will be in an unused MPB address range */
++static size_t OWN_MPB_vaddr = 0;
++static size_t OWN_MPB_offset = 0;
++
++
++/* Methods of the character device */
++static int sccmem_open(struct inode *inode, struct file *filp);
++static int sccmem_release(struct inode *inode, struct file *filp);
++static int sccdcm_mmap(struct file *filp, struct vm_area_struct *vma);
++static int sccncm_mmap(struct file *filp, struct vm_area_struct *vma);
++static int sccmpb_mmap(struct file *filp, struct vm_area_struct *vma);
++/* For simplicity reasons, exising file operations are overloaded with
++ * new functionality:
++ * -read()  returns the physical address of the buffer
++ * -write() force write-backs of modified data from the caches
++ */
++static ssize_t sccdcm_read(struct file *filp,
++                           char __user *buf, 
++                           size_t count, 
++                           loff_t *ppos);
++static ssize_t sccdcm_write(struct file *filp, 
++                            const char __user *buf, 
++                            size_t count, 
++                            loff_t *ppos);
++
++/* The file operations, i.e. all character device methods */
++static struct file_operations sccdcm_fops = {
++	.open = sccmem_open, 
++        .release = sccmem_release, 
++        .mmap = sccdcm_mmap, 
++        .read = sccdcm_read,
++        .write = sccdcm_write,
++        .owner = THIS_MODULE
++};
++
++static struct file_operations sccncm_fops = {
++	.open = sccmem_open, 
++        .release = sccmem_release, 
++        .mmap = sccncm_mmap, 
++        .owner = THIS_MODULE
++};
++
++static struct file_operations sccmpb_fops = {
++	.open = sccmem_open, 
++        .release = sccmem_release, 
++        .mmap = sccmpb_mmap, 
++        .owner = THIS_MODULE
++};
++
++/* character device open method */
++static int sccmem_open(struct inode *inode, struct file *filp) {
++  return 0;
++}
++
++/* character device last close method */
++static int sccmem_release(struct inode *inode, struct file *filp) {
++  return 0;
++}
++
++/* Character device mmap method for noncachable memory mapped registers like CRB->GLCFG0 */
++static int sccncm_mmap(struct file *filp, struct vm_area_struct *vma) {
++  int minor = iminor(filp->f_dentry->d_inode);
++  int major = imajor(filp->f_dentry->d_inode);
++  size_t size = vma->vm_end - vma->vm_start;
++
++  PRINTD(KERN_DEBUG "sccncm_mmap: Device 0x%08lx (%d:%d),\n", (unsigned long)filp->f_dentry->d_inode->i_rdev, major, minor);
++  PRINTD(KERN_DEBUG "             VM Start: 0x%08lx, size: 0x%08lx, offset: 0x%08lx\n", (unsigned long) vma->vm_start, (unsigned long) size, (unsigned long) vma->vm_pgoff);
++
++  /* Mark the page protection value as "uncacheable" */
++  vma->vm_page_prot = __pgprot(pgprot_val(vma->vm_page_prot) | _PAGE_PCD | _PAGE_PWT);
++  PRINTD(KERN_DEBUG "             VM pgprot value is 0x%02lx!\n", pgprot_val(vma->vm_page_prot));
++
++  /* Remap-pfn-range will mark the range VM_IO and VM_RESERVED */
++  if (remap_pfn_range(vma,  vma->vm_start, vma->vm_pgoff, size, vma->vm_page_prot)) return -EAGAIN;
++
++  return 0;
++}
++
++/* Character device mmap method for cachable regular memory */
++static int sccdcm_mmap(struct file *filp, struct vm_area_struct *vma) {
++  int minor = iminor(filp->f_dentry->d_inode);
++  int major = imajor(filp->f_dentry->d_inode);
++  size_t size = vma->vm_end - vma->vm_start;
++
++  PRINTD(KERN_DEBUG "sccdcm_mmap: Device 0x%08lx (%d:%d),\n", (unsigned long)filp->f_dentry->d_inode->i_rdev, major, minor);
++  PRINTD(KERN_DEBUG "             VM Start: 0x%08lx, size: 0x%08lx, offset: 0x%08lx\n", (unsigned long) vma->vm_start, (unsigned long) size, (unsigned long) vma->vm_pgoff);
++
++  /* Mark the page protection value as "cacheable" */
++  vma->vm_page_prot = __pgprot((pgprot_val(vma->vm_page_prot) & ~(_PAGE_PCD | _PAGE_PWT)) );
++  PRINTD(KERN_DEBUG "             VM pgprot value is 0x%02lx!\n", pgprot_val(vma->vm_page_prot));
++
++  /* Remap-pfn-range will mark the range VM_IO and VM_RESERVED */
++  if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff, size, vma->vm_page_prot)) return -EAGAIN;
++
++  return 0;
++}
++
++/* Character device mmap method for cachable MPB-type memory */
++static int sccmpb_mmap(struct file *filp, struct vm_area_struct *vma) {
++  int minor = iminor(filp->f_dentry->d_inode);
++  int major = imajor(filp->f_dentry->d_inode);
++  size_t size = vma->vm_end - vma->vm_start;
++
++  PRINTD(KERN_DEBUG "sccmpb_mmap: Device 0x%08lx (%d:%d),\n", (unsigned long)filp->f_dentry->d_inode->i_rdev, major, minor);
++  PRINTD(KERN_DEBUG "             VM Start: 0x%08lx, size: 0x%08lx, offset: 0x%08lx\n", (unsigned long) vma->vm_start, (unsigned long) size, (unsigned long) vma->vm_pgoff);
++
++  /* Mark the page protection value as "cacheable" MPB type */
++  vma->vm_page_prot = __pgprot((pgprot_val(vma->vm_page_prot) & ~(_PAGE_PCD | _PAGE_PWT)) | _PAGE_MPE);
++  PRINTD(KERN_DEBUG "             VM pgprot value is 0x%02lx!\n", pgprot_val(vma->vm_page_prot));
++
++  /* Remap-pfn-range will mark the range VM_IO and VM_RESERVED */
++  if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff, size, vma->vm_page_prot)) return -EAGAIN;
++
++  return 0;
++}
++
++
++
++/* Character device read method to return the physical address
++ */
++static ssize_t sccdcm_read(struct file *filp, 
++                           char __user *buf, 
++                           size_t count, 
++                           loff_t *ppos)
++{
++  struct task_struct  *tsk;
++  struct mm_struct    *mm;
++  
++  pgd_t *pgd;
++  pud_t *pud;
++  pmd_t *pmd;
++  pte_t *pte;
++  
++  unsigned long physAddress;
++  unsigned long address = (unsigned long)buf;
++  
++  /* First get our process and memory information */
++  pte = 0;
++  tsk = current;
++  mm  = tsk->mm;
++    
++  pgd = pgd_offset(mm, address);
++  if (pgd_none(*pgd) ) return -EADDRNOTAVAIL; 
++  pud = pud_offset(pgd, address);
++  if (pud_none(*pud) ) return -EADDRNOTAVAIL;
++  pmd = pmd_offset(pud, address);
++  if (pmd_none(*pmd) ) return -EADDRNOTAVAIL;
++  pte = pte_offset_map(pmd, address);
++
++  if (pte_none(*pte) )
++  {
++    pte_unmap(pte);
++    return -EADDRNOTAVAIL;
++  }
++
++  physAddress = pte_val(*pte);
++  physAddress &= PAGE_MASK;
++  physAddress |= (address & ~PAGE_MASK);
++  
++  pte_unmap(pte);
++  
++  return physAddress;
++}
++
++
++/* Helper function to purge a specific set from the caches
++ * by reading invalid data into all ways
++ */
++__attribute__((always_inline)) static inline void sccdcm_purgeSet(unsigned long set)
++{
++  register char   tmp;
++
++  /* Translate the set to a kernel space virtual address */
++  const volatile char*  dummyData = (volatile char*)set;
++  
++  /* Now read new data into all four ways */
++  tmp = *dummyData;
++  tmp = *(dummyData + L2_WBSTRIDE);
++  tmp = *(dummyData + L2_WBSTRIDE * 2);
++  tmp = *(dummyData + L2_WBSTRIDE * 3);
++}
++
++
++/* Character device write method to write back modified data from the caches
++ * to main memory (cacheable memory, only)
++ */
++static ssize_t sccdcm_write(struct file *filp, 
++                            const char __user *buf, 
++                            size_t count, 
++                            loff_t *ppos)
++{
++  struct task_struct  *tsk;
++  struct mm_struct    *mm;
++
++  pgd_t *pgd;
++  pud_t *pud;
++  pmd_t *pmd;
++  pte_t *pte;
++
++  size_t        pos         = 0;
++  size_t        purgebase   = 0;
++  unsigned long physAddress = 0;
++  unsigned long address     = (unsigned long)buf;
++  unsigned long flags;
++
++
++  PRINTD(KERN_INFO "sccdcm_write(): Flushing %d bytes from 0x%08lX\n",
++                    count, address);
++
++  /* First disable interrupts to be sure nobody else accesses the cache
++   * in parallel and messes up the LRU state bits.
++   */
++  local_irq_save(flags);
++
++  /* Flip-flop between two parts of the flush area */
++  if(OWN_MPB_offset == 0)
++    OWN_MPB_offset = L2_CAPACITY;
++  else
++    OWN_MPB_offset = 0;
++
++  /* Set basepointer to flush area we will use in this flush */
++  purgebase = OWN_MPB_vaddr + OWN_MPB_offset;
++
++#ifdef FLUSH_USES_WBINVD
++  /* Now write-back and invalidate the L1 content so subsequent reads
++   * cannot trigger evictions which could again mess up L2 LRU state.
++   * It is not clear that this is required - disabling it saves about 10K cycles */
++  __asm__ volatile ( "wbinvd;\n\t" );
++#endif
++
++  /* In order to improve performance, check whether the entire cache has to
++   * be flushed first; use count=0 as shortcut.
++   */
++  if ((count==0) || (count>=L2_WBSTRIDE))
++  {
++    for (physAddress=purgebase; physAddress<purgebase+L2_WBSTRIDE; physAddress+=L2_LINESIZE)
++      sccdcm_purgeSet(physAddress);
++  }
++  else
++  {
++    /* First get our process and memory information */
++    pte = 0;
++    tsk = current;
++    mm  = tsk->mm;
++
++    /* Align the address to cacheline boundaries */
++    address &= ~(L2_LINESIZE-1);
++
++    /* Loop over the entire range which shall be purged from the caches */
++    pos = 0;
++    while (pos < count)
++    {
++      /* Get the page table information so we can calculate the physical
++       * address. This is only necessary when moving to a new page.
++       */
++      if (pos==0 || (address+pos)%PAGE_SIZE==0)
++      {
++        /* Enable interrupts for the address lookup in order to handle
++         * potential faults and errors.
++         */
++        local_irq_restore(flags);
++
++        pgd = pgd_offset(mm, address);
++        if (pgd_none(*pgd) ) return -EADDRNOTAVAIL;
++        pud = pud_offset(pgd, address);
++        if (pud_none(*pud) ) return -EADDRNOTAVAIL;
++        pmd = pmd_offset(pud, address);
++        if (pmd_none(*pmd) ) return -EADDRNOTAVAIL;
++        pte = pte_offset_map(pmd, address);
++              if (pte_none(*pte) )
++        {
++          pte_unmap(pte);
++          return -EADDRNOTAVAIL;
++        }
++        physAddress = pte_val(*pte);
++        pte_unmap(pte);
++
++        /* Disable interrupts again while purging the data from the cache */
++        local_irq_save(flags);
++      }
++
++      /* Determine the physical address by taking the MSBs from the PTE
++       * and the offset within the page from the virtual space address.
++       */
++      physAddress &= PAGE_MASK;
++      physAddress += ((address+pos) & ~PAGE_MASK);
++
++      sccdcm_purgeSet((physAddress % L2_WBSTRIDE) + purgebase);
++
++      /* We only have to read once per cacheline */
++      pos += L2_LINESIZE;
++    }
++  }
++
++
++  /* Enable normal operation again */
++  local_irq_restore(flags);
++
++  return 0;
++}
++
++
++
++static struct miscdevice sccncm_dev = {
++	.minor = MISC_DYNAMIC_MINOR,
++	.name = "rckncm",
++	.fops = &sccncm_fops,
++};
++
++static struct miscdevice sccmpb_dev = {
++	.minor = MISC_DYNAMIC_MINOR,
++	.name = "rckmpb",
++	.fops = &sccmpb_fops,
++};
++
++static struct miscdevice sccdcm_dev = {
++	.minor = MISC_DYNAMIC_MINOR,
++	.name = "rckdcm",
++	.fops = &sccdcm_fops,
++};
++
++/* module initialization - called at module load time */
++static int __init sccmem_init(void) {
++  int ret = 0;
++
++  PRINTD(KERN_INFO "Starting up SCC memory driver...\n");
++  /* This driver does only work in a bare-metal environment */
++  if (!scc_bare_metal()) {
++    printk(KERN_INFO "sccmem: startup in non-SCC or paravirtualized environment.\n");
++    return -EINVAL;
++  }
++
++  ret = misc_register(&sccncm_dev);
++  if (ret != 0) {
++    printk(KERN_ERR "sccmem_init: could not register sccncm device. err = %d\n",
++	ret);
++    goto out;
++  }
++
++  ret = misc_register(&sccmpb_dev);
++  if (ret != 0) {
++    printk(KERN_ERR "sccmem_init: could not register sccmpb device. err = %d\n",
++	ret);
++    goto out_dereg_ncm;
++  }
++
++  ret = misc_register(&sccdcm_dev);
++  if (ret != 0) {
++    printk(KERN_ERR "sccmem_init: could not register sccdcm device. err = %d\n",
++	ret);
++    goto out_dereg_mpb;
++  }
++
++  /* Make a memory mapping for invalid MPB data to flush the L2 cache with,
++     this region starts at one L2 size beyond the MPB */
++  OWN_MPB_vaddr = (size_t) ioremap_prot(OWN_MPB + L2_CAPACITY, L2_CAPACITY * 2, 0);
++  OWN_MPB_offset = 0;
++
++  if(!OWN_MPB_vaddr)
++    goto out_dereg_dcm;
++
++  printk(KERN_INFO "sccmem_init(): Mapped MPB at %x for flushing to %x\n", (OWN_MPB + MPBSIZE), OWN_MPB_vaddr);
++
++  return 0;
++
++out_dereg_dcm:
++  misc_deregister(&sccdcm_dev);
++out_dereg_mpb:
++  misc_deregister(&sccmpb_dev);
++out_dereg_ncm:
++  misc_deregister(&sccncm_dev);
++out:
++  return ret;
++}
++
++/* module unload */
++static void __exit sccmem_exit(void)
++{
++  PRINTD(KERN_INFO "sccmem_init(): Shutting down SCC memory driver...\n");
++
++  /* remove the misc devices */
++  misc_deregister(&sccncm_dev);
++  misc_deregister(&sccmpb_dev);
++  misc_deregister(&sccdcm_dev);
++
++  /* Unmap invalid MPB memory used by L2 flush */
++  iounmap((void*)OWN_MPB_vaddr);
++}
++
++/* Perform write-back/invalidate for all cachelines holding the specified pfn */
++void scc_cop_wbinv_pfn(pfn_t pfn)
++{
++	unsigned long purgebase, physAddress, offset;
++	unsigned long flags;
++
++	/* First disable interrupts to be sure nobody else accesses the cache
++	 * in parallel and messes up the LRU state bits. */
++	local_irq_save(flags);
++
++	/* Flip-flop between two parts of the flush area */
++	if (OWN_MPB_offset == 0) {
++		OWN_MPB_offset = L2_CAPACITY;
++	} else {
++		OWN_MPB_offset = 0;
++	}
++
++	/* Set basepointer to flush area we will use in this flush */
++	purgebase = OWN_MPB_vaddr + OWN_MPB_offset;
++
++#ifdef FLUSH_USES_WBINVD
++	/* Begin by flushing the entire L1. We don't want any stale data in it,
++	 * as the reads issued by sccdcm_purgeAddress need to go to L2. */
++	__asm__ __volatile__ ("wbinvd;\n\t");
++#endif
++
++	/* Now flush the entire pfn out of the cache. It is no longer in L1 by
++	 * definition, so all we need to do now is kick it out of L2...
++	 * Beware of race conditions here, as no other thread may access the
++	 * page afterwards or cachelines seem to reappear from nowhere. The
++	 * safest way is to unmap all page table entries referring to the page.
++	 * Alternatively, just disable interrupts around the current method. */
++	physAddress = pfn << PAGE_SHIFT;
++
++	for (offset = 0; offset < (1 << PAGE_SHIFT); offset += L2_LINESIZE) {
++		sccdcm_purgeSet(purgebase + ((physAddress + offset) % L2_WBSTRIDE));
++	}
++
++	/* Re-enable interrupts */
++	local_irq_restore(flags);
++}
++EXPORT_SYMBOL(scc_cop_wbinv_pfn);
++
++module_init(sccmem_init);
++module_exit(sccmem_exit);
++MODULE_DESCRIPTION("SCC system memory driver...");
++MODULE_AUTHOR("Michael Riepen <michael.riepen@intel.com>");
++
+diff -urN linux-3.1.4/drivers/char/sccperf.c linux-3.1.4-scc/drivers/char/sccperf.c
+--- linux-3.1.4/drivers/char/sccperf.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/char/sccperf.c	2011-12-20 15:27:07.578352779 +0100
+@@ -0,0 +1,170 @@
++/*
++ *  linux/drivers/scc/sccperf.c
++ *
++ * SCC performance meter driver, based on fs/proc/stat.c and the
++ * modified CPUUTIL program distributed as part of SCC Linux.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel_stat.h>
++#include <linux/time.h>
++#include <asm/cputime.h>
++#include <asm/io.h>
++#include <linux/sccsys.h>
++
++#ifndef arch_irq_stat_cpu
++#define arch_irq_stat_cpu(cpu) 0
++#endif
++#ifndef arch_irq_stat
++#define arch_irq_stat() 0
++#endif
++#ifndef arch_idle_time
++#define arch_idle_time(cpu) 0
++#endif
++
++static struct timer_list sccperf_timer;
++static volatile char* loadRegs = NULL;
++
++/* Timer callback. This routine calculates CPU utilization by reading kernel
++ * tick counters directly, then writes the result into shared memory where the
++ * MCPC can read it.
++ *
++ * Code to read the timer ticks has been copied from the proc filesystem driver
++ * (/fs/proc/stat.c!show_stat). The calculation of CPU utilization is based on
++ * the modified CPUUTIL program distributed as part of SCC Linux by Intel.
++ */
++static void sccperf_timer_function(unsigned long data)
++{
++	static cputime64_t last_user, last_nice, last_system, last_idle;
++	static cputime64_t last_iowait, last_irq, last_softirq, last_steal;
++	static cputime64_t last_guest, last_guest_nice;
++	static int first_callback = 1;
++
++	if (!loadRegs) {
++		printk(KERN_ERR "sccmem_cpuutil: unable to map SHM_X0_Y0\n");
++	} else {
++		int i;
++
++		/* Get ticks, just like /fs/proc/stat.c */
++		cputime64_t user, nice, system, idle, iowait, irq, softirq, steal;
++		cputime64_t guest, guest_nice;
++
++		user = nice = system = idle = iowait =
++			irq = softirq = steal = cputime64_zero;
++		guest = guest_nice = cputime64_zero;
++
++		for_each_possible_cpu(i) {
++			user = cputime64_add(user, kstat_cpu(i).cpustat.user);
++			nice = cputime64_add(nice, kstat_cpu(i).cpustat.nice);
++			system = cputime64_add(system, kstat_cpu(i).cpustat.system);
++			idle = cputime64_add(idle, kstat_cpu(i).cpustat.idle);
++			idle = cputime64_add(idle, arch_idle_time(i));
++			iowait = cputime64_add(iowait, kstat_cpu(i).cpustat.iowait);
++			irq = cputime64_add(irq, kstat_cpu(i).cpustat.irq);
++			softirq = cputime64_add(softirq, kstat_cpu(i).cpustat.softirq);
++			steal = cputime64_add(steal, kstat_cpu(i).cpustat.steal);
++			guest = cputime64_add(guest, kstat_cpu(i).cpustat.guest);
++			guest_nice = cputime64_add(guest_nice,
++				kstat_cpu(i).cpustat.guest_nice);
++		}
++
++		/* Calculate differences to last iteration */
++		if (!first_callback) {
++			char utilization = 0;
++
++			cputime64_t total;
++			cputime64_t diff_user, diff_nice, diff_system;
++			cputime64_t diff_idle, diff_iowait, diff_irq;
++			cputime64_t diff_softirq, diff_steal, diff_guest;
++			cputime64_t diff_guest_nice;
++
++			diff_user = cputime64_sub(user, last_user);
++			total = diff_user;
++			diff_nice = cputime64_sub(nice, last_nice);
++			total = cputime64_add(total, diff_nice);
++			diff_system = cputime64_sub(system, last_system);
++			total = cputime64_add(total, diff_system);
++			diff_idle = cputime64_sub(idle, last_idle);
++			total = cputime64_add(total, diff_idle);
++			diff_iowait = cputime64_sub(iowait, last_iowait);
++			total = cputime64_add(total, diff_iowait);
++			diff_irq = cputime64_sub(irq, last_irq);
++			total = cputime64_add(total, diff_irq);
++			diff_softirq = cputime64_sub(softirq, last_softirq);
++			total = cputime64_add(total, diff_softirq);
++			diff_steal = cputime64_sub(steal, last_steal);
++			total = cputime64_add(total, diff_steal);
++			diff_guest = cputime64_sub(guest, last_guest);
++			total = cputime64_add(total, diff_guest);
++			diff_guest_nice = cputime64_sub(guest_nice, last_guest_nice);
++			total = cputime64_add(total, diff_guest_nice);
++
++			/* Calculate local CPU utilization */
++			if ((unsigned long)total == 0) {
++				utilization = -1;
++			} else {
++				/* Division of unsigned long long seems not be
++				 * available, so unsigned long is the best we
++				 * can use for this. If the timer period is not
++				 * too long, this should work...
++				 */
++				utilization = (char)((unsigned long)(
++					diff_user + diff_nice + diff_system
++					) * 100 / (unsigned long)total);
++			}
++
++			*(loadRegs + sccsys_get_pid()) = utilization;
++		}
++
++		/* Save current values for next iteration */
++		last_user = user;
++		last_nice = nice;
++		last_system = system;
++		last_idle = idle;
++		last_iowait = iowait;
++		last_irq = irq;
++		last_softirq = softirq;
++		last_steal = steal;
++		last_guest = guest;
++		last_guest_nice = guest_nice;
++		first_callback = 0;
++	}
++
++	mod_timer(&sccperf_timer, jiffies + HZ);
++}
++
++/* module initialization - called at module load time */
++static int __init sccperf_init(void) {
++	/* This driver does only work in a bare-metal environment */
++	if (!scc_bare_metal()) {
++		printk(KERN_INFO "sccperf: startup in non-SCC or paravirtualized environment.\n");
++		return -EINVAL;
++	}
++
++	/* Map shared memory section belonging to the performance meter */
++	loadRegs = ioremap_nocache(/*SHM_X0_Y0*/ 0x80000000 + 0x900, 0x1000);
++	if (!loadRegs) {
++		printk(KERN_ERR "sccperf_init: Could not map shared memory section\n");
++		return -ENOMEM;
++	}
++
++	/* Start polling timer */
++	init_timer(&sccperf_timer);
++	sccperf_timer.function = sccperf_timer_function;
++	mod_timer(&sccperf_timer, jiffies + HZ);
++
++	return 0;
++}
++
++/* module unload */
++static void __exit sccperf_exit(void)
++{
++	del_timer_sync(&sccperf_timer);
++	iounmap(loadRegs);
++}
++
++module_init(sccperf_init);
++module_exit(sccperf_exit);
++MODULE_DESCRIPTION("SCC performance meter driver...");
++MODULE_AUTHOR("Jan-Arne Sobania <jan-arne.sobania@hpi.uni-potsdam.de");
++
+diff -urN linux-3.1.4/drivers/char/sccproc/base.c linux-3.1.4-scc/drivers/char/sccproc/base.c
+--- linux-3.1.4/drivers/char/sccproc/base.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/char/sccproc/base.c	2011-12-20 15:27:07.578352779 +0100
+@@ -0,0 +1,100 @@
++/*
++ *  linux/drivers/char/sccproc/base.c
++ *
++ *  proc filesystem extension for SCC hardware
++ */
++
++#include "sccproc.h"
++
++/* Root directory for SCC /proc entries. /proc/scc/ */
++struct proc_dir_entry* sccproc_root_dir;
++static struct proc_dir_entry* sccproc_pid_entry;
++static struct proc_dir_entry* sccproc_tileid_entry;
++
++/* Get root directory SCC /proc entries: /proc/scc/ */
++struct proc_dir_entry* sccproc_get_root_dir(void)
++{
++	return sccproc_root_dir;
++}
++EXPORT_SYMBOL(sccproc_get_root_dir);
++
++/* /proc/scc/pid */
++static int sccproc_pid_show(struct seq_file *m, void *v)
++{
++	int pid;
++
++	pid = sccsys_get_pid();
++
++	seq_printf(m, "%02d", pid);
++
++	return 0;
++}
++
++static int sccproc_pid_open(struct inode *inode, struct file *file)
++{
++	return single_open(file, sccproc_pid_show, NULL);
++}
++
++static const struct file_operations sccproc_pid_fops = {
++	.owner		= THIS_MODULE,
++	.open		= sccproc_pid_open,
++	.read		= seq_read,
++	.llseek		= seq_lseek,
++	.release	= single_release,
++};
++
++/* /proc/scc/[core/<pid>/]tileid */
++static int sccproc_hex_show(struct seq_file *m, void *v)
++{
++	int value = (int)m->private;
++
++	seq_printf(m, "0x%08x", value);
++
++	return 0;
++}
++
++static int sccproc_hex_open(struct inode *inode, struct file *file)
++{
++	return single_open(file, sccproc_hex_show, PDE(inode)->data);
++}
++
++const struct file_operations sccproc_hex_fops = {
++	.owner		= THIS_MODULE,
++	.open		= sccproc_hex_open,
++	.read		= seq_read,
++	.llseek		= seq_lseek,
++	.release	= single_release,
++};
++
++int sccproc_init_base(void)
++{
++	/* Create /proc/scc/ directory */
++	sccproc_root_dir = proc_mkdir("scc", NULL);
++	if (!sccproc_root_dir) {
++		printk(KERN_ERR "sccproc_init: unable to create /proc/scc/ directory.\n");
++		return -ENOMEM;
++	}
++
++	/* Create /proc/scc/pid file */
++	if (!(sccproc_pid_entry = proc_create_data("pid", S_IFREG | S_IRUGO,
++				sccproc_root_dir, &sccproc_pid_fops, NULL))) {
++		printk(KERN_ERR "sccproc_init: unable to create /proc/scc/pid file.\n");
++		return -ENOMEM;
++	}
++
++	/* Create /proc/scc/tileid file */
++	if (!(sccproc_tileid_entry = proc_create_data("tileid", S_IFREG | S_IRUGO,
++				sccproc_root_dir, &sccproc_hex_fops, (void*)sccsys_get_tileid()))) {
++		printk(KERN_ERR "sccproc_init: unable to create /proc/scc/tileid file.\n");
++		return -ENOMEM;
++	}
++
++	return 0;
++}
++
++void sccproc_cleanup_base(void)
++{
++	SCCPROC_DELETE(sccproc_pid_entry);
++	SCCPROC_DELETE(sccproc_tileid_entry);
++	SCCPROC_DELETE(sccproc_root_dir);
++}
+diff -urN linux-3.1.4/drivers/char/sccproc/core.c linux-3.1.4-scc/drivers/char/sccproc/core.c
+--- linux-3.1.4/drivers/char/sccproc/core.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/char/sccproc/core.c	2011-12-20 15:27:07.578352779 +0100
+@@ -0,0 +1,248 @@
++/*
++ *  linux/drivers/char/sccproc/core.c
++ *
++ *  proc filesystem extension for SCC hardware
++ */
++
++#include "sccproc.h"
++
++/* Root directory for SCC core entries. /proc/scc/core/ */
++static struct proc_dir_entry *sccproc_core_dir;
++
++struct sccproc_core_entry {
++	struct proc_dir_entry* core_dir;
++	struct proc_dir_entry* lutinfo;
++	struct proc_dir_entry* lut_dir;
++	struct proc_dir_entry* tileid;
++	struct proc_dir_entry* lut[256];
++};
++
++struct proc_dir_entry* sccproc_core_self_entry;
++struct sccproc_core_entry sccproc_core_entries[SCC_CORECOUNT];
++
++/* /proc/scc/core/<pid>/lutinfo */
++static void sccproc_print_lut(struct seq_file *m, scc_lut_t lut)
++{
++	int has_error = 0;
++
++#define SET_LUT_ERROR(d...)	\
++do { \
++	if (!has_error) { \
++		seq_printf(m, "    !" d); has_error = 1; \
++	} else { \
++		seq_printf(m, d); \
++	} \
++} while(0);
++
++	/* Decode LUT entry */
++	seq_printf(m, "%d_0x%x%x_%d(%s)_0x%03x",
++		lut.bypass, lut.y, lut.x, lut.subdest,
++		sccsys_subdest_names[lut.subdest], lut.address);
++
++	/* Mark common configuration errors */
++
++	/* Bypass does not work. MARC BUG #46 */
++	if (lut.bypass) SET_LUT_ERROR("B");
++
++	/* Tile coordinates: X = 0..5, Y = 0..3*/
++	if ((lut.y > 3) || (lut.x > 5))  SET_LUT_ERROR("T");
++
++	/*
++	 * CORE0+CORE1 cannot really be accessed from scc
++	 * hardware because they do not generate response packets, thus hanging
++	 * the requesting core; note that the MCPC *CAN* access these, as it can
++	 * just ignore that a response is missing.
++	 */
++
++	if ((lut.subdest == SCC_SUBDEST_CORE0) ||
++	    (lut.subdest == SCC_SUBDEST_CORE1)) SET_LUT_ERROR("C");
++
++	/* Nothing is connected to PERIN on any router */
++	if ((lut.subdest == SCC_SUBDEST_PERIN) ||
++
++	/* PERIS connects the VRC and SysIF (YX=(0,0) and (0,3), respectively) */
++	    ((lut.subdest == SCC_SUBDEST_PERIS) && !(
++		(lut.y == 0) && ((lut.x == 0) || (lut.x == 3))
++	    )) ||
++
++	/* PERIE is for memory controllers (YX=(0,5) and (2,5) only) */
++	    ((lut.subdest == SCC_SUBDEST_PERIE) && !(
++		((lut.y == 0) && (lut.x == 5)) || ((lut.y == 2) && (lut.x == 5))
++	    )) ||
++
++	/* PERIW is for memory controllers (YX=(0,0) and (2,0) only) */
++	    ((lut.subdest == SCC_SUBDEST_PERIW) && !(
++		((lut.y == 0) && (lut.x == 0)) || ((lut.y == 2) && (lut.x == 0))
++	    )) ||
++
++	/* That's it. MPB and CRB are available on all tiles. */
++	    0) SET_LUT_ERROR("S");
++
++	seq_printf(m, "\n");
++
++#undef SET_LUT_ERROR
++}
++
++static int sccproc_lutinfo_show(struct seq_file *m, void *v)
++{
++	int pid = (int)m->private;
++	unsigned int i;
++	scc_lut_t lut;
++	
++	for (i = 0; i < 256; i++) {
++		lut = sccsys_read_lut_entry(pid, i);
++
++		seq_printf(m, "0x%02x: ", i);
++		sccproc_print_lut(m, lut);
++	}
++
++	return 0;
++}
++
++static int sccproc_lutinfo_open(struct inode *inode, struct file *file)
++{
++	return single_open(file, sccproc_lutinfo_show, PDE(inode)->data);
++}
++
++static const struct file_operations sccproc_lutinfo_fops = {
++	.owner		= THIS_MODULE,
++	.open		= sccproc_lutinfo_open,
++	.read		= seq_read,
++	.llseek		= seq_lseek,
++	.release	= single_release,
++};
++
++/* /proc/scc/core/<pid>/lut/<index> */
++static int sccproc_lutentry_show(struct seq_file *m, void *v)
++{
++	int pid = ((int)m->private >> 8);
++	int i = (int)m->private & 0xFF;
++	scc_lut_t lut;
++	
++	lut = sccsys_read_lut_entry(pid, i);
++
++	sccproc_print_lut(m, lut);
++
++	return 0;
++}
++
++static int sccproc_lutentry_open(struct inode *inode, struct file *file)
++{
++	return single_open(file, sccproc_lutentry_show, PDE(inode)->data);
++}
++
++static const struct file_operations sccproc_lutentry_fops = {
++	.owner		= THIS_MODULE,
++	.open		= sccproc_lutentry_open,
++	.read		= seq_read,
++	.llseek		= seq_lseek,
++	.release	= single_release,
++};
++
++/* /proc/scc/core/ * */
++static int sccproc_create_core_entries(int core_index)
++{
++	struct sccproc_core_entry* core = &sccproc_core_entries[core_index];
++	char dname[16];
++	int i;
++
++	/* /proc/scc/core/<pid>/ */
++	snprintf(dname, sizeof(dname), "%02d", core_index);
++
++	core->core_dir = proc_mkdir(dname, sccproc_core_dir);
++	if (!core->core_dir) {
++		return -ENOMEM;
++	}
++
++	/* /proc/scc/core/<pid>/tileid */
++	core->tileid = proc_create_data("tileid", S_IFREG | S_IRUGO,
++		core->core_dir, &sccproc_hex_fops, (void*)
++		scc_pid_to_tileid(core_index));
++	if (!core->tileid) {
++		return -ENOMEM;
++	}
++
++	/* /proc/scc/core/<pid>/lutinfo */
++	core->lutinfo = proc_create_data("lutinfo", S_IFREG | S_IRUGO,
++		core->core_dir, &sccproc_lutinfo_fops, (void*)core_index);
++	if (!core->lutinfo) {
++		return -ENOMEM;
++	}
++
++	/* /proc/scc/core/<pid>/lut/ */
++	core->lut_dir = proc_mkdir("lut", core->core_dir);
++	if (!core->lut_dir) {
++		return -ENOMEM;
++	}
++
++	/* /proc/scc/core/<pid>/lut/<lut_index> */
++	for (i = 0; i < 256; i++) {
++		snprintf(dname, sizeof(dname), "%02x", i);
++		core->lut[i] = proc_create_data(dname, S_IFREG | S_IRUGO,
++			core->lut_dir, &sccproc_lutentry_fops, (void*)(
++			(core_index << 8) | i));
++		if (!core->lut[i]) {
++			return -ENOMEM;
++		}
++	}
++
++	return 0;
++}
++
++static void sccproc_delete_core_entries(int core_index)
++{
++	int i;
++	struct sccproc_core_entry* core = &sccproc_core_entries[core_index];
++
++	if (core->lut_dir != NULL) {
++		for (i = 0; i < 256; i++) {
++			SCCPROC_DELETE(core->lut[i]);
++		}
++		SCCPROC_DELETE(core->lut_dir);
++	}
++	SCCPROC_DELETE(core->lutinfo);
++	SCCPROC_DELETE(core->tileid);
++	SCCPROC_DELETE(core->core_dir);
++}
++
++int sccproc_init_core(void)
++{
++	int i;
++	char dname[16];
++
++	/* Create /proc/scc/core/ directory */
++	if (!(sccproc_core_dir = proc_mkdir("core", sccproc_root_dir))) {
++		printk(KERN_ERR "sccproc_init: unable to create /proc/scc/core directory.\n");
++		return -ENOMEM;
++	}
++
++	/* Create symlink /proc/scc/core/self  --->  [/proc/scc/core/]<pid>/ */
++	snprintf(dname, sizeof(dname), "%02d", sccsys_get_pid());
++	if (!(sccproc_core_self_entry = proc_symlink("self", sccproc_core_dir, dname))) {
++		printk(KERN_ERR "sccproc_init: unable to create /proc/scc/core/self symlink to %s.\n", dname);
++		return -ENOMEM;
++	}
++
++	/* Create per-core entries */
++	for (i = 0; i < SCC_CORECOUNT; i++) {
++		int err = sccproc_create_core_entries(i);
++
++		if (err < 0) {
++			return err;
++		}
++	}
++
++	return 0;
++}
++
++void sccproc_cleanup_core(void)
++{
++	int i;
++
++	for (i = 0; i < SCC_CORECOUNT; i++) {
++		sccproc_delete_core_entries(i);
++	}
++
++	SCCPROC_DELETE(sccproc_core_self_entry);
++	SCCPROC_DELETE(sccproc_core_dir);
++}
+diff -urN linux-3.1.4/drivers/char/sccproc/Makefile linux-3.1.4-scc/drivers/char/sccproc/Makefile
+--- linux-3.1.4/drivers/char/sccproc/Makefile	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/char/sccproc/Makefile	2011-12-20 15:27:07.578352779 +0100
+@@ -0,0 +1,9 @@
++#
++# Makefile for SCC proc filesystem extension driver
++#
++
++obj-$(CONFIG_SCCPROC)		+= sccproc.o
++
++sccproc-objs = proc.o base.o core.o net.o
++
++$(sccproc-objs) : sccproc.h
+diff -urN linux-3.1.4/drivers/char/sccproc/net.c linux-3.1.4-scc/drivers/char/sccproc/net.c
+--- linux-3.1.4/drivers/char/sccproc/net.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/char/sccproc/net.c	2011-12-20 15:27:07.578352779 +0100
+@@ -0,0 +1,254 @@
++/*
++ *  linux/drivers/char/sccproc/net.c
++ *
++ *  proc filesystem extension for SCC hardware
++ */
++
++#include "sccproc.h"
++
++/* /proc/scc/net/emac<idx>/ * */
++static struct proc_dir_entry* sccproc_net_dir;
++static struct proc_dir_entry* sccproc_base_ip_entry;
++static struct proc_dir_entry* sccproc_host_entry;
++static struct proc_dir_entry* sccproc_gw_entry;
++static struct proc_dir_entry* sccproc_emac_ports_entry;
++
++struct sccproc_emac_entry {
++	struct proc_dir_entry* net_dir;
++	struct proc_dir_entry* stat_entry;
++};
++
++static struct sccproc_emac_entry sccproc_emac_entries[4];
++
++/* /proc/scc/net/[base_ip|host|gw] */
++static int sccproc_ip_show(struct seq_file *m, void *v)
++{
++	unsigned ip = (unsigned)m->private;
++
++	seq_printf(m, "%d.%d.%d.%d", (ip >> 24) & 0xFF, (ip >> 16) & 0xFF,
++		(ip >> 8) & 0xFF, ip & 0xFF);
++
++	return 0;
++}
++
++static int sccproc_ip_open(struct inode *inode, struct file *file)
++{
++	return single_open(file, sccproc_ip_show, PDE(inode)->data);
++}
++
++static const struct file_operations sccproc_ip_fops = {
++	.owner		= THIS_MODULE,
++	.open		= sccproc_ip_open,
++	.read		= seq_read,
++	.llseek		= seq_lseek,
++	.release	= single_release,
++};
++
++/* EMAC statistic names, copied from emactool.c */
++static const char *emac_stat_name[46]= {
++	"TRBYTE",
++	"REBYTE",
++	"UFREC",
++	"FRFRREC",
++	"64BREC",
++	"127BREC",
++	"255BREC",
++	"511BREC",
++	"1023BREC",
++	"MAXBREC",
++	"OVFROK",
++	"64BTRA",
++	"127BTRA",
++	"255BTRA",
++	"511BTRA",
++	"1023BTRA",
++	"MAXBTRA",
++	"OVSZTX",
++	"FRRXOK",
++	"FRCHERR",
++	"BCFRRXOK",
++	"MCFRRXOK",
++	"CTFRRXOK",
++	"LGOUTRG",
++	"VLFRRXOK",
++	"PFFRRXOK",
++	"CTRRXBAD",
++	"LGOUTRG",
++	"VLFFRXOK",
++	"PFRRXOK",
++	"CTRRXBAD",
++	"FRTRANOK",
++	"BCFRTXOK",
++	"MCFRTXOK",
++	"UNDERR",
++	"CTFRTXOK",
++	"VLFRTXOK",
++	"PSFRTXOK",
++	"SGLCOLFR",
++	"MLTCOLFR",
++	"DEFTRANS",
++	"LATCOLL",
++	"EXCOLL",
++	"FRWEXCD",
++	"FRRXAERR",
++	"UNDCOUNT"
++};
++
++/* Base of EMAC statistics in GRB, copied from emactool.h */
++#define STAT0_TRBYTE							0x00003400
++#define STAT1_TRBYTE							0x00004400
++#define STAT2_TRBYTE							0x00005400
++#define STAT3_TRBYTE							0x00006400
++
++static int sccproc_emac_stat_show(struct seq_file *m, void *v)
++{
++	int emac_index = (int)m->private, i;
++	unsigned base;
++
++	switch (emac_index) {
++	case 0:
++		base = STAT0_TRBYTE;
++		break;
++	case 1:
++		base = STAT1_TRBYTE;
++		break;
++	case 2:
++		base = STAT2_TRBYTE;
++		break;
++	case 3:
++		base = STAT3_TRBYTE;
++		break;
++	default:
++		seq_printf(m, "Unexpected call for emac%d\n", emac_index);
++		return 0;
++	}
++
++	seq_printf(m, "Ethernet statistic for emac%d: \n", emac_index);
++	seq_printf(m, "----------------------------\n");
++
++	for (i = 0; i < 46; i++) {
++		unsigned value = sccsys_read_grb_entry(base + i * 8);
++		seq_printf(m, "%8.8s (0x%4x)  - %10d\n", emac_stat_name[i], base + i * 8, value);
++	}
++	seq_printf(m, "----------------------------\n");
++
++	return 0;
++}
++
++static int sccproc_emac_stat_open(struct inode *inode, struct file *file)
++{
++	return single_open(file, sccproc_emac_stat_show, PDE(inode)->data);
++}
++
++static const struct file_operations sccproc_emac_stat_fops = {
++	.owner		= THIS_MODULE,
++	.open		= sccproc_emac_stat_open,
++	.read		= seq_read,
++	.llseek		= seq_lseek,
++	.release	= single_release,
++};
++
++static int sccproc_create_emac_entries(int emac_index)
++{
++	struct sccproc_emac_entry* net = &sccproc_emac_entries[emac_index];
++	char dname[16];
++
++	/* Make sure we only activate EMACs that are present in the bitstream. */
++	if (!((sccsys_read_grb_entry(SCCGRB_FPGA_CONFIG) >> 9) &
++		(1 << emac_index))) {
++		memset(net, 0, sizeof(struct sccproc_emac_entry));
++		return 0;
++	}
++
++	/* /proc/scc/net/emac<idx>/ */
++	snprintf(dname, sizeof(dname), "emac%d", emac_index);
++
++	net->net_dir = proc_mkdir(dname, sccproc_net_dir);
++	if (!net->net_dir) {
++		return -ENOMEM;
++	}
++
++	/* /proc/scc/net/emac<idx>/stat */
++	net->stat_entry = proc_create_data("stat", S_IFREG | S_IRUGO,
++		net->net_dir, &sccproc_emac_stat_fops, (void*)emac_index);
++	if (!net->stat_entry) {
++		return -ENOMEM;
++	}
++
++	return 0;
++}
++
++static void sccproc_delete_emac_entries(int emac_index)
++{
++	struct sccproc_emac_entry* net = &sccproc_emac_entries[emac_index];
++
++	SCCPROC_DELETE(net->stat_entry);
++	SCCPROC_DELETE(net->net_dir);
++}
++
++int sccproc_init_net(void)
++{
++	int i;
++
++	/* Create /proc/scc/net/ directory */
++	if (!(sccproc_net_dir = proc_mkdir("net", sccproc_root_dir))) {
++		printk(KERN_ERR "sccproc_init: unable to create /proc/scc/net directory.\n");
++		return -ENOMEM;
++	}
++
++	/* Create /proc/scc/net/base_ip file */
++	if (!(sccproc_base_ip_entry = proc_create_data("base_ip", S_IFREG | S_IRUGO,
++				sccproc_net_dir, &sccproc_ip_fops, (void*)sccsys_read_grb_entry(SCCGRB_EMAC_IP_START)))) {
++		printk(KERN_ERR "sccproc_init: unable to create /proc/scc/net/base_ip file.\n");
++		return -ENOMEM;
++	}
++
++	/* Create /proc/scc/net/gw file */
++	if (!(sccproc_gw_entry = proc_create_data("gw", S_IFREG | S_IRUGO,
++				sccproc_net_dir, &sccproc_ip_fops, (void*)sccsys_read_grb_entry(SCCGRB_EMAC_GW_IP)))) {
++		printk(KERN_ERR "sccproc_init: unable to create /proc/scc/net/gw file.\n");
++		return -ENOMEM;
++	}
++
++	/* Create /proc/scc/net/host file */
++	if (!(sccproc_host_entry = proc_create_data("host", S_IFREG | S_IRUGO,
++				sccproc_net_dir, &sccproc_ip_fops, (void*)sccsys_read_grb_entry(SCCGRB_EMAC_HOST_IP)))) {
++		printk(KERN_ERR "sccproc_init: unable to create /proc/scc/net/host file.\n");
++		return -ENOMEM;
++	}
++
++	/* Create /proc/scc/net/emac_ports file */
++	if (!(sccproc_emac_ports_entry = proc_create_data("emac_ports", S_IFREG | S_IRUGO,
++				sccproc_net_dir, &sccproc_hex_fops, (void*)((sccsys_read_grb_entry(SCCGRB_FPGA_CONFIG) >> 16) >> 9 & 0xF)))) {
++		printk(KERN_ERR "sccproc_init: unable to create /proc/scc/net/emac_ports file.\n");
++		return -ENOMEM;
++	}
++
++	/* Create individual emac entries */
++	for (i = 0; i < 4; i++) {
++		int err = sccproc_create_emac_entries(i);
++
++		if (err < 0) {
++			return err;
++		}
++	}
++
++	return 0;
++}
++
++void sccproc_cleanup_net(void)
++{
++	int i;
++
++	/* Delete entries from /proc/scc/net directory */
++	for (i = 0; i < 4; i++) {
++		sccproc_delete_emac_entries(i);
++	}
++
++	SCCPROC_DELETE(sccproc_base_ip_entry);
++	SCCPROC_DELETE(sccproc_host_entry);
++	SCCPROC_DELETE(sccproc_gw_entry);
++	SCCPROC_DELETE(sccproc_emac_ports_entry);
++
++	SCCPROC_DELETE(sccproc_net_dir);
++}
+diff -urN linux-3.1.4/drivers/char/sccproc/proc.c linux-3.1.4-scc/drivers/char/sccproc/proc.c
+--- linux-3.1.4/drivers/char/sccproc/proc.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/char/sccproc/proc.c	2011-12-20 15:27:07.588922327 +0100
+@@ -0,0 +1,62 @@
++/*
++ *  linux/drivers/char/sccproc/proc.c
++ *
++ *  proc filesystem extension for SCC hardware
++ */
++
++#include "sccproc.h"
++
++/* cleanup /proc/scc directory */
++static void sccproc_cleanup(void)
++{
++	sccproc_cleanup_core();
++	sccproc_cleanup_net();
++	sccproc_cleanup_base();
++}
++
++/* module initialization - called at module load time */
++static int __init sccproc_init(void)
++{
++	int err;
++
++	/* This driver does only work in a bare-metal environment */
++	if (!scc_bare_metal()) {
++		printk(KERN_INFO "sccproc: startup in non-SCC or paravirtualized environment.\n");
++		return -EINVAL;
++	}
++
++	/* Init /proc/scc/ */
++	err = sccproc_init_base();
++	if (err < 0) {
++		sccproc_cleanup();
++		return err;
++	}
++
++	/* Init /proc/scc/core/ */
++	err = sccproc_init_core();
++	if (err < 0) {
++		sccproc_cleanup();
++		return err;
++	}
++
++	/* Init /proc/scc/net/ */
++	err = sccproc_init_net();
++	if (err < 0) {
++		sccproc_cleanup();
++		return err;
++	}
++
++	return 0;
++}
++
++/* module unload */
++static void __exit sccproc_exit(void)
++{
++	sccproc_cleanup();
++}
++
++module_init(sccproc_init);
++module_exit(sccproc_exit);
++MODULE_DESCRIPTION("SCC procfs driver");
++MODULE_AUTHOR("Jan-Arne Sobania <jan-arne.sobania@hpi.uni-potsdam.de>");
++
+diff -urN linux-3.1.4/drivers/char/sccproc/sccproc.h linux-3.1.4-scc/drivers/char/sccproc/sccproc.h
+--- linux-3.1.4/drivers/char/sccproc/sccproc.h	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/char/sccproc/sccproc.h	2011-12-20 15:27:07.588922327 +0100
+@@ -0,0 +1,22 @@
++#include <linux/module.h>
++#include <linux/proc_fs.h>
++#include <linux/seq_file.h>
++#include <linux/sccsys.h>
++
++extern const struct file_operations sccproc_hex_fops;
++extern struct proc_dir_entry* sccproc_root_dir;
++
++#define SCCPROC_DELETE(entry) \
++	if (entry) { \
++		remove_proc_entry((entry)->name, (entry)->parent); \
++		entry = NULL; \
++	}
++
++extern int sccproc_init_base(void);
++extern void sccproc_cleanup_base(void);
++
++extern int sccproc_init_core(void);
++extern void sccproc_cleanup_core(void);
++
++extern int sccproc_init_net(void);
++extern void sccproc_cleanup_net(void);
+diff -urN linux-3.1.4/drivers/char/sccproc.h linux-3.1.4-scc/drivers/char/sccproc.h
+--- linux-3.1.4/drivers/char/sccproc.h	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/char/sccproc.h	2011-12-20 15:27:07.588922327 +0100
+@@ -0,0 +1,3 @@
++/* Get root directory of SCC /proc entries: /proc/scc/ */
++extern struct proc_dir_entry* sccproc_get_root_dir(void);
++
+diff -urN linux-3.1.4/drivers/cpufreq/Kconfig.x86 linux-3.1.4-scc/drivers/cpufreq/Kconfig.x86
+--- linux-3.1.4/drivers/cpufreq/Kconfig.x86	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/drivers/cpufreq/Kconfig.x86	2011-12-20 15:27:07.588922327 +0100
+@@ -201,6 +201,12 @@
+ 
+ 	  If in doubt, say N.
+ 
++config X86_SCCFREQ
++	tristate "SCC Freq"
++	depends on X86_SCC
++	help
++	  This adds the CPUFreq driver for Single-chip cloud computer.
++
+ config X86_LONGRUN
+ 	tristate "Transmeta LongRun"
+ 	depends on X86_32
+diff -urN linux-3.1.4/drivers/cpufreq/Makefile linux-3.1.4-scc/drivers/cpufreq/Makefile
+--- linux-3.1.4/drivers/cpufreq/Makefile	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/drivers/cpufreq/Makefile	2011-12-20 15:27:07.588922327 +0100
+@@ -35,6 +35,7 @@
+ obj-$(CONFIG_X86_SPEEDSTEP_SMI)		+= speedstep-smi.o
+ obj-$(CONFIG_X86_SPEEDSTEP_CENTRINO)	+= speedstep-centrino.o
+ obj-$(CONFIG_X86_P4_CLOCKMOD)		+= p4-clockmod.o
++obj-$(CONFIG_X86_SCCFREQ)		+= sccfreq.o
+ obj-$(CONFIG_X86_CPUFREQ_NFORCE2)	+= cpufreq-nforce2.o
+ 
+ ##################################################################################
+diff -urN linux-3.1.4/drivers/cpufreq/sccfreq.c linux-3.1.4-scc/drivers/cpufreq/sccfreq.c
+--- linux-3.1.4/drivers/cpufreq/sccfreq.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/cpufreq/sccfreq.c	2011-12-20 15:27:07.588922327 +0100
+@@ -0,0 +1,244 @@
++/*******************************************************************************
++
++  This program is free software; you can redistribute it and/or modify it
++  under the terms of the GNU General Public License as published by the Free
++  Software Foundation; either version 2 of the License, or (at your option)
++  any later version.
++
++  This program is distributed in the hope that it will be useful, but WITHOUT
++  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
++  more details.
++
++  You should have received a copy of the GNU General Public License along with
++  this program; if not, write to the Free Software Foundation, Inc., 59
++  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
++
++  The full GNU General Public License is included in this distribution in the
++  file called LICENSE.
++
++  Contact Information:
++  Jan-Michael Brummer <jan-michael.brummer@intel.com>
++  Intel Braunschweig
++
++*******************************************************************************/
++
++#include <linux/version.h>
++
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/pci.h>
++#include <linux/init.h>
++
++#include <linux/cpufreq.h>
++#include <linux/sccsys.h>
++
++#include <asm/io.h>
++
++#define MODVERSION	"0.2b"
++
++/** Frequency mapping table */
++/* The index member encodes the tile clock divisor for GCBCFG */
++static struct cpufreq_frequency_table scc_freq_table[] = {
++	{0x01, 800000},
++	{0x02, 533000},
++	{0x03, 400000},
++	{0x04, 320000},
++	{0x05, 266000},
++	{0x06, 228000},
++	{0x07, 200000},
++	{0x08, 178000},
++	{0x09, 160000},
++	{0x0A, 145000},
++	{0x0B, 133000},
++	{0x0C, 123000},
++	{0x0D, 114000},
++	{0x0E, 106000},
++	{0x0F, 100000},
++	{0, CPUFREQ_TABLE_END},
++};
++
++/**
++ * \brief Get current cpu frequency
++ * \param cpu selected cpu (0)
++ * \return frequency in khz
++ */
++static unsigned int scc_freq_get_cpu_frequency(unsigned int cpu) {
++	unsigned int fastclock = 0;
++	unsigned int divider = 0;
++	unsigned int freq = 0;
++
++	/* Get fastclock */
++	fastclock = sccsys_read_grb_fastclock();
++
++	/* Get core divider */
++	divider = sccsys_read_gcbcfg(sccsys_get_pid()).divider;
++	divider++;
++
++	/* Fallback to 533MHz */
++	if (!divider || !fastclock) {
++		freq = 533000;
++	} else {
++		/* Calculate new frequency */
++		freq = fastclock / divider * 1000;
++	}
++
++	/* return frequency */
++	return freq;
++}
++
++/**
++ * \brief Set current cpu state
++ * \param state transition state
++ */
++static void scc_freq_set_cpu_state(unsigned int state) {
++	struct cpufreq_freqs freqs;
++	scc_gckcfg_t gcbcfg;
++	unsigned int divider;
++
++	/* Save old data and setup new values */
++	freqs.old = scc_freq_get_cpu_frequency(0);
++	freqs.new = scc_freq_table[state].frequency;
++	freqs.cpu = 0;
++
++	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
++
++	printk(KERN_INFO "attempting to set frequency to %i kHz\n",
++		scc_freq_table[state].frequency);
++
++	local_irq_disable();
++
++	/* Calculate new gcbcfg value and set it */
++	gcbcfg = sccsys_read_gcbcfg(sccsys_get_pid());
++
++	/* Get new divider value from frequency table. If it is out of range
++	 * OR indicates a tile clock of 1600MHz, we force it down to 800MHz,
++	 * although that should never happen unless we have serious memory
++	 * corruption. */
++	divider = (unsigned int)scc_freq_table[state].index;
++	if (!divider || divider > 15) {
++		divider = 2;
++	}
++
++	gcbcfg.divider = divider;
++	gcbcfg.router = 7 * (divider + 1);
++
++	sccsys_write_gcbcfg(sccsys_get_pid(), gcbcfg);
++
++	local_irq_enable();
++
++	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
++}
++
++/**
++ * \brief Verify selected frequency
++ * \param policy pointer to cpufreq policy
++ * \return result
++ */
++static int scc_freq_verify(struct cpufreq_policy *policy) {
++	return cpufreq_frequency_table_verify(policy, &scc_freq_table[0]);
++}
++
++/**
++ * \brief Get frequency target
++ * \param policy pointer to cpufreq policy
++ * \param target_freq target frequency
++ * \param relation relation
++ * \return 0 on success, otherwise error
++ */
++static int scc_freq_target(struct cpufreq_policy *policy, unsigned int target_freq, unsigned int relation) {
++	unsigned int newstate = 0;
++
++	/* On fault return -EINVAL */
++	if (cpufreq_frequency_table_target(policy, scc_freq_table, target_freq, relation, &newstate)) {
++		return -EINVAL;
++	}
++
++	scc_freq_set_cpu_state(newstate);
++
++	return 0;
++}
++
++/**
++ * \brief Initialize cpu frequency policy
++ * \param policy pointer to cpufreq policy
++ * \return 0 on success, otherwise error
++ */
++static int scc_freq_cpu_init(struct cpufreq_policy *policy) {
++	struct cpuinfo_x86 *c = &cpu_data(0);
++	int result;
++
++	if (c->x86_vendor != 0 || c->x86 != 5 || c->x86_model != 2) {
++		return -EINVAL;
++	}
++
++	/* cpuinfo and default policy values */
++	policy->cpuinfo.transition_latency = 10000;
++	policy->cur = scc_freq_get_cpu_frequency(0);
++
++	result = cpufreq_frequency_table_cpuinfo(policy, scc_freq_table);
++	if (result) {
++		return result;
++	}
++
++	cpufreq_frequency_table_get_attr(scc_freq_table, policy->cpu);
++
++	return 0;
++}
++
++/**
++ * \brief Exit cpu frequency policy
++ * \param policy pointer to cpufreq policy
++ * \return 0
++ */
++static int scc_freq_cpu_exit(struct cpufreq_policy *policy) {
++	cpufreq_frequency_table_put_attr(policy->cpu);
++	return 0;
++}
++
++/** Frequency attribute table */
++static struct freq_attr *scc_freq_attr[] = {
++	&cpufreq_freq_attr_scaling_available_freqs,
++	NULL,
++};
++
++/** CPU Frequency driver structure */
++static struct cpufreq_driver scc_freq_driver = {
++	.get = scc_freq_get_cpu_frequency,
++	.verify = scc_freq_verify,
++	.target = scc_freq_target,
++	.init = scc_freq_cpu_init,
++	.exit = scc_freq_cpu_exit,
++	.name = "scc_freq",
++	.owner = THIS_MODULE,
++	.attr = scc_freq_attr,
++};
++
++/**
++ * \brief Initialze cpu frequency module
++ * \return error code
++ */
++static int __init scc_freq_init(void) {
++	struct cpuinfo_x86 *c = &cpu_data(0);
++
++	if (c->x86_vendor != 0 || c->x86 != 5 || c->x86_model != 2) {
++		return -EINVAL;
++	}
++
++	return cpufreq_register_driver(&scc_freq_driver);
++}
++
++/**
++ * \brief Exit cpu frequency module
++ */
++static void __exit scc_freq_exit(void) {
++	cpufreq_unregister_driver(&scc_freq_driver);
++}
++
++module_init(scc_freq_init);
++module_exit(scc_freq_exit);
++
++MODULE_LICENSE("GPL");
++MODULE_AUTHOR("Jan-Michael Brummer");
++MODULE_VERSION(MODVERSION);
++MODULE_DESCRIPTION("scc cpufreq driver");
+diff -urN linux-3.1.4/drivers/net/Kconfig linux-3.1.4-scc/drivers/net/Kconfig
+--- linux-3.1.4/drivers/net/Kconfig	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/drivers/net/Kconfig	2011-12-20 15:27:07.588922327 +0100
+@@ -2044,6 +2044,51 @@
+ 
+ if NETDEV_1000
+ 
++choice
++	prompt "SCC Message Buffer Driver"
++	default SCCMB
++	depends on SCCSYS && NET
++	---help---
++	  Select which implementation of the message buffer driver is used.
++
++config SCCMB
++	bool "Original"
++	---help---
++	  Default SCC driver for the on-die network via the message
++	  buffers.
++
++config SCCMBX
++	bool "Extended"
++	---help---
++	  Extended message buffer driver that provides a side-channel for
++	  kernel components.
++
++endchoice
++
++config SCCMBX_DUMP_NONNET_PACKETS
++	bool "Enable packet tracing for on-die non-NET packets"
++	default n
++	depends on SCCMBX
++
++config SCCPC
++	tristate "SCC-HostPC NIC"
++	default n
++	depends on SCCSYS && NET
++	---help---
++	  SCC driver for the MCPC network via the System Interface FPGA.
++
++config SCCPC_DUMP_PACKETS
++	bool "Enable packet tracing for MCPC network"
++	default n
++	depends on SCCPC
++
++config SCCEMAC
++	tristate "SCC EMAC NIC"
++	default n
++	depends on SCCSYS && NET
++	---help---
++	  SCC driver for the off-die network via Ethernet ports.
++
+ config ACENIC
+ 	tristate "Alteon AceNIC/3Com 3C985/NetGear GA620 Gigabit support"
+ 	depends on PCI
+diff -urN linux-3.1.4/drivers/net/Makefile linux-3.1.4-scc/drivers/net/Makefile
+--- linux-3.1.4/drivers/net/Makefile	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/drivers/net/Makefile	2011-12-20 15:27:07.609021371 +0100
+@@ -6,6 +6,11 @@
+ obj-$(CONFIG_MDIO) += mdio.o
+ obj-$(CONFIG_PHYLIB) += phy/
+ 
++obj-$(CONFIG_SCCMB)		+= sccmb.o
++obj-$(CONFIG_SCCMBX)		+= sccmbx.o
++obj-$(CONFIG_SCCPC) 		+= sccpc.o
++obj-$(CONFIG_SCCEMAC)		+= sccemac.o
++
+ obj-$(CONFIG_TI_DAVINCI_EMAC) += davinci_emac.o
+ obj-$(CONFIG_TI_DAVINCI_MDIO) += davinci_mdio.o
+ obj-$(CONFIG_TI_DAVINCI_CPDMA) += davinci_cpdma.o
+diff -urN linux-3.1.4/drivers/net/sccemac.c linux-3.1.4-scc/drivers/net/sccemac.c
+--- linux-3.1.4/drivers/net/sccemac.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/net/sccemac.c	2011-12-20 15:27:07.609021371 +0100
+@@ -0,0 +1,1133 @@
++/*******************************************************************************
++
++  This program is free software; you can redistribute it and/or modify it
++  under the terms of the GNU General Public License as published by the Free
++  Software Foundation; either version 2 of the License, or (at your option)
++  any later version.
++
++  This program is distributed in the hope that it will be useful, but WITHOUT
++  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
++  more details.
++
++  You should have received a copy of the GNU General Public License along with
++  this program; if not, write to the Free Software Foundation, Inc., 59
++  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
++
++  The full GNU General Public License is included in this distribution in the
++  file called LICENSE.
++
++  Contact Information:
++  Jan-Michael Brummer <jan-michael.brummer@intel.com>
++  Intel Braunschweig
++
++*******************************************************************************/
++
++#include "sccemac.h"
++
++/* Change Log
++ * 0.3.0	01/14/2011
++ *   o ported driver to NAPI structure
++ * 0.2.1	12/08/2010
++ *   o fix possible rx packet lost
++ * 0.2.0	11/19/2010
++ *   o added irq handling
++ * 0.1.4	09/06/2010
++ *   o added fpga emac port detection
++ *   o fix rx illegal packet length bug
++ * 0.1.3	08/27/2010
++ *   o create general configuration functions
++ *   o added support for emac2 and emac3
++ * 0.1.2	08/26/2010
++ *   o fix emac1 transfer setup
++ * 0.1.1	08/19/2010
++ *   o handle more than one packet in receive
++ *   o overflow check
++ * 0.1.0	08/18/2010
++ *   o first release
++ */
++
++#define MODVERSTRING	"0.3.0"
++#define OVERFLOW_CHECK	1
++
++#define IRQ_STATUS	0xD000
++#define IRQ_MASK	0xD200
++#define IRQ_RESET	0xD400
++#define IRQ_CONFIG	0xD800
++
++/** emac0 network driver structure */
++static struct net_device *emac0_dev = NULL;
++/** emac1 network driver structure */
++static struct net_device *emac1_dev = NULL;
++/** emac2 network driver structure */
++static struct net_device *emac2_dev = NULL;
++/** emac3 network driver structure */
++static struct net_device *emac3_dev = NULL;
++
++/** optional select ethernet port */
++static int ethernet_port = EMAC0 | EMAC1 | EMAC2 | EMAC3;
++module_param(ethernet_port, int, 0644);
++MODULE_PARM_DESC(ethernet_port,
++	"Ethernet ports the driver should use (0x01=emac0, 0x02=emac1,"
++	" 0x04=emac2, 0x08=emac3)");
++
++/** debug level */
++static int debug_level = 0;
++module_param(debug_level, int, 0644);
++MODULE_PARM_DESC(debug_level, "Debug level");
++
++/** override sccKit configuration */
++static int override = 0;
++module_param(override, int, 0644);
++MODULE_PARM_DESC(override, "Override sccKit configuration");
++
++static int core0 = 0;
++
++/* grb address */
++static void* grb;
++
++/**
++ * \brief Read long from emac
++ * \param pAddr address we want to read
++ * \return value stored in address
++ */
++static int emac_readl(void *addr) {
++	int ret;
++
++	ret = readl(addr);
++	/* no error: read twice, as xilinx ip need some time... */
++	ret = readl(addr);
++
++	return ret;
++}
++
++/**
++ * \brief Write long to emac
++ * \param value entry for address
++ * \param pAddr address we want to write
++ */
++static void emac_writel(int value, void *addr) {
++	writel(value, addr);
++}
++
++static void init_xilinx_port(int emac, int base) {
++	int flow_control = 0;
++	int transmitter_addr = 0;
++	int receiver1_addr = 0;
++	int config_add = 0;
++	int add_filter_mod = 0;
++
++	transmitter_addr = emac_readl(RA(base + TRANSMITTER_ADDRESS, 0));
++	receiver1_addr = emac_readl(RA(base + RECEIVER1_ADDRESS, 0));
++
++	/* Check if IP is already configured */
++	//if (!(transmitter_addr & 0x10000000) ||
++       //    !(receiver1_addr & 0x10000000)) {
++    if (core0 == 0)
++       {
++		EPRINTK(DEBUG_INFO, "Config eMAC RX %d\n", emac);
++
++		/* Disable tx and rx flow control of eMAC */
++		EPRINTK(DEBUG_INFO, "Disabling tx/rx flow control of eMAC%d\n", emac);
++		flow_control = emac_readl(RA(base + CONFIG_FLOW_CONTROL_ADD, 0));
++
++		/* Set top 3 bits of the flow control configuration to zero,
++		 * therefore disabling tx and rx flow control
++		 */
++		flow_control &= 0x7FFFFFF;
++		emac_writel(flow_control, RA(base + CONFIG_FLOW_CONTROL_ADD, 0));
++
++		/* Sanity check */
++		flow_control = emac_readl(RA(base + CONFIG_FLOW_CONTROL_ADD, 0));
++		EPRINTK(DEBUG_INFO, "  CONFIG_FLOW_CONTROL_ADD set: 0x%x\n",
++                flow_control);
++
++		/* Setting the tx configuration bit to enable the transmitter and
++		 * set to full duplex mode.
++		 */
++		EPRINTK(DEBUG_INFO, "Setting rx configuration of eMAC%d\n", emac);
++		transmitter_addr = emac_readl(RA(base + TRANSMITTER_ADDRESS, 0));
++
++		/* Now set the relevant bits and write back into the register:
++		 * 26 (half duplex) = 0, 28 (transmit enable) = 1, 31 (reset) = 0
++		 */
++		transmitter_addr &= ~(1 << 31);
++		transmitter_addr &= ~(1 << 26);
++		transmitter_addr |= (1 << 28);
++		emac_writel(transmitter_addr, RA(base + TRANSMITTER_ADDRESS, 0));
++
++		transmitter_addr = emac_readl(RA(base + TRANSMITTER_ADDRESS, 0));
++		EPRINTK(DEBUG_INFO, "  TRANSMITTER_ADDRESS set: %x\n",
++                transmitter_addr);
++
++		/* Setting the rx configuration bit to enable the transmitter and
++		 * set to full duplex mode.
++		 */
++		EPRINTK(DEBUG_INFO, "Setting IP configuration of EMAC%d\n", emac);
++
++		/* Read the current config value from the register */
++		receiver1_addr = emac_readl(RA(base + RECEIVER1_ADDRESS, 0));
++
++		/* Now set the relevant bits and write back into the register:
++		 *  25 = 1, 26 = 0, 28 = 1, 31 = 0
++		 */
++		/* Length/Type Error Check Disable */
++		receiver1_addr |= (1 << 25);
++		/* Disable Half Duplex => Full Duplex */
++		receiver1_addr &= ~(1 << 26);
++		/* Receiver enable */
++		receiver1_addr |= (1 << 28);
++		/* Reset */
++		receiver1_addr &= ~(1 << 31);
++		emac_writel(receiver1_addr, RA(base + RECEIVER1_ADDRESS, 0));
++
++		receiver1_addr = emac_readl(RA(base + RECEIVER1_ADDRESS, 0));
++		EPRINTK(DEBUG_INFO, "  RECEIVER1_ADDRESS set: %x\n",
++                receiver1_addr);
++
++		/* Setting the speed to eMAC to 1Gb/s */
++		EPRINTK(DEBUG_INFO, "Setting speed of EMAC%d to 1Gb/s\n", emac);
++
++		/* Read the current config value from register */
++		config_add = emac_readl(RA(base + CONFIG_ADD, 0));
++
++		/* Now set the relevant bits and write back into the register:
++		 * 31 = 1, 30 = 0
++		 */
++		/* MAC Speed Configuration: 00 - 10Mbps, 01 - 100Mbps, 10 - 1Gbps */
++		config_add |= (1 << 31);
++		config_add &= ~(1 << 30);
++		emac_writel(config_add, RA(base + CONFIG_ADD, 0));
++
++		config_add = emac_readl(RA(base + CONFIG_ADD, 0));
++		EPRINTK(DEBUG_INFO, "  CONFIG_ADD set: %x\n", config_add);
++
++		/* Read the current config addr filter mode */
++		add_filter_mod = emac_readl(RA(base + ADD_FILTER_MOD, 0));
++
++		/* Not set the relevant bits and write back into the register:
++		 * 31 (promiscuous mode) = 1 not working, but thats ok!
++		 */
++		add_filter_mod |= (1 << 31);
++		emac_writel(add_filter_mod, RA(base + ADD_FILTER_MOD, 0));
++
++		add_filter_mod = emac_readl(RA(base + ADD_FILTER_MOD, 0));
++		EPRINTK(DEBUG_INFO, "  ADD_FILTER_MOD set: %x\n", add_filter_mod);
++	//} else {
++	//	EPRINTK(DEBUG_INFO, "EMAC%d already configured!\n", emac);
++	}
++}
++
++/**
++ * \brief Allocate and return clean mpb
++ * \param order order of memory pages
++ * \return new buffer
++ */
++static unsigned char *alloc_buffer(int order) {
++	struct page *page = NULL;
++	unsigned char *buffer = NULL;
++	int num = 1 << order;
++
++	/* We are using alloc_pages and change_page_attr here, as the other
++	 * functions do not allow setting our attributes (NC/PSE)
++	 */
++	page = alloc_pages(GFP_KERNEL, order);
++	buffer = page_address(page);
++
++	if (set_memory_wt_mpbt((unsigned long)buffer, 1 << order) < 0) {
++		EPRINTK(DEBUG_INFO, "Failed");
++		return NULL;
++	}
++
++	memset(buffer, 0x00, 0x20);
++	memset(buffer + 0x20, 0xDA, num * PAGE_SIZE - 0x20);
++
++	return buffer;
++}
++
++/**
++ * \brief Get mac address
++ * \param dev network device pointer
++ */
++static inline unsigned long long get_mac_address(struct net_device *dev) {
++	struct emac_priv *priv = netdev_priv(dev);
++	unsigned long long mac;
++	int mac1 = readl(RA(0x7E00, 0));
++	int mac2 = readl(RA(0x7E04, 0));
++
++	mac = (((unsigned long long)mac1) << 32) + ( unsigned long long ) mac2;
++
++	if (mac == 0x00) {
++		mac = MAC_ADDRESS;
++	}
++
++	/* Calculate mac address of core depending on selected emac device */
++	return mac + priv->device * 0x100 + priv->pid;
++}
++
++/**
++ * \brief Setup application register of selected emac port
++ * \param dev network device pointer
++ * \param pid core pid
++ * \param tile_offset tile memory offset
++ * \param pos core route
++ * \param mode contains route and destination to memory controller
++ */
++static void setup_emac(struct net_device *dev, int pid,
++                 unsigned long long tile_offset, int pos, int mode) {
++	struct emac_priv *priv = netdev_priv(dev);
++	unsigned long long addr_offset = tile_offset;
++	unsigned long long mac = 0;
++	u32 tmp = 0;
++	u16 write_offset = 0;
++	u16 read_offset = 0;
++	unsigned char core = 0;
++
++	/* store own id */
++	priv->pid = pid;
++
++	EPRINTK(DEBUG_INFO, "Initialize eMAC 0x%x (pid %d)\n", priv->device, priv->pid);
++
++	/**** Receive configuration ****/
++
++	/* Set up ring buffer space */
++	priv->rx_buffer_max = CLINE_PACKETS(BUFFER_SIZE) - 1;
++	priv->rx_buffer = alloc_buffer(BUFFER_ORDER);
++
++	/* Start address */
++	EPRINTK(DEBUG_INFO, "  RX Buffer %p (%p phys)\n", priv->rx_buffer,
++            (void*)virt_to_phys(priv->rx_buffer));
++
++	tmp = virt_to_phys(priv->rx_buffer);
++	addr_offset = tile_offset + tmp;
++	addr_offset >>= 5;
++	emac_writel(addr_offset, RA(priv->base + EMAC_RX_BUFFER_START_ADDRESS,
++                priv->pid));
++	tmp = emac_readl(RA(priv->base + EMAC_RX_BUFFER_START_ADDRESS, priv->pid));
++	EPRINTK(DEBUG_INFO, "  RX Buffer set to @%x\n", tmp);
++
++	/* Set buffer write offset */
++	write_offset = emac_readl(RA(priv->base + EMAC_RX_BUFFER_WRITE_OFFSET,
++                              priv->pid));
++	EPRINTK(DEBUG_INFO, "  RX Buffer write offset at: %d\n", write_offset);
++
++	/* Set buffer read offset to write offset */
++	emac_writel(write_offset, RA(priv->base + EMAC_RX_BUFFER_READ_OFFSET,
++                priv->pid));
++	EPRINTK(DEBUG_INFO, "  RX Buffer read offset set to: %d\n",
++            emac_readl(RA(priv->base + EMAC_RX_BUFFER_READ_OFFSET, priv->pid)));
++	priv->rx_read_offset = write_offset;
++
++	/* Size */
++	emac_writel(priv->rx_buffer_max, RA(priv->base + EMAC_RX_BUFFER_SIZE,
++                priv->pid));
++	EPRINTK(DEBUG_INFO, "  RX Size set to %d\n",
++            emac_readl(RA(priv->base + EMAC_RX_BUFFER_SIZE, priv->pid)));
++
++	/* Threshold */
++	emac_writel(0x01, RA(priv->base + EMAC_RX_BUFFER_THRESHOLD, priv->pid));
++	EPRINTK(DEBUG_INFO, "  RX Threshold set to %x\n",
++            emac_readl(RA(priv->base + EMAC_RX_BUFFER_THRESHOLD, priv->pid)));
++
++	/* Route */
++	core = pid & 1;
++	emac_writel((core << 24) | (pos << 16) | mode, RA(priv->base + EMAC_RX_MODE, priv->pid));
++	EPRINTK(DEBUG_INFO, "  RX Mode set to %x\n",
++            emac_readl(RA(priv->base + EMAC_RX_MODE, priv->pid)));
++
++	/* MAC */
++	mac = get_mac_address(dev); 
++	emac_writel(MAC_HI(mac), RA(priv->base +
++                EMAC_RX_NETWORK_PORT_MAC_ADDRESS_HI, priv->pid));
++	EPRINTK(DEBUG_INFO, "  MAC1 set to %x\n",
++            emac_readl(RA(priv->base + EMAC_RX_NETWORK_PORT_MAC_ADDRESS_HI,
++                       priv->pid)));
++	emac_writel(MAC_LO(mac), RA(priv->base +
++                EMAC_RX_NETWORK_PORT_MAC_ADDRESS_LO, priv->pid));
++	EPRINTK(DEBUG_INFO, "  MAC2 set to %x\n",
++            emac_readl(RA(priv->base + EMAC_RX_NETWORK_PORT_MAC_ADDRESS_LO,
++                       priv->pid)));
++
++	/* Activate network port by setting enable bit */
++	emac_writel(0x01, RA(priv->base + EMAC_RX_NETWORK_PORT_ENABLE, priv->pid));
++	EPRINTK(DEBUG_INFO, "  RX Port enable set to %x\n",
++            emac_readl(RA(priv->base + EMAC_RX_NETWORK_PORT_ENABLE,
++                       priv->pid)));
++
++	/**** Transfer configuration ****/
++
++	/* Set up ring buffer space */
++	priv->tx_buffer_max = CLINE_PACKETS(BUFFER_SIZE) - 1;
++	priv->tx_buffer = alloc_buffer(BUFFER_ORDER);
++
++	/* Start address */
++	EPRINTK(DEBUG_INFO, "  TX Buffer %p (%p phys)\n", priv->tx_buffer,
++            (void*)virt_to_phys(priv->tx_buffer));
++	tmp = virt_to_phys(priv->tx_buffer);
++	emac_writel((tmp + tile_offset) >> 5, RA(priv->base +
++                EMAC_TX_BUFFER_START_ADDRESS, priv->pid));
++	tmp = emac_readl(RA(priv->base + EMAC_TX_BUFFER_START_ADDRESS, priv->pid));
++	EPRINTK(DEBUG_INFO, "  TX Buffer set to @%x\n", tmp);
++
++	/* Get buffer read offset */
++	read_offset = emac_readl(RA(priv->base + EMAC_TX_BUFFER_READ_OFFSET,
++                             priv->pid));
++	EPRINTK(DEBUG_INFO, "  TX Buffer read offset at: %d\n", read_offset);
++
++	/* Set buffer write offset to read offset */
++	emac_writel(read_offset, RA(priv->base + EMAC_TX_BUFFER_WRITE_OFFSET,
++                priv->pid));
++	EPRINTK(DEBUG_INFO, "  TX Buffer write offset set to: %d\n",
++            emac_readl(RA(priv->base + EMAC_TX_BUFFER_WRITE_OFFSET,
++                       priv->pid)));
++	priv->tx_write_offset = read_offset;
++
++	/* Size */
++	emac_writel(priv->tx_buffer_max, RA(priv->base + EMAC_TX_BUFFER_SIZE,
++                priv->pid));
++	EPRINTK(DEBUG_INFO, "  TX Size set to %d\n",
++            emac_readl(RA(priv->base + EMAC_TX_BUFFER_SIZE, priv->pid)));
++
++	/* Route */
++	emac_writel(mode, RA(priv->base + EMAC_TX_MODE, priv->pid));
++	EPRINTK(DEBUG_INFO, "  TX Mode set to %x\n",
++            emac_readl(RA(priv->base + EMAC_TX_MODE, priv->pid)));
++
++	/* Activate network port by setting enable bit */
++	emac_writel(0x01, RA(priv->base + EMAC_TX_NETWORK_PORT_ENABLE, priv->pid));
++	EPRINTK(DEBUG_INFO, "  TX Port enable set to %x\n",
++            emac_readl(RA(priv->base + EMAC_TX_NETWORK_PORT_ENABLE,
++                       priv->pid)));
++}
++
++/**
++ * \brief Resets local interrupt and then global
++ * \prev priv emac private data
++ */
++static void emac_clear_interrupt(struct emac_priv *priv) {
++	unsigned int tmp;
++
++	unset_lapic_mask(EMAC_LVT, priv->net_device->irq);
++
++	/* Clear interrupt bit */
++	sccsys_clear_irq_direct(sccsys_get_pid(), EMAC_IRQ_MASK);
++
++	/* Reset */
++	tmp = priv->device;
++	writel(tmp, RA(IRQ_RESET, priv->pid * 2));
++}
++
++/**
++ * \brief Interrupt handler
++ * \param irq current irq number
++ * \param dev_id private net_device pointer
++ * \return IRQ_HANDLED if we handled this interrupt, otherwise IRQ_NONE
++ */
++static irqreturn_t emac_interrupt(int irq, void *dev_id) {
++	struct net_device *dev = (struct net_device *)dev_id;
++	struct emac_priv *priv = netdev_priv(dev);
++	unsigned int status = 0;
++
++	if (!dev) {
++		printk(KERN_DEBUG "emac interrupt %d for unknown device\n", irq);
++		return IRQ_NONE;
++	}
++
++	status = readl(RA(IRQ_STATUS, priv->pid * 2));
++	//if (printk_ratelimit()) {
++	//	EPRINTK(DEBUG_READ, "Interrupt status Core: %x\n", status);
++	//}
++
++	if (!(status & priv->device)) {
++		//printk(KERN_WARNING "Not an emac interrupt (0x%x)\n", status);
++		return IRQ_NONE;
++	}
++
++	if (likely(napi_schedule_prep(&priv->napi))) {
++		/* disable interrupt */
++		set_lapic_mask(EMAC_LVT, priv->net_device->irq);
++		__napi_schedule(&priv->napi);
++	}
++
++	//if (status & ~priv->device) {
++		/* In case status indicates other int. devices... */
++	//	printk(KERN_INFO "Status was 0x%x, now is 0x%x\n", status, readl(RA(IRQ_STATUS, priv->pid * 2)));
++	//	return IRQ_NONE;
++	//}
++
++	return IRQ_HANDLED;
++}
++
++/**
++ * \brief Open network device
++ * \param dev network device
++ * \return error code
++ */
++int emac_open(struct net_device *dev) {
++	struct emac_priv *priv = netdev_priv(dev);
++	unsigned long long offset = 0;
++	unsigned long long mac = 0;
++	int tmp = 0;
++	scc_coord_t coord;
++	scc_lut_t phys_base;
++	int position = 0;
++	int mode = 0;
++	int subdest = 0;
++	int route = 0;
++	int i = 0;
++	int status;
++
++	netif_carrier_off(dev);
++
++	/* Get SCC processor coordinates and number */
++	coord = sccsys_get_coord();
++	position = sccsys_get_pid();
++
++	EPRINTK(DEBUG_INFO, "Location:\n");
++	EPRINTK(DEBUG_INFO, "  X: %d Y: %d, Z: %d => Position: %d\n",
++	    coord.x, coord.y, coord.z, position);
++
++	/* Depending on core location read own private data
++	 * (offset, subdest, route)
++	 */
++	phys_base = sccsys_read_lut_entry(sccsys_get_pid(), 0);
++
++	offset = (unsigned long long)((unsigned long long)phys_base.address) << 24;
++	subdest = phys_base.subdest;
++	route = sccsys_get_route(phys_base);
++	mode = (subdest << 8) + route;
++
++	EPRINTK(DEBUG_INFO, "Using offset: %llx\n", offset);
++
++	/* setup ethernet port */
++	setup_emac(dev, position, offset, sccsys_get_route(coord), mode);
++
++	/* set network addr */
++	mac = get_mac_address(dev);
++	for (i = 5; i != 0; i--) {
++		dev->dev_addr[i] = mac & 0xFF;
++		mac >>= 8;
++	}
++
++	status = request_irq(dev->irq, &emac_interrupt, IRQF_SHARED, "emac", dev);
++	if (status) {
++		printk(KERN_WARNING "Can't get interrupt #%d\n", dev->irq);
++		return status;
++	}
++
++	napi_enable(&priv->napi);
++
++	emac_clear_interrupt(priv);
++	/* Enable interrupt */
++	tmp = readl(RA(IRQ_MASK, priv->pid * 2));
++	writel(tmp & ~(priv->device), RA(IRQ_MASK, priv->pid * 2));
++	writel(EMAC_IRQ_CONFIG, RA(IRQ_CONFIG, priv->pid));
++	netif_carrier_on(dev);
++
++	netif_start_queue(priv->net_device);
++
++	return 0;
++}
++
++/**
++ * \brief Stop network device: stop queue
++ * \param dev network device
++ * \return error code (0)
++ */
++int emac_stop(struct net_device *dev) {
++	struct emac_priv *priv = netdev_priv(dev);
++
++	/* Shutdown poll */
++	EPRINTK(DEBUG_INFO, "shutdown\n");
++	napi_disable(&priv->napi);
++
++	/* stop queue */
++	EPRINTK(DEBUG_INFO, "stop queue\n");
++	netif_stop_queue(dev);
++
++	/* free irq */
++	free_irq(dev->irq, dev);
++
++	EPRINTK(DEBUG_INFO, "disable rx/tx ports\n");
++
++	/* Disable network tx/rx port */
++	emac_writel(0x00, RA(priv->base + EMAC_TX_NETWORK_PORT_ENABLE, priv->pid));
++	emac_writel(0x00, RA(priv->base + EMAC_RX_NETWORK_PORT_ENABLE, priv->pid));
++
++	netif_carrier_off(dev);
++
++	return 0;
++}
++
++/**
++ * \brief Get first bytes of addr0 (length)
++ * \param dev net device
++ * \return length of data or 0
++ */
++int get_addr0(struct net_device *dev) {
++	struct emac_priv *priv = NULL;
++
++	if (!dev) {
++		return 0;
++	}
++	priv = netdev_priv(dev);
++
++	if (priv && priv -> rx_buffer) {
++		return readl(priv->rx_buffer);
++	}
++
++	return 0;
++}
++
++/**
++ * \brief Receive and process packets from network device
++ * \param priv emac private data
++ * \param write_offset write offset
++ * \param max_num maximum number of packets we can read at once
++ * \return new read offset
++ */
++int emac_rx(struct emac_priv *priv, unsigned short write_offset, int max_num) {
++	struct sk_buff *skb = NULL;
++	unsigned short read_offset = priv->rx_read_offset;
++	void *addr = NULL;
++	unsigned short len = 0;
++	int packets = 0;
++
++again:
++	read_offset++;
++	if (read_offset < 1 || read_offset > priv->rx_buffer_max) {
++		EPRINTK(DEBUG_READ, "read_offset is %d\n", read_offset);
++		read_offset = 1;
++	}
++	addr = priv->rx_buffer + read_offset * 32;
++
++	len = U16(addr);
++
++	EPRINTK(DEBUG_READ, "device: %x current: start read at %d; write_offset "
++            "at %d; addr: %p, packet len: %d (num packets:%d)\n", priv->device,
++             read_offset, write_offset, addr, len, packets);
++
++	/* check for over/underflow */
++	if (len < sizeof(struct iphdr) || len > 1536) {
++		int i = 0;
++
++		printk(KERN_NOTICE "emac_rx(): illegal packet length %d => drop "
++               "(num packets: %d)\n", len, packets);
++		priv->stats.rx_errors++;
++		priv->stats.rx_dropped++;
++
++		read_offset = write_offset;
++		printk("Buffer:\n");
++		for (i = 0; i < 32; i++) {
++			printk("%2.2x ", ((char*)addr)[i] & 0xFF);
++		}
++		printk("\n");
++
++		printk("Buffer0:\n");
++		for (i = 0; i < 32; i++) {
++			printk("%2.2x ", ((char*)priv->rx_buffer)[i] & 0xFF);
++		}
++		printk("\n");
++
++		//napi_disable(&priv->napi);
++		//netif_stop_queue(priv->net_device);
++		//return 0;
++
++		goto rxDone;
++	}
++
++	/* allocate buffer */
++	skb = dev_alloc_skb(len);
++	if (!skb) {
++		if (printk_ratelimit()) {
++			printk(KERN_NOTICE "emac_rx(): low on mem - packet dropped\n");
++		}
++
++		priv->stats.rx_dropped++;
++		return 0;
++	}
++
++	skb_put(skb, len);
++
++	if (read_offset < write_offset) {
++		memcpy(skb->data, addr + 2, len);
++		read_offset += CLINE_PACKETS(skb->len + 2) - 1;
++	} else {
++		int rest;
++		int bytesLeft = len;
++		int bytesToCopy = len;
++
++		EPRINTK(DEBUG_READ, "case: read_offset > write_offset (%d > %d)\n",
++                read_offset, write_offset);
++		/* rest to the end of buffer - 2 bytes length information */
++		rest = (priv->rx_buffer_max - read_offset + 1) * 32 - 2;
++		if (len > rest) {
++			bytesToCopy = rest;
++		}
++		EPRINTK(DEBUG_READ, "bytes to copy: %d, bytesLeft: %d\n", bytesToCopy,
++                bytesLeft);
++		memcpy(skb->data, addr + 2, bytesToCopy);
++		bytesLeft -= bytesToCopy;
++
++		if (bytesLeft != 0) {
++			addr = priv->rx_buffer + 0x20;
++			EPRINTK(DEBUG_READ, "copying from %p, left: %d (%x)\n", addr,
++                    bytesLeft, ((u8*)addr)[0]);
++			memcpy(skb->data+bytesToCopy, addr, bytesLeft);
++			read_offset = CLINE_PACKETS(bytesLeft);
++		} else {
++			read_offset += CLINE_PACKETS(skb->len+2) - 1;
++		}
++	}
++
++	priv->stats.rx_packets++;
++	priv->stats.rx_bytes += len;
++	priv->net_device->last_rx = jiffies;
++
++	skb->dev = priv->net_device;
++	skb->protocol = eth_type_trans(skb, priv->net_device);
++	skb->ip_summed = CHECKSUM_UNNECESSARY;
++
++	/* now process the buffer */
++	netif_receive_skb(skb);
++
++	packets++;
++
++rxDone:
++	/* set new read pointer */
++	EPRINTK(DEBUG_READ, "Update rx read offset: %d\n", read_offset);
++	writel(read_offset, RA(priv->base + EMAC_RX_BUFFER_READ_OFFSET, priv->pid));
++	priv->rx_read_offset = read_offset;
++
++	if (read_offset != write_offset) {
++		if (packets < max_num) {
++			goto again;
++		}
++	}
++
++	return packets;
++}
++
++/**
++ * \brief Polling interface for emac
++ * \param napi napi structure
++ * \param budget budget
++ * \return error code (0=everything done, 1=still work todo)
++ */
++int emac_poll(struct napi_struct *napi, int budget) {
++	struct emac_priv *priv = container_of(napi, struct emac_priv, napi);
++	unsigned int write_offset = 0;
++	int read = 0;
++	int work_done = 0;
++
++	/* try to read packets */
++	while (work_done < budget) {
++		/* check for updated write offset */
++		CL1FLUSH;
++		write_offset = readl(priv->rx_buffer) & 0xFFFF;
++
++		if ((write_offset != 0) && (priv->rx_read_offset != write_offset)) {
++			/* Retrieve packets */
++			read = emac_rx(priv, write_offset, budget - work_done);
++			if (read > 0) {
++				work_done += read;
++			}
++		} else {
++			/* Tell the system we are done polling */
++			napi_complete(napi);
++
++			/* Clear the interrupt */
++			emac_clear_interrupt(priv);
++			break;
++		}
++	}
++
++	return work_done;
++}
++
++/**
++ * \brief Read and display ethernet statistics
++ */
++void show_statistic(void) {
++	int i;
++
++	printk("Ethernet statistic: \n");
++	printk("----------------------------\n");
++	for (i = 0; i < 46; i++) {
++		printk("0x%4x\t-\t%4d\n", STAT0_TRBYTE + i * 8,
++               readl(RA(STAT0_TRBYTE + i * 8, 0)));
++	}
++	printk("----------------------------\n");
++}
++
++/**
++ * \brief Transfer packet to network deivce
++ * \param skb buffer we want to transfer
++ * \param dev network device
++ * \return error code
++ */
++int emac_tx(struct sk_buff *skb, struct net_device *dev) {
++	struct emac_priv *priv = netdev_priv(dev);
++	void *addr = NULL;
++	u16 read_offset = 0;
++	int rest = 0;
++	int packets = 0;
++	int sum = 0;
++
++	EPRINTK(DEBUG_WRITE, "packet len: %d\n", skb->len);
++
++	/* check for over/underflow */
++	if (skb->len < sizeof(struct iphdr) || skb->len > 1536) {
++		printk(KERN_NOTICE "emac_tx(): illegal packet length %d => drop\n",
++               skb->len);
++		priv->stats.tx_errors++;
++		priv->stats.tx_dropped++;
++
++		return 0;
++	}
++
++	priv->tx_write_offset++;
++	/* check if we need to wrap */
++	if (priv->tx_write_offset > priv->tx_buffer_max) {
++		priv->tx_write_offset = 1;
++	}
++
++	packets = CLINE_PACKETS(skb->len + 2);
++
++	read_offset = readl(RA(priv->base + EMAC_TX_BUFFER_READ_OFFSET, priv->pid));
++#ifdef OVERFLOW_CHECK
++again:
++
++	if (read_offset < priv->tx_write_offset) {
++		sum = priv->tx_buffer_max - priv->tx_write_offset + read_offset - 1;
++	} else if (read_offset > priv->tx_write_offset) {
++		sum = read_offset - priv->tx_write_offset - 1;
++	}
++
++	if (sum < packets) {
++		EPRINTK(DEBUG_WRITE, "2. Warning: not enough space available, "
++                "retrying...\n");
++		goto again;
++	}
++#endif
++
++	addr = priv->tx_buffer + priv->tx_write_offset * 32;
++
++	/* Set frame length */
++	((u8*)addr)[0] = skb->len % 256;
++	((u8*)addr)[1] = skb->len / 256;
++
++	if (priv->tx_write_offset + packets - 1 <= priv->tx_buffer_max) {
++		/* enough space, just copy */
++		memcpy(addr + 2, skb->data, skb->len);
++
++		/* increment write ptr */
++		priv->tx_write_offset += packets - 1;
++	} else {
++		/* wrap in offsets. first copy to the end, second at the starting
++         * point
++         */
++		int bytes_left = skb->len;
++		int bytes_to_copy = (priv->tx_buffer_max - priv->tx_write_offset + 1) *
++                             32 - 2;
++
++		if (bytes_left < bytes_to_copy) {
++			bytes_to_copy = bytes_left;
++		}
++
++		EPRINTK(DEBUG_WRITE, "special case: copy last %d bytes\n",
++                bytes_to_copy);
++
++		memcpy(addr + 2, skb->data, bytes_to_copy);
++		bytes_left -= bytes_to_copy;
++
++		if (bytes_left != 0) {
++			priv->tx_write_offset = 1;
++			addr = priv->tx_buffer + 32;
++			EPRINTK(DEBUG_WRITE, "special case: copy remaining %d bytes\n",
++                    bytes_left);
++			memcpy(addr, skb->data + bytes_to_copy, bytes_left);
++
++			rest = bytes_left % 32;
++			if (rest != 0) {
++				rest = 32 - rest;
++			}
++			EPRINTK(DEBUG_WRITE, "Rest is %d\n", rest);
++			priv->tx_write_offset += CLINE_PACKETS(bytes_left + rest) - 1;
++		}
++	}
++
++	writel(2, priv->tx_buffer);
++
++	/* set new write offset */
++	EPRINTK(DEBUG_WRITE, "Update tx write offset: %d (read offset %d)\n",
++            priv->tx_write_offset, read_offset);
++
++	writel(priv->tx_write_offset, RA(priv->base + EMAC_TX_BUFFER_WRITE_OFFSET,
++                   priv->pid));
++
++	dev->trans_start = jiffies;
++	priv->stats.tx_packets++;
++	priv->stats.tx_bytes += skb->len;
++	dev_kfree_skb_any(skb);
++
++	return 0;
++}
++
++/**
++ * \brief Handler transmit timeout
++ * \param dev network device
++ */
++void emac_tx_timeout(struct net_device *dev) {
++	netif_wake_queue(dev);
++}
++
++/**
++ * \brief Return network statistics
++ * \param dev network device
++ * \return network statistic
++ */
++struct net_device_stats *emac_stats(struct net_device *dev) {
++	struct emac_priv *priv = netdev_priv(dev);
++
++	return &(priv->stats);
++}
++
++/**
++ * \brief Change mtu of network device
++ * \param dev network device
++ * \param new_mtu new mtu size
++ * \return error code
++ */
++int emac_change_mtu(struct net_device *dev, int new_mtu) {
++	if ((new_mtu < sizeof(struct iphdr)) || (new_mtu > BUFFER_SIZE - 1)) {
++		return -EINVAL;
++	}
++
++	dev->mtu = new_mtu;
++
++	return 0;
++}
++
++static const struct net_device_ops emac_netdev_ops = {
++	.ndo_open = emac_open,
++	.ndo_stop = emac_stop,
++	.ndo_start_xmit = emac_tx,
++	.ndo_tx_timeout = emac_tx_timeout,
++	.ndo_change_mtu = emac_change_mtu,
++	.ndo_get_stats = emac_stats,
++};
++
++/**
++ * \brief Initialize emac network device
++ * \param dev network device
++ */
++void emac_init(struct net_device *dev) {
++	/* set standard infos */
++	ether_setup(dev);
++
++	/* Network driver specific functions */
++	dev->netdev_ops = &emac_netdev_ops;
++	dev->watchdog_timeo = 5;
++
++	/* Note LVT1's vector is set to 3, LVT0 = 4 */
++	dev->irq = EMAC_IRQ_NR;
++
++	dev->hard_header_len = 2 + ETH_HLEN;
++}
++
++/**
++ * \brief Main network driver entry
++ * \return error code
++ */
++static int __init emac_module_init(void) {
++	struct emac_priv *priv = NULL;
++	int errorCode;
++	int macPorts = 0;
++	int tmp;
++
++	printk(KERN_DEBUG "eMAC driver %s\n", MODVERSTRING);
++
++	grb = sccsys_get_grb();
++
++	/* Get SCC processor id */
++	core0 = sccsys_get_pid();
++
++	tmp = readl(RA(0x822C, 0));
++	if (tmp & EMAC0) {
++		emac_writel(0x00, RA(EMAC0 + EMAC_RX_NETWORK_PORT_ENABLE, core0));
++		emac_writel(0x00, RA(EMAC0 + EMAC_TX_NETWORK_PORT_ENABLE, core0));
++	}
++	if (tmp & EMAC1) {
++		emac_writel(0x00, RA(EMAC1 + EMAC_RX_NETWORK_PORT_ENABLE, core0));
++		emac_writel(0x00, RA(EMAC1 + EMAC_TX_NETWORK_PORT_ENABLE, core0));
++	}
++	if (tmp & EMAC2) {
++		emac_writel(0x00, RA(EMAC2 + EMAC_RX_NETWORK_PORT_ENABLE, core0));
++		emac_writel(0x00, RA(EMAC2 + EMAC_TX_NETWORK_PORT_ENABLE, core0));
++	}
++	if (tmp & EMAC3) {
++		emac_writel(0x00, RA(EMAC3 + EMAC_RX_NETWORK_PORT_ENABLE, core0));
++		emac_writel(0x00, RA(EMAC3 + EMAC_TX_NETWORK_PORT_ENABLE, core0));
++	}
++
++	if (!override) {
++		tmp >>= 16;
++	}
++
++	macPorts = ((tmp >> 9) & 0xFF);
++
++	printk(KERN_DEBUG "eMAC0: %s eMAC1: %s eMAC2: %s eMAC3: %s\n",
++		(macPorts & EMAC0) != 0 ? "present" : "-",
++		(macPorts & EMAC1) != 0 ? "present" : "-",
++		(macPorts & EMAC2) != 0 ? "present" : "-",
++		(macPorts & EMAC3) != 0 ? "present" : "-");
++
++
++	/* Create emac0 if requested */
++	if ((macPorts & EMAC0) && (ethernet_port & EMAC0)) {
++		/* initialize xilinx ip */
++		init_xilinx_port(0, XILINX_EMAC0_BASE);
++
++		emac0_dev = alloc_netdev(sizeof(struct emac_priv), "emac0", emac_init);
++		if (emac0_dev==NULL) {
++			printk(KERN_ERR "alloc_netdev() failed\n");
++			return -ENOMEM;
++		}
++		priv = netdev_priv(emac0_dev);
++		memset(priv, 0, sizeof(struct emac_priv));
++		priv->device = EMAC0;
++		priv->base = EMAC0_BASE;
++		priv->net_device = emac0_dev;
++		netif_napi_add(emac0_dev, &priv->napi, emac_poll, EMAC_NAPI_WEIGHT);
++
++		errorCode = register_netdev(emac0_dev);
++		if (errorCode) {
++			printk(KERN_ERR "error %i registering device \"%s\"\n", errorCode,
++                   emac0_dev->name);
++			return -ENODEV;
++		}
++	}
++
++	/* Create emac1 if requested */
++	if ((macPorts & EMAC1) && (ethernet_port & EMAC1)) {
++		/* initialize xilinx ip */
++		init_xilinx_port(1, XILINX_EMAC1_BASE);
++
++		emac1_dev = alloc_netdev(sizeof(struct emac_priv), "emac1", emac_init);
++		if (emac1_dev==NULL) {
++			printk(KERN_ERR "alloc_netdev() failed\n");
++			return -ENOMEM;
++		}
++		priv = netdev_priv(emac1_dev);
++		memset(priv, 0, sizeof(struct emac_priv));
++		priv->device = EMAC1;
++		priv->base = EMAC1_BASE;
++		priv->net_device = emac1_dev;
++		netif_napi_add(emac1_dev, &priv->napi, emac_poll, EMAC_NAPI_WEIGHT);
++
++		errorCode = register_netdev(emac1_dev);
++		if (errorCode) {
++			printk(KERN_ERR "error %i registering device \"%s\"\n", errorCode,
++                    emac1_dev->name);
++			return -ENODEV;
++		}
++	}
++
++	/* Create emac2 if requested */
++	if ((macPorts & EMAC2) && (ethernet_port & EMAC2)) {
++		/* initialize xilinx ip */
++		init_xilinx_port(2, XILINX_EMAC2_BASE);
++
++		emac2_dev = alloc_netdev(sizeof(struct emac_priv), "emac2", emac_init);
++		if (emac2_dev==NULL) {
++			printk(KERN_ERR "alloc_netdev() failed\n");
++			return -ENOMEM;
++		}
++		priv = netdev_priv(emac2_dev);
++		memset(priv, 0, sizeof(struct emac_priv));
++		priv->device = EMAC2;
++		priv->base = EMAC2_BASE;
++		priv->net_device = emac2_dev;
++		netif_napi_add(emac2_dev, &priv->napi, emac_poll, EMAC_NAPI_WEIGHT);
++
++		errorCode = register_netdev(emac2_dev);
++		if (errorCode) {
++			printk(KERN_ERR "error %i registering device \"%s\"\n", errorCode,
++                    emac2_dev->name);
++			return -ENODEV;
++		}
++	}
++
++	/* Create emac3 if requested */
++	if ((macPorts & EMAC3) && (ethernet_port & EMAC3)) {
++		/* initialize xilinx ip */
++		init_xilinx_port(3, XILINX_EMAC3_BASE);
++
++		emac3_dev = alloc_netdev(sizeof(struct emac_priv), "emac3", emac_init);
++		if (emac3_dev==NULL) {
++			printk(KERN_ERR "alloc_netdev() failed\n");
++			return -ENOMEM;
++		}
++		priv = netdev_priv(emac3_dev);
++		memset(priv, 0, sizeof(struct emac_priv));
++		priv->device = EMAC3;
++		priv->base = EMAC3_BASE;
++		priv->net_device = emac3_dev;
++		netif_napi_add(emac3_dev, &priv->napi, emac_poll, EMAC_NAPI_WEIGHT);
++
++		errorCode = register_netdev(emac3_dev);
++		if (errorCode) {
++			printk(KERN_ERR "error %i registering device \"%s\"\n", errorCode,
++                    emac3_dev->name);
++			return -ENODEV;
++		}
++	}
++
++
++#ifdef NOTIFIER
++	register_netdevice_notifier(&emac_dev_notifier);
++#endif
++
++	return 0;
++}
++
++/**
++ * \brief Main network driver removal function
++ */
++static void __exit emac_module_exit(void) {
++#ifdef NOTIFIER
++	/* unregister netdevice notifier: event handler */
++	EPRINTK(DEBUG_INFO, "unregister netdevice notifier\n");
++	unregister_netdevice_notifier(&emac_dev_notifier);
++#endif
++
++	/* if network device has been created, remove it and free structure */
++	if (emac0_dev != NULL) {
++		unregister_netdev(emac0_dev);
++		free_netdev(emac0_dev);
++	}
++
++	if (emac1_dev != NULL) {
++		unregister_netdev(emac1_dev);
++		free_netdev(emac1_dev);
++	}
++
++	if (emac2_dev != NULL) {
++		unregister_netdev(emac2_dev);
++		free_netdev(emac2_dev);
++	}
++
++	if (emac3_dev != NULL) {
++		unregister_netdev(emac3_dev);
++		free_netdev(emac3_dev);
++	}
++}
++
++module_init(emac_module_init);
++module_exit(emac_module_exit);
++
++MODULE_LICENSE("GPL");
++MODULE_AUTHOR("Jan-Michael Brummer");
++MODULE_VERSION(MODVERSTRING);
++MODULE_DESCRIPTION("Intel(R) eMAC Network Driver");
+diff -urN linux-3.1.4/drivers/net/sccemac.h linux-3.1.4-scc/drivers/net/sccemac.h
+--- linux-3.1.4/drivers/net/sccemac.h	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/net/sccemac.h	2011-12-20 15:27:07.609021371 +0100
+@@ -0,0 +1,231 @@
++/*******************************************************************************
++
++  This program is free software; you can redistribute it and/or modify it
++  under the terms of the GNU General Public License as published by the Free
++  Software Foundation; either version 2 of the License, or (at your option)
++  any later version.
++
++  This program is distributed in the hope that it will be useful, but WITHOUT
++  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
++  more details.
++
++  You should have received a copy of the GNU General Public License along with
++  this program; if not, write to the Free Software Foundation, Inc., 59
++  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
++
++  The full GNU General Public License is included in this distribution in the
++  file called LICENSE.
++
++  Contact Information:
++  Jan-Michael Brummer <jan-michael.brummer@intel.com>
++  Intel Braunschweig
++
++*******************************************************************************/
++
++#ifndef EMAC_H
++#define EMAC_H
++
++#include <linux/version.h>
++
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/pci.h>
++#include <linux/init.h>
++#include <linux/interrupt.h>
++
++#include <linux/netdevice.h>
++#include <linux/etherdevice.h>
++#include <linux/ip.h>
++
++#include <asm/cacheflush.h>
++#include <asm/apic.h>
++
++#include <asm/lapic.h>
++
++#include <linux/sccsys.h>
++
++#define DEBUG_EMAC
++
++#ifdef DEBUG_EMAC
++#define EPRINTK(_level, x...) do {\
++	if (_level & debug_level) {\
++			printk(KERN_INFO "%s(): ", __FUNCTION__);\
++			printk(x);\
++		}\
++	} while ( 0 )
++#else
++#define EPRINTK(_level, x...) //
++#endif
++
++/* Debugging */
++#define DEBUG_READ								0x01
++#define DEBUG_WRITE								0x02
++#define DEBUG_INFO								0x04
++#define DEBUG_TXBUFFER							0x100
++
++/* Read 16bit from buffer */
++//#define U16(_addr)								(256 * (*((volatile u8*)
++//							(_addr + 1))) + (*((volatile u8*)(_addr))))
++
++#define U16(_addr)								(256 * (*((u8*)\
++							(_addr + 1))) + (*((u8*)(_addr))))
++
++/* MAC Address */
++#define MAC_ADDRESS								0x00454D414331ULL
++#define MAC_HI(_x)								((((_x) >> 32)) & 0xFFFF)
++#define MAC_LO(_x)								(((_x) ) & 0xFFFFFFFF)
++
++/* Cache line wrappers */
++#define CLINE_SHIFT								5
++#define CLINE_SIZE								(1UL << CLINE_SHIFT)
++#define CLINE_MASK								(~(CLINE_SIZE - 1))
++#define CLINE_ALIGN(_x)							(((_x) + CLINE_SIZE - 1) & CLINE_MASK)
++#define CLINE_PACKETS(_x)						(CLINE_ALIGN(_x) >> CLINE_SHIFT)
++
++/* Flush */
++#define CL1FLUSH								__asm__ volatile (".byte 0x0F; .byte 0x0A;\n")
++
++/* Limits */
++/* Minimum buffer size must be 48 + 1! in order to handle a maximum ethernet frame */
++/** Order of 9 = 2MB, order of 4 = 64k */
++#define BUFFER_ORDER							9
++#define BUFFER_NUM								(1 << BUFFER_ORDER)
++#define BUFFER_SIZE								(BUFFER_NUM * PAGE_SIZE)
++
++/* Mapping */
++#define RA(_x, _y)								(grb + (_x) + (_y) * 4)
++
++/* Interrupt configuration */
++#ifdef USE_LVT0
++	#define EMAC_LVT							APIC_LVT0
++	#define EMAC_IRQ_MASK						0x00000002
++	#define EMAC_IRQ_NR							4
++	#define EMAC_IRQ_CONFIG						0
++#else
++	#define EMAC_LVT							APIC_LVT1
++	#define EMAC_IRQ_MASK						0x00000001
++	#define EMAC_IRQ_NR							3
++	#define EMAC_IRQ_CONFIG						1
++#endif
++
++#define EMAC0									0x01
++#define EMAC1									0x02
++#define EMAC2									0x04
++#define EMAC3									0x08
++
++#define EMAC0_BASE								0x9000
++#define EMAC1_BASE								0xA000
++#define EMAC2_BASE								0xB000
++#define EMAC3_BASE								0xC000
++
++/* NAPI weight */
++#define EMAC_NAPI_WEIGHT						(64)
++
++/* EMAC RX */
++#define EMAC_RX_BUFFER_START_ADDRESS			0x0000
++#define EMAC_RX_BUFFER_READ_OFFSET				0x0100
++#define EMAC_RX_BUFFER_WRITE_OFFSET				0x0200
++#define EMAC_RX_BUFFER_SIZE						0x0300
++#define EMAC_RX_BUFFER_THRESHOLD				0x0400
++#define EMAC_RX_MODE							0x0500
++#define EMAC_RX_NETWORK_PORT_MAC_ADDRESS_HI		0x0600
++#define EMAC_RX_NETWORK_PORT_MAC_ADDRESS_LO		0x0700
++#define EMAC_RX_NETWORK_PORT_ENABLE				0x0800
++
++/* EMAC TX */
++#define EMAC_TX_BUFFER_START_ADDRESS			0x0900
++#define EMAC_TX_BUFFER_READ_OFFSET				0x0A00
++#define EMAC_TX_BUFFER_WRITE_OFFSET				0x0B00
++#define EMAC_TX_BUFFER_SIZE						0x0C00
++#define EMAC_TX_MODE							0x0D00
++#define EMAC_TX_NETWORK_PORT_ENABLE				0x0E00
++
++/* Xilinx IP configuration - base address */
++#define XILINX_EMAC0_BASE						0x3200
++#define XILINX_EMAC1_BASE						0x4200
++#define XILINX_EMAC2_BASE						0x5200
++#define XILINX_EMAC3_BASE						0x6200
++
++/* Xilinx IP configuration - offsets */
++#define CONFIG_FLOW_CONTROL_ADD					0xC0
++#define TRANSMITTER_ADDRESS						0x80
++#define RECEIVER1_ADDRESS						0x40
++#define CONFIG_ADD								0x100
++#define ADD_FILTER_MOD							0x190
++
++/* Xilinx ethernet statistic */
++#define STAT0_TRBYTE							0x00004400
++#define STAT0_REBYTE							0x00004408
++#define STAT0_UFREC								0x00004410
++#define STAT0_FRFRREC							0x00004418
++#define STAT0_64BREC							0x00004420
++#define STAT0_127BREC							0x00004428
++#define STAT0_255BREC							0x00004430
++#define STAT0_511BREC							0x00004438
++#define STAT0_1023BREC							0x00004440
++#define STAT0_MAXBREC							0x00004448
++#define STAT0_OVFROK							0x00004450
++#define STAT0_64BTRA							0x00004458
++#define STAT0_127BTRA							0x00004460
++#define STAT0_255BTRA							0x00004468
++#define STAT0_511BTRA							0x00004470
++#define STAT0_1023BTRA							0x00004478
++#define STAT0_MAXBTRA							0x00004480
++#define STAT0_OVSZTX							0x00004488
++#define STAT0_FRRXOK							0x00004490
++#define STAT0_FRCHERR							0x00004498
++#define STAT0_BCFRRXOK							0x000044a0
++#define STAT0_MCFRRXOK							0x000044a8
++#define STAT0_CTFRRXOK							0x000044b0
++#define STAT0_LGOUTRG							0x000044b8
++#define STAT0_VLFRRXOK							0x000044c0
++#define STAT0_PFRRXOK							0x000044c8
++#define STAT0_CTRRXBAD							0x000044d0
++#define STAT0_FRTRANOK							0x000044d8
++#define STAT0_BCFRTXOK							0x000044e0
++#define STAT0_MCFRTXOK							0x000044e8
++#define STAT0_UNDERR							0x000044f0
++#define STAT0_CTFRTXOK							0x000044f8
++#define STAT0_VLFRTXOK							0x00004500
++#define STAT0_PSFRTXOK							0x00004508
++#define STAT0_SGLCOLFR							0x00004510
++#define STAT0_MLTCOLFR							0x00004518
++#define STAT0_DEFTRANS							0x00004520
++#define STAT0_LATCOLL							0x00004528
++#define STAT0_EXCCOLL							0x00004530
++#define STAT0_FRWEXCD							0x00004538
++#define STAT0_FRRXAERR							0x00004540
++#define STAT0_UNDCOUNT							0x00004548
++
++/** private network information */
++struct emac_priv {
++	/** network statistic */
++	struct net_device_stats stats;
++	/** indicates which device port is in use */
++	u8 device;
++	/* register base address */
++	u32 base;
++	/** flag for polling shutdown */
++	u8 shutdown;
++	/** own core id */
++	u8 pid;
++	/** rx ring buffer */
++	u8 *rx_buffer;
++	/** tx ring buffer */
++	u8 *tx_buffer;
++	/** maximum rx buffer level */
++	u32 rx_buffer_max;
++	/** current rx buffer level */
++	u32 rx_read_offset;
++	/** maximum tx buffer level */
++	u32 tx_buffer_max;
++	/** current tx buffer level */
++	u32 tx_write_offset;
++	/** napi structure */
++	struct napi_struct napi;
++	/** network device */
++	struct net_device *net_device;
++};
++
++#endif
+diff -urN linux-3.1.4/drivers/net/sccmb.c linux-3.1.4-scc/drivers/net/sccmb.c
+--- linux-3.1.4/drivers/net/sccmb.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/net/sccmb.c	2011-12-20 15:27:07.618380472 +0100
+@@ -0,0 +1,1275 @@
++/*
++ * sccmb.c -- SCC message buffer driver
++ *
++ * Portions Copyright (C) 2009 Intel Corp.
++ *
++ * The code is based on sccmb.c from the book "Linux Device
++ * Drivers" by Alessandro Rubini and Jonathan Corbet, published
++ * by O'Reilly & Associates.
++ */
++
++/* Notes:
++ * - This driver assumes that the SCC system memory driver is also
++ *   loaded as it performs the appropriate initialisation
++ */
++ 
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/moduleparam.h>
++
++#include <linux/sched.h>
++#include <linux/kernel.h>       /* printk() */
++#include <linux/slab.h>         /* kmalloc() */
++#include <linux/errno.h>        /* error codes */
++#include <linux/types.h>        /* size_t */
++#include <linux/interrupt.h>    /* mark_bh */
++
++#include <linux/in.h>
++#include <linux/netdevice.h>    /* struct device, and other headers */
++#include <linux/etherdevice.h>  /* eth_type_trans */
++#include <linux/ip.h>           /* struct iphdr */
++#include <linux/tcp.h>          /* struct tcphdr */
++#include <linux/skbuff.h>
++
++#include <linux/in6.h>
++#include <asm/checksum.h>
++
++#include <asm/io.h>             /* ioremap() & friends */
++#include <asm/pgtable.h>        /* page protection bits */
++#include <asm/apic.h>           /* apic_read() & apic_write() */
++#include <asm/lapic.h>          /* (un)set_lapic_mask */
++
++#include <linux/sccsys.h>
++
++MODULE_AUTHOR("Werner Haas");
++MODULE_LICENSE("GPL");
++
++/* DEBUG messages */
++#define DEBUG_MSG 0
++#define PRINTD(format, args...) if (DEBUG_MSG) { printk(format, ##args); }
++
++
++/*
++ * use the below define to aid in debugging
++ */
++/* #define DBG_INTERRUPT */
++
++/*
++ * runs better without NAPI poll methodology
++ */
++/* #define SCCMB_NO_NAPI*/
++
++
++
++/*
++ * Module parameters
++ */
++static int timeout = 5;
++module_param(timeout, int, 0644);
++MODULE_PARM_DESC(timeout, "Timeout period in jiffies of the NETDEV watchdog");
++
++static int mpb_size = SCC_MPB_SIZE;
++module_param(mpb_size, int, 0644);
++MODULE_PARM_DESC(mpb_size, "Available MPB space for the network layer");
++
++static int mpb_stride = SCC_TILE_SIZE;
++module_param(mpb_stride, int, 0644);
++MODULE_PARM_DESC(mpb_stride, "Stride between adjacent MPBs");
++
++static int mpb_offset = 0xC0000000;
++module_param(mpb_offset, int, 0644);
++MODULE_PARM_DESC(mpb_offset, "Start address of the on-die SRAM memory range");
++
++/* Optionally allow up to 4 packets in flight per destination */
++static int multiPacket = 0;
++module_param(multiPacket, int, 0644);
++MODULE_PARM_DESC(multiPacket, "Enable/disable multiple packets in flight");
++
++/* When interrupts are disabled the NAPI poll function is added to the queue 
++ * at startup never returns 0.
++ */
++static int noIrq = 0;
++module_param(noIrq, int, 0644);
++MODULE_PARM_DESC(noIrq, "Do not use interrupts to trigger receiver");
++
++/* Trigger mode of the receiver interrupt:
++ * level = sender sets IRQ bit, cleared by receiver
++ * edge  = sender sets and clears IRQ bit
++ * Note that the pulse generation may not work reliably on SCC!
++ */
++static int edgeIrq = 1;
++module_param(edgeIrq, int, 0644);
++MODULE_PARM_DESC(edgeIrq, "Generate an IRQ edge, i.e. set&clear status bit");
++
++/* Default: do not use the SCC test&set register so the driver does not 
++ * interfere with other software such as RCCE
++ */
++static int disable_locking = 0;
++module_param(disable_locking, int, 0644);
++MODULE_PARM_DESC(disable_locking, "Enable/disable use of the test&set bits");
++
++/* IP address of the local network the router core to enable packet forwarding.
++ * Note that the parameter format is octet0|octet1|octet2|octet3.
++ */
++static unsigned int ownIpAddress = 0xC0A80000;       /* 192.168.0.0 */
++module_param(ownIpAddress, uint, 0644);
++MODULE_PARM_DESC(ownIpAddress, "IP address of the local network");
++
++static unsigned int routerIpAddress = 0xC0A80001;    /* 192.168.0.1 */
++module_param(routerIpAddress, uint, 0644);
++MODULE_PARM_DESC(routerIpAddress, "IP address of a router core");
++
++static int retriggerInt = 1;
++#ifdef DBG_INTERRUPT
++module_param(retriggerInt, int, 0644);
++MODULE_PARM_DESC(retriggerInt, "Control retriggering of interrupt in case of timeout");
++
++
++static int pingPongTarget = 0;
++module_param(pingPongTarget, int, 0644);
++MODULE_PARM_DESC(pingPongTarget, "Ping Pong Target Core number (1 - 48)");
++#endif
++
++
++
++
++/*
++ * The SCC message buffer device
++ */
++struct net_device* sccmb_dev;
++
++struct sccmb_priv {
++  struct net_device_stats     stats;
++  struct napi_struct          napi;
++  spinlock_t                  lock;
++    
++  /* Device-specific constants:
++   * - the local IP address
++   * - the size of the data FIFO (in cache lines)
++   */
++  u8                          localIp;
++  u8                          mpb_buffersize;
++  /* SCC specific physical memory addresses are mapped into kernel space 
++   */
++  /* mpb = Message Passing Buffer */
++  void*                       mpb[SCC_CORECOUNT];
++  /* The FIFO data structure for the data transfer algorithm 
++   * - pointer to the next cache line in the circular buffer
++   * - busy flag for all peers
++   * - map indicating which peer might be accessing each cache line
++   */
++  u8                          mpb_next;
++  int                         mpb_busy[4*SCC_CORECOUNT];
++  u8                          mpb_map[SCC_MPB_SIZE/SCC_CLINE_SIZE];
++  u8                          mpb_nextDesc[SCC_CORECOUNT];
++  u8                          mpb_rxDesc[SCC_CORECOUNT];
++#ifdef DBG_PACKET_TRACE
++void*     packetTrace;
++unsigned  txTracePtr;
++unsigned  rxTracePtr;
++#endif
++
++#ifdef DBG_INTERRUPT
++unsigned txIntCount[SCC_CORECOUNT];
++unsigned txRetriggerCount[SCC_CORECOUNT];
++unsigned rxIntCount;
++#endif
++};
++
++
++
++/*
++ * SCC specific helper functions
++ */
++
++
++/* ip2phys calculates the physical address of the MPB for the
++ * core ID
++ */
++int sccmb_id2phys(u8 id)
++{
++  int tile_number = (id/2);
++  int core_number = (id%2);
++  int result;
++  
++  /* Only accept IDs for the available cores */
++  if (id >= SCC_CORECOUNT) return 0;
++  
++    result  = mpb_offset;
++    result += mpb_stride*tile_number;
++    result += SCC_MPB_SIZE*core_number;
++
++  return PAGE_ALIGN(result);
++}
++
++
++/* Calculate the descriptor address for a packet transfer from the given
++ * sender IP address. Note that the corresponding descriptor data is stored
++ * in the receiver's MPB.
++ */
++int sccmb_get_desc_address(struct net_device* dev, u8 sender_ip, u8 receiver_ip)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  int                         address;
++  
++  /* The packet descriptors are stored at the receiver side i.e. start with
++   * the message passing buffer of the destination
++   */
++  address  = (int)(priv->mpb[receiver_ip-1]);
++  /* The descriptor area is located at the top i.e. skip the data range */
++  address += (SCC_CLINE_SIZE * priv->mpb_buffersize);
++  /* Evaluate the offset corresponding to the sender IP */
++  address += sender_ip-1;
++
++  return address;
++}
++
++
++/* lock/unlock access the LOCK bit in the core register bank of the
++ * given IP address
++ */
++void sccmb_lock(struct net_device* dev, u8 ip_address)
++{
++	int pid = ip_address - 1;
++
++	if (disable_locking) return;
++
++	sccsys_acquire_pid_lock(pid);
++}
++
++void sccmb_unlock(struct net_device* dev, u8 ip_address)
++{
++	int pid = ip_address - 1;
++
++	if (disable_locking) return;
++
++	sccsys_release_pid_lock(pid);
++}
++
++
++/* trigger_irq/clear_irq access the interrupt bit in the core register bank 
++ * of the given IP address which is connected to the processor's INTR pin
++ */
++void sccmb_trigger_irq(struct net_device* dev, u8 ip_address)
++{
++	int pid = ip_address - 1;
++	sccsys_trigger_irq_direct(pid, SCC_INTR_MASK, edgeIrq);
++}
++
++
++/* reset interrupt bit for core 
++ */
++void sccmb_clear_irq(struct net_device* dev, u8 ip_address)
++{
++	int pid = ip_address - 1;
++	sccsys_clear_irq_direct(pid, SCC_INTR_MASK);
++}
++
++
++/* Flush the write-combining buffer
++ */
++void sccmb_flush_wcbuffer(struct net_device* dev)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  int                         address;
++  int                         value;
++  int                         i;
++  
++  /* Read & write back our own message buffer to flush the write-combining
++   * data. The area at the beginning of the MPB is read-only for other cores,
++   * i.e. we can safely access these cache lines. By reading/writing data
++   * from the first 2 cache lines we have at least 1 address change and thus
++   * the data is forwarded to its destination.
++   */
++  address = (int)priv->mpb[priv->localIp-1];
++  for (i=0; i<2; i++) {
++    value = *((volatile int*)address);
++    CL1FLUSHMB;
++    *((volatile int*)address) = value;
++    
++    address += SCC_CLINE_SIZE;
++  }
++}
++
++
++
++/* tx_pending returns the current status of send operations to the specified IP
++ * In case the local busy flag is set, the remote message passing buffer is
++ * queried to check whether the operation is still pending
++ */
++int sccmb_tx_pending(struct net_device* dev, u8 ip_address, int slot)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  int                         desc_address;
++  int                         i;
++  int 			      timesent;
++  static int 		      timeout_count = 0;
++
++  /* 0 is not a valid IP address and marks unused circular buffer slots */
++  if (ip_address == 0) return 0;
++  
++  /* Select the next Tx descriptor slot if none is specified */
++  if (slot < 0) slot = priv->mpb_nextDesc[ip_address-1];
++  
++  /* Check whether there is an undelivered packet */
++  if (priv->mpb_busy[slot*SCC_CORECOUNT + ip_address-1]) {
++    /* Read the descriptor from the destination to see whether it is still
++     * valid. First we have to flush potentially stale data, though.
++     */
++    CL1FLUSHMB;
++    
++    /* Calculate the descriptor address for the packet transfer from this
++     * node to the given IP address.
++     */
++    desc_address = sccmb_get_desc_address(dev, priv->localIp, ip_address)
++                 + SCC_CORECOUNT * slot;
++    
++    /* Read the packet offset
++     * 0xFF is illegal because the descriptors are located at the top i.e.
++     * this value signals transfer completed.
++     */
++    if (*((u8*)desc_address) != 0xFF) {
++      /* Check the age of the transmission and delete the packet if it is
++       * too old.
++       */
++      timesent =  priv->mpb_busy[slot*SCC_CORECOUNT+ip_address-1];
++      if (jiffies > timesent + timeout)
++      {
++        timeout_count++;
++	if (timeout_count == 1000) {
++	  printk(KERN_DEBUG "sccmb_tx_pending(): Timeout at destination %d\n", 
++		 ip_address);
++	  timeout_count = 0;
++	}
++      
++        /* Free all cache lines holding data for that destination */
++        for (i=0; i<priv->mpb_buffersize; i++) {
++          if ((priv->mpb_map[i]) == ((slot<<6)+ip_address) ) 
++            priv->mpb_map[i] = 0;
++        }
++      }
++      /* Else signal that the transmission is still pending and retrigger the target with another interrupt */
++      else {
++        if  (retriggerInt && (jiffies > timesent)) {
++          sccmb_trigger_irq(dev, ip_address);
++#ifdef DBG_INTERRUPT
++	  priv->txRetriggerCount[ip_address - 1]++;
++#endif
++	}
++	return 1;
++      }
++    }
++    
++    /* Clear the busy flag */
++    priv->mpb_busy[slot*SCC_CORECOUNT + ip_address-1] = 0;
++  }
++  
++  return 0;
++}
++
++
++/* set_descriptor updates the start of packet pointer corresponding to our
++ * own ID at the given destination
++ */
++void sccmb_set_descriptor(struct net_device* dev, u8 ip_address, u8 offset)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  int                         desc_address;
++  
++  /* Make sure that the write misses in the L1 */
++  CL1FLUSHMB;
++  
++  /* Calculate the descriptor address for the packet transfer from this
++   * node to the given IP address. In case multiple packets may be in
++   * flight, the address has to be adjusted according to the current
++   * descriptor slot.
++   */
++  desc_address = sccmb_get_desc_address(dev, priv->localIp, ip_address)
++               + SCC_CORECOUNT * priv->mpb_nextDesc[ip_address-1];
++    
++  /* Write the packet offset for the new transfer */
++  sccmb_lock(dev, ip_address);
++  (*((u8*)desc_address) ) = offset;
++  sccmb_flush_wcbuffer(dev);
++  sccmb_unlock(dev, ip_address);
++}
++
++
++/* clear_descriptor invalidates the packet offset in our own descriptor area,
++ * i.e. marks the data transfer from the specified IP address as completed.
++ */
++void sccmb_clear_descriptor(struct net_device* dev, u8 ip_address)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  int                         desc_address;
++    
++  /* Make sure that the write misses in the L1 */
++  CL1FLUSHMB;
++  
++  /* Calculate the descriptor address for the packet transfer from the
++   * given IP address to our node and adjust it according to the descriptor
++   * slot where we found the packet.
++   */
++  desc_address = sccmb_get_desc_address(dev, ip_address, priv->localIp)
++               + SCC_CORECOUNT * priv->mpb_rxDesc[ip_address-1];
++
++  /* Write 0xFF to enable message transfers again */
++  sccmb_lock(dev, priv->localIp);
++  (*((u8*)desc_address) ) = 0xFF;
++  sccmb_flush_wcbuffer(dev);
++  sccmb_unlock(dev, priv->localIp);
++}
++
++
++
++/*
++ * Open and close
++ * These functions are called when an interface is activated/stopped. Thus,
++ * any system resources should be registered and the device itself should
++ * be initialized.
++ */
++static irqreturn_t sccmb_interrupt(int, void*);
++
++void sccmb_unmap(struct net_device* dev)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  int                         i;
++
++  for (i=0; i<SCC_CORECOUNT; i++) {
++    iounmap(priv->mpb[i]);
++  }
++}
++
++int sccmb_open(struct net_device* dev)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  int                         status = 0;
++  int                         i;
++  int                         address;
++  int                         tmp;
++  int                         pid;
++
++  /* MPB initialisation */
++  
++  /* Calculate how many cache lines are available for the circular buffer
++   * We need 1 status byte per core for message descriptors; in case
++   * support for multiple packets in-flight to the same destination is
++   * enabled, the descriptor range is expanded accordingly.
++   */
++  i = SCC_CORECOUNT/SCC_CLINE_SIZE;
++  if (multiPacket) i = 4*SCC_CORECOUNT/SCC_CLINE_SIZE;
++  if (i%SCC_CLINE_SIZE) i++;
++  priv->mpb_buffersize = (mpb_size/SCC_CLINE_SIZE) - i;
++      
++  /* Map all message buffers */
++  for (i=0; i<SCC_CORECOUNT; i++) {
++    /* Map the address directly, setting the PMB bit so the memory is indeed
++     * treated as message buffer by the core. Also mark it as Write-Through
++     * in order to avoid flushing the L1 cache to get the data into the
++     * message buffer.
++     */
++    address = sccmb_id2phys(i);
++    priv->mpb[i] = ioremap_mpbt(address, mpb_size);
++    if (!priv->mpb[i]) status = -EIO;
++  }
++
++  if (status) {
++    printk(KERN_WARNING "sccmb_open(): Can't map message passing buffer\n");
++    sccmb_unmap(dev);
++    return status;
++  }
++
++  pid = sccsys_get_pid();
++  /* Add 1 to the processor ID to avoid *.*.*.0 IP addresses */
++  priv->localIp = pid + 1;
++
++#ifdef DBG_PACKET_TRACE
++/* Map 2*1MB DDR3 memory per core as packet trace buffer */
++priv->packetTrace = ioremap_nocache(0x80800000ul + 0x400000ul*x + 0x200000ul*z, 2*1024*1024);
++memset(priv->packetTrace, 0, 2*1024*1024);
++#endif
++  PRINTD(KERN_INFO "sccmb_open(): sccmb local IP = %d\n", priv->localIp);
++
++  /* Initialize the descriptor area located at the top of the message buffer */
++  address  = (int)(priv->mpb[priv->localIp-1]);
++  address += (SCC_CLINE_SIZE * priv->mpb_buffersize);
++  tmp = SCC_CORECOUNT;
++  if (multiPacket) tmp *= 4;
++  for (i=0; i<tmp; i++) *((u8*)(address+i)) = 0xFF;
++  sccmb_flush_wcbuffer(dev);
++    
++  /* Configure interrupt handling */
++  status = request_irq(dev->irq, &sccmb_interrupt, IRQF_SHARED, "sccmb", dev);
++  if (status) {
++    printk(KERN_WARNING "Can't get interrupt #%d\n", dev->irq);
++    sccmb_unmap(dev);
++    return status;
++  }
++
++  /* Assign the hardware address of the board (6 octets for Ethernet)
++   * Note that the first octet of ethernet multicast addresses is odd
++   */
++  memcpy(dev->dev_addr, "\0MPB_0", ETH_ALEN);
++    
++  netif_start_queue(dev);
++  napi_enable(&priv->napi);
++
++  /* If interrupts are not used we immediately add the polling function
++   * to the queue which would otherwise be done through the IRQ handler.
++   */
++  if (noIrq) napi_schedule(&priv->napi);
++
++  return 0;
++}
++
++
++int sccmb_close(struct net_device* dev)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  napi_disable(&priv->napi);
++
++  /* Unmap the SCC resources */
++  free_irq(dev->irq, dev);
++  sccmb_unmap(dev);
++  
++  netif_stop_queue(dev);
++  return 0;
++}
++
++
++
++/*!
++ * Configuration changes (passed on by ifconfig)
++ */
++int sccmb_config(struct net_device* dev, struct ifmap* map)
++{	
++#ifdef DBG_INTERRUPT
++	int i;
++	struct sccmb_priv*          priv = netdev_priv(dev);
++#endif
++
++/* Debugging printout trigger */
++#ifdef DBG_INTERRUPT
++	if (map->base_addr == 0xdeb9) {
++	printk(KERN_INFO "sccmb_config(): got debug trigger! (0x%08x)\n", map->base_addr);
++
++	printk(KERN_DEBUG "APIC_ID  : %lx\n", apic_read(APIC_ID));
++	printk(KERN_DEBUG "APIC_LVT0: %lx\n", apic_read(APIC_LVT0));
++	printk(KERN_DEBUG "APIC_LVT1: %lx\n", apic_read(APIC_LVT1));
++	printk(KERN_DEBUG "APIC_ESR : %lx\n", apic_read(APIC_ESR));
++	for (i=0; i < 8; i++) {
++		printk(KERN_DEBUG "APIC_ISR%i: %lx\n", i, apic_read(APIC_ISR + i*0x10));
++	}
++	for (i=0; i < 8; i++) {
++		printk(KERN_DEBUG "APIC_TMR%i: %lx\n", i, apic_read(APIC_TMR + i*0x10));
++	}
++	for (i=0; i < 8; i++) {
++		printk(KERN_DEBUG "APIC_IRR%i: %lx\n", i, apic_read(APIC_IRR + i*0x10));
++	}
++
++	return 0;
++	}
++#endif
++
++#ifdef DBG_INTERRUPT
++	if (map->base_addr == 0xdeba) {
++	for (i=0; i < 48; i++) {
++		printk(KERN_DEBUG "TX int count to core %i: %i (ReTrig: %i)\n", i, priv->txIntCount[i], priv->txRetriggerCount[i]);
++		priv->txIntCount[i] = 0;
++		priv->txRetriggerCount[i] = 0;
++	}
++	printk(KERN_DEBUG "RX int count: %i\n", priv->rxIntCount);
++	priv->rxIntCount = 0;
++	
++	return 0;
++	}
++#endif
++
++#ifdef DBG_INTERRUPT
++	if (map->base_addr == 0xdebb) {
++	  if (pingPongTarget > 0) {
++	    printk(KERN_DEBUG "Triggering Ping Pong to core %i\n", pingPongTarget);
++	    sccmb_trigger_irq(dev, pingPongTarget);
++	  }
++
++	return 0;
++	}
++#endif
++
++
++  /* Can't act on a running interface */
++  if (dev->flags & IFF_UP) return -EBUSY;
++
++  /* Don't allow changing the I/O address */
++  if (map->base_addr != dev->base_addr) {
++    printk(KERN_WARNING "sccmb: Can't change I/O address\n");
++    return -EOPNOTSUPP;
++  }
++
++  /* Allow changing the IRQ */
++  if (map->irq != dev->irq) {
++    dev->irq = map->irq;
++    /* request_irq() is delayed to open-time */
++  }
++
++  /* ignore other fields */
++  return 0;
++}
++
++
++
++/*
++ * Receive a packet: retrieve, encapsulate and pass over to upper levels
++ */
++void sccmb_rx(struct net_device* dev, u8 sourceIp, u8 offset)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  struct sk_buff*             skb;
++  int                         mpb_address;
++  int                         len;
++  int                         headroom;
++  int                         byteCount;
++  unsigned char*              local_mem;
++
++  /* Calculate the address of the packet */
++  mpb_address  = (int)(priv->mpb[sourceIp-1]);
++  mpb_address += offset*SCC_CLINE_SIZE;
++  
++  /* The packet length is stored in the first 2 bytes but does not include
++   * the header. Check for reasonable sizes before processing the data to
++   * prevent nasty memory overflow errors.
++   */
++  len = 256*( *((u8*)(mpb_address  )) )
++      +     ( *((u8*)(mpb_address+1)) );
++  mpb_address += 2;
++
++  if (len < sizeof(struct iphdr) || len > dev->mtu) {
++    /* Simply drop the packet */
++    sccmb_clear_descriptor(dev, sourceIp);
++    
++    printk(KERN_NOTICE "sccmb_rx(): illegal packet length %d => drop\n", len);
++    priv->stats.rx_dropped++;
++    return;
++  }
++        
++  /* Build a skb for the packet data so upper layers can handle it
++   * Note that IP headers should be aligned on 16B boundaries!
++   */
++  skb = dev_alloc_skb(len);
++  if (!skb) {
++    if (printk_ratelimit() )
++      printk(KERN_NOTICE "sccmb rx: low on mem - packet dropped\n");
++
++    /* Note: since we do not clear the offset descriptor we do not trigger
++     * a retransmission and the packet will eventually be processed.
++     */
++    priv->stats.rx_dropped++;
++    return;
++  }
++
++  /* IP headers should be aligned on 16B boundaries, i.e. we just reserve the
++   * payload area and do not prepend the header bytes which are not used
++   * anymore.
++   */
++  local_mem = skb_put(skb, len);
++
++  /* Copy the packet data (without the header) into the buffer. Because 
++   * of the circular buffer implementation we may have to do it in 2 steps.
++   */
++  /* First calculate how much data we can fetch before the wrap-around
++   * occurs so we can determine how much to copy in the first run. Note
++   * that the headroom includes the 2 header bytes as the entire packet
++   * is cacheline aligned!
++   */
++  headroom = (priv->mpb_buffersize - offset) * SCC_CLINE_SIZE - 2;
++  byteCount = len;
++  if (headroom < byteCount) byteCount = headroom;
++  memcpy(skb->data, (void*)mpb_address, byteCount);
++
++#ifdef DBG_PACKET_TRACE
++/* Store the entire packet (including header bytes) also in the trace buffer */
++memcpy((void*)(priv->packetTrace + 1024*1024 + priv->rxTracePtr), (void*)(mpb_address-2), byteCount+2);
++priv->rxTracePtr += byteCount+2;
++if (priv->rxTracePtr > 1024*1024-2048) priv->rxTracePtr = 0;
++#endif
++  
++  /* Finish with the rest if we could not copy the entire packet */
++  if (byteCount < len) {
++    memcpy(skb->data+byteCount, priv->mpb[sourceIp-1], len-byteCount);
++#ifdef DBG_PACKET_TRACE
++memcpy((void*)(priv->packetTrace + 1024*1024 + priv->rxTracePtr), priv->mpb[sourceIp-1], len-byteCount);
++priv->rxTracePtr += len-byteCount;
++if (priv->rxTracePtr > 1024*1024-2048) priv->rxTracePtr = 0;
++#endif
++  }
++
++#ifdef DBG_PACKET_TRACE
++/* Align the rx trace pointer to cacheline boundaries */
++while (priv->rxTracePtr % SCC_CLINE_SIZE) priv->rxTracePtr++;
++#endif
++
++  /* Clear the descriptor as we no longer need the message buffer content */
++  sccmb_clear_descriptor(dev, sourceIp);
++
++  /* Update the interface statistics (also count the header bytes) */
++  priv->stats.rx_packets++;
++  priv->stats.rx_bytes += 2+len;
++  dev->last_rx = jiffies;
++
++  /* Write metadata, and then pass to the receive level */
++  skb->dev        = dev;
++  skb_set_transport_header(skb, 0);
++  skb_set_network_header(skb, 0);
++  skb_set_mac_header(skb, 0);
++  skb->protocol   = htons(ETH_P_IP);
++  skb->pkt_type   = PACKET_HOST;
++  skb->ip_summed  = CHECKSUM_UNNECESSARY;
++
++#ifdef SCCMB_NO_NAPI
++    netif_rx(skb);
++#else
++    netif_receive_skb(skb);
++#endif
++
++}
++
++
++
++/*
++ * Check the receive descriptors and return the IP address if a valid
++ * packet offset is found. Note that a round robin scheme is used to
++ * ensure fairness.
++ */
++static int sccmb_nextRxPacket(struct net_device* dev, u8* offset)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  static u8                   lastSource = 0;
++  u8                          source;
++  u8                          i;
++  u8                          nrOfDescriptors;
++  int                         desc_address;
++  
++  nrOfDescriptors = multiPacket ? 4*SCC_CORECOUNT : SCC_CORECOUNT;
++  
++  *offset = 0xFF;
++  for (i=0; i<nrOfDescriptors; i++) {
++    /* Calculate the descriptor address for the packet transfer from the
++     * given IP address to our node. Add 1 to the last found packet source
++     * so it gets processed with least priority.
++     */
++    source = (1+lastSource + i) % nrOfDescriptors;
++    desc_address = sccmb_get_desc_address(dev, 1+source, priv->localIp);
++    
++    /* Check for a valid receive descriptor */
++    *offset = *((u8*)desc_address);
++    if (*offset < 0xFF) {
++      /* Store the descriptor slot where we found the packet */
++      priv->mpb_rxDesc[source%SCC_CORECOUNT] = source/SCC_CORECOUNT;
++      
++      /* Remember the core number and return the IP address = 1+core number */
++      lastSource = source;
++      return 1 + source%SCC_CORECOUNT;
++    }
++  }
++  
++  /* Return 0 if no packet was found */
++  return 0;
++}
++
++
++/*
++ * The poll implementation processing all incoming packets
++ */
++static int sccmb_poll(struct napi_struct* napi, int to_do)
++{
++  struct sccmb_priv*          priv = container_of(napi, struct sccmb_priv, napi);
++  struct net_device*          dev = napi->dev;
++  int                         npackets = 0;
++  int                         quota = to_do;
++  u8                          sourceIp;
++  u8                          offset = 0;
++
++  /* Process up to quota packets from the receive queue */
++  while (npackets<quota) {
++    /* Flush the message buffer so we get up to date descriptor info */
++    CL1FLUSHMB;
++    sourceIp = sccmb_nextRxPacket(dev, &offset);
++    
++    /* Call the standard receive handler if there is a packet */
++    if (sourceIp) {
++      /* In case of level-triggered interrupts clear it now */
++      if (!edgeIrq) sccmb_clear_irq(dev, priv->localIp);
++      
++      sccmb_rx(dev, sourceIp, offset);
++      npackets++;
++    }
++    /* Else perform a clean exit */
++    else {
++
++      /* If interrupts are disabled we hae to remain in the polling function,
++       * i.e. we may signal that we are done with packet processing but must
++       * not remove us from the queueing list via netif_rx_complete().
++       */
++      if (noIrq) {
++        break;
++      }
++      
++      /* Tell the system we are done with polling */
++      napi_complete(&priv->napi);
++
++      /* Do not use enable_irq(dev->irq); since we might loose enables --> INT locked up */      
++      unset_lapic_mask(APIC_LVT0, dev->irq);
++
++      /* The interrupt was cleared before the Rx packet was processed,
++       * i.e. it will be re-set if another packet arrived since the last
++       * check. Thus the polling function will be scheduled again as
++       * soon as we enable interrupts again so we can safely return.
++       */
++      break;
++    }
++  }
++  
++  return npackets;
++}
++
++
++
++/*
++ * A NAPI interrupt handler since we can receive multiple packets 
++ * (from different sources) with a single interrupt.
++ */
++static irqreturn_t sccmb_interrupt(int irq, void* dev_id)
++{
++  struct net_device*          dev = (struct net_device*)dev_id;
++  struct sccmb_priv*          priv = netdev_priv(dev);
++
++#ifdef SCCMB_NO_NAPI
++  u8                          sourceIp = 0; 
++  u8                          offset = 0; 
++#endif
++
++  /* Paranoid */
++  if (!dev) {
++    printk(KERN_DEBUG "sccmb interrupt %d for unknown device\n", irq);
++    return IRQ_NONE;
++  }
++
++#ifdef DBG_INTERRUPT
++  priv->rxIntCount++;
++  
++  if (pingPongTarget > 0) {
++    sccmb_trigger_irq(dev, pingPongTarget);
++    return IRQ_HANDLED;
++  }
++#endif
++
++#ifdef SCCMB_NO_NAPI
++  CL1FLUSHMB;
++  sourceIp = sccmb_nextRxPacket(dev, &offset);
++  while (sourceIp) {
++    /* Call the standard receive handler if there is a packet */
++    sccmb_rx(dev, sourceIp, offset);
++    /* Flush the message buffer so we get up to date descriptor info */
++    CL1FLUSHMB;
++    sourceIp = sccmb_nextRxPacket(dev, &offset);
++  }
++  return IRQ_HANDLED;
++#else
++
++  /* Disable further interrupts and start the polling process. 
++   * We have to use the nosync version since we are inside the interrupt
++   * service routine!
++   * Do not use disable_irq_nosync(dev->irq); since we might loose enables --> INT locked up
++   */
++
++  set_lapic_mask(APIC_LVT0, dev->irq);
++
++  napi_schedule(&priv->napi);
++  return IRQ_HANDLED;
++#endif
++}
++
++
++
++
++/*
++ * Transmit a packet (low level interface)
++ * This function deals with HW details, i.e. it writes the packet
++ * into the message buffer and informs the destination.
++ */
++u8 sccmb_get_destination(struct net_device* dev, char* packet_buf)
++{
++  struct iphdr*               ipHeader;
++  u32*                        destAddr;
++  u8                          destCore;
++  u8                          netAddr[4];
++  int                         i;
++  
++  /* Extract the destination address from the IP header.
++   * The last (4th) octet is interpreted as core ID.
++   */
++  ipHeader  = (struct iphdr*)(packet_buf+dev->hard_header_len);
++  destAddr  = &(ipHeader->daddr);
++  destCore  = ((u8*)destAddr)[3];
++
++  /* Compare the network part to check if we have a local destination.
++   * Note that the module parameter is expected in A.B.C.D format to make
++   * it easier to modify so the values have to be reversed.
++   * In case a remote network is detected, the core number of the router
++   * is used as destination.
++   */
++  for (i=0; i<4; i++) netAddr[3-i] = (ownIpAddress >> 8*i) & 0xFF;
++  for (i=0; i<3; i++) {
++    if (((u8*)destAddr)[i] != netAddr[i]) destCore = routerIpAddress & 0xFF;
++  }
++  
++  /* Make sure that only valid local IP addresses are returned */
++  if ((destCore < 1) || (destCore > 48)) destCore = 1;
++  
++  return destCore;
++}
++
++static int sccmb_hw_tx(struct net_device* dev, struct sk_buff* skb, u8 destIp)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  u8                          clen;
++  int                         i;
++  int                         ptr;
++  int                         owner;
++  int                         slot;
++
++  /* Determine how many cache lines we need to store the message buffer data */
++  clen = (skb->len / SCC_CLINE_SIZE);
++  if (skb->len % SCC_CLINE_SIZE) clen++;
++  
++  /* Check whether there is enough space in the circular buffer */
++  for (i=0; i<clen; i++) {
++    ptr = (priv->mpb_next + i) % priv->mpb_buffersize;
++    owner = priv->mpb_map[ptr] & 0x3F;
++    slot  = priv->mpb_map[ptr] >> 6;
++    if (sccmb_tx_pending(dev, owner, slot) ) return 1;
++    
++    /* This slot will be used for the new packet transfer - also mark the
++     * the descriptor slot that is being used.
++     */
++    priv->mpb_map[ptr] = (priv->mpb_nextDesc[destIp-1] << 6) + destIp;
++  }
++  
++  /* Copy the data into the circular buffer */
++  ptr  = (int)(priv->mpb[priv->localIp-1]);
++  ptr += (priv->mpb_next * SCC_CLINE_SIZE);
++  if (clen + priv->mpb_next > priv->mpb_buffersize) {
++    /* First fill up the remaining space to the top of the buffer */
++    i = (priv->mpb_buffersize - priv->mpb_next) * SCC_CLINE_SIZE;
++    memcpy((void*)ptr, skb->data, i);
++    
++    /* Copy the remaining bytes to the start */
++    ptr  = (int)(priv->mpb[priv->localIp-1]);
++    memcpy((void*)ptr, skb->data+i, skb->len-i);
++  }
++  else {
++    /* Simply copy all the data since there is enough space without
++     * pointer roll-over.
++     */
++    memcpy((void*)ptr, skb->data, skb->len);
++  }
++
++#ifdef DBG_PACKET_TRACE
++/* Store the packet in the trace buffer */
++memcpy((void*)(priv->packetTrace + priv->txTracePtr), skb->data, skb->len);
++priv->txTracePtr += clen*SCC_CLINE_SIZE;
++if (priv->txTracePtr > 1024*1024-2048) priv->txTracePtr = 0;
++#endif    
++  /* Set the descriptor on the receiver side
++   * Since different addresses are used, this automatically flushes the
++   * data inside the write-combining buffer so the receiver sees up to
++   * date message buffer content.
++   */
++  sccmb_set_descriptor(dev, destIp, priv->mpb_next);
++  
++  /* Update the pointer to the next circular buffer slot and flag the
++   * pending transmission.
++   */
++  slot = priv->mpb_nextDesc[destIp-1];
++  priv->mpb_next = (priv->mpb_next + clen) % priv->mpb_buffersize;
++  priv->mpb_busy[slot*SCC_CORECOUNT + destIp-1] = jiffies;
++
++  /* Interrupt the receiver so it starts processing the packet */
++  sccmb_trigger_irq(dev, destIp);
++  
++  /* Increment the next descriptor slot for the next transmission in case
++   * multiple packets may be in flight.
++   */
++  if (multiPacket)
++    priv->mpb_nextDesc[destIp-1] = (priv->mpb_nextDesc[destIp-1] + 1) % 4;
++      
++  /* Transmission succeeded so save the timestamp of the transmission,
++   * update the statistics and free the socket buffer 
++   */
++  dev->trans_start = jiffies;
++
++  priv->stats.tx_packets++;
++  priv->stats.tx_bytes += skb->len;
++  dev_kfree_skb_any(skb);
++  
++  return 0;
++}
++
++
++
++/*
++ * Transmit a packet (called by the kernel)
++ */
++int sccmb_tx(struct sk_buff* skb, struct net_device* dev)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  u8                          destIp = sccmb_get_destination(dev, skb->data);
++  u8                          slot = priv->mpb_nextDesc[destIp-1];
++  u8                          i;
++  
++  //printk(KERN_DEBUG "sccmb_tx(): start\n");
++  
++  /* Perform a sanity check on the packet data, i.e. silently drop packets
++   * that are either too short or send to an illegal IP address by indicating
++   * success without executing any data transfer operations.
++   */
++  if ((skb->len < dev->hard_header_len+sizeof(struct iphdr) ) || 
++      (destIp > SCC_CORECOUNT) )
++  {
++    printk(KERN_NOTICE "sccmb_tx(): Illegal packet (%i octets to IP %d)\n", 
++                       skb->len, destIp);
++    goto drop_packet;
++  }
++  
++  /* Check if another transmission to the same destination is pending */
++  if (sccmb_tx_pending(dev, destIp, -1) ) {
++    /* If too much time elapsed since the previous transmission the receiver
++     * is probably dead and we drop the packet
++     */
++    if (jiffies > priv->mpb_busy[slot*SCC_CORECOUNT + destIp-1] + timeout) {
++      printk(KERN_NOTICE "sccmb_tx(): Timeout at destination %d\n", destIp);
++      
++      /* Also free all cache lines holding data for that destination */
++      for (i=0; i<priv->mpb_buffersize; i++) {
++        if ((priv->mpb_map[i]) == ((slot<<6)+destIp) )
++          priv->mpb_map[i] = 0;
++      }
++      
++      goto drop_packet;
++    }
++    /* Else signal the kernel that the transmission failed so it can 
++     * reschedule 
++     */
++    return 1;
++  }
++  
++  /* Now perform the low level data transfer and return the result. If it
++   * failed, e.g. because there is not enough space in the MPB, the kernel
++   * will retry transmission.
++   */
++  return sccmb_hw_tx(dev, skb, destIp);
++  
++drop_packet:
++  priv->stats.tx_errors++;
++  dev_kfree_skb_any(skb);
++  return 0;
++}
++
++
++
++/*
++ * Deal with a transmit timeout.
++ */
++void sccmb_tx_timeout(struct net_device* dev)
++{
++  /* A timeout occurs if the queue was stopped because too many packet
++   * transfers were pending. Let's simply resume regular packet processing
++   * in the hope that the receiver have cleared their backlog.
++   */
++  //printk(KERN_DEBUG "sccmb_tx_timeout()\n");
++  
++  netif_wake_queue(dev);
++  return;
++}
++
++
++
++/*
++ * ioctl commands
++ */
++int sccmb_ioctl(struct net_device* dev, struct ifreq* rq, int cmd)
++{
++  /*
++   * Custom commands
++   */
++  return 0;
++}
++
++
++
++/*
++ * Return statistics to the caller
++ */
++struct net_device_stats* sccmb_stats(struct net_device* dev)
++{
++  struct sccmb_priv* priv = netdev_priv(dev);
++  
++  return &(priv->stats);
++}
++
++
++
++/*
++ * The "change_mtu" method is usually not needed.
++ * If you need it, it must be like this.
++ */
++int sccmb_change_mtu(struct net_device* dev, int new_mtu)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  unsigned long               flags;
++  spinlock_t*                 lock = &(priv->lock);
++
++  /* check ranges */
++  if ((new_mtu < 68) || (new_mtu > 1500)) return -EINVAL;
++
++  /*
++   * Simply accept the value
++   */
++  spin_lock_irqsave(lock, flags);
++  dev->mtu = new_mtu;
++  spin_unlock_irqrestore(lock, flags);
++  
++  return 0;
++}
++
++
++
++/*
++ * This function is called to fill up an eth header, since ARP is not
++ * available on the interface.
++ */
++int sccmb_rebuild_header(struct sk_buff* skb)
++{
++  printk(KERN_WARNING "sccmb_rebuild_header() called - ignoring\n");
++
++  return 0;
++}
++
++int sccmb_header(struct sk_buff* skb, struct net_device* dev,
++                 unsigned short type, const void* daddr, const void* saddr,
++                 unsigned int len)
++{
++  /* Prepend 2 header bytes containing the packet length */
++  u8* header = skb_push(skb, 2);
++
++  /* Store the length starting with the MSBs */
++  header[0] = len/256;
++  header[1] = len%256;
++      
++  return (dev->hard_header_len);
++}
++
++
++static const struct net_device_ops sccmb_netdev_ops = {
++	.ndo_open		= sccmb_open,
++	.ndo_stop		= sccmb_close,
++	.ndo_set_config		= sccmb_config,
++	.ndo_start_xmit		= sccmb_tx,
++	.ndo_do_ioctl		= sccmb_ioctl,
++	.ndo_get_stats		= sccmb_stats,
++	.ndo_change_mtu		= sccmb_change_mtu,
++	.ndo_tx_timeout		= sccmb_tx_timeout,
++};
++
++static const struct header_ops sccmb_header_ops = {
++	.create			= sccmb_header,
++	.rebuild		= sccmb_rebuild_header,
++};
++
++/*
++ * The init function (sometimes called probe).
++ * It is invoked by register_netdev()
++ */
++void sccmb_init(struct net_device* dev)
++{
++  struct sccmb_priv* priv;
++
++  /*
++   * Then initialize the priv field. This encloses the statistics
++   * and a few private fields.
++   */
++  priv = netdev_priv(dev);
++  memset(priv, 0, sizeof(struct sccmb_priv));
++  
++  spin_lock_init(&priv->lock);
++
++  /* Get meaningful default values */
++  ether_setup(dev);
++
++  /* Set the correct function pointers */
++  dev->netdev_ops = &sccmb_netdev_ops;
++  dev->header_ops = &sccmb_header_ops;
++  
++  dev->watchdog_timeo   = timeout;
++
++  /* Configure NAPI interrupt handling because we may receive multiple
++   * packets per interrupt. Note that Lehnix/MCEMU set LVT0's vector to 4.
++   */
++  netif_napi_add(dev, &priv->napi, sccmb_poll, 16);
++  dev->irq              = 4;
++
++  /* Keep the default flags; just add NOARP */
++  dev->flags           |= IFF_NOARP;
++  /* Checksum checks are not required */
++  // dev->features        |= NETIF_F_NO_CSUM;
++  /* Disable caching of (nonexistent) ARP replies */
++  //dev->hard_header_cache = NULL;
++  /* Change the hardware header as there is no need for an Ethernet format */
++  dev->hard_header_len    = 2;
++  dev->addr_len           = 0;
++}
++
++
++
++/*
++ * Finally, the module stuff
++ */
++void sccmb_cleanup(void)
++{
++  if (sccmb_dev) {
++    unregister_netdev(sccmb_dev);
++    free_netdev(sccmb_dev);
++  }
++}
++
++
++
++int sccmb_init_module(void)
++{
++  int result;
++
++  /* This driver does only work in a bare-metal environment */
++  if (!scc_bare_metal()) {
++    printk(KERN_INFO "sccmb: startup in non-SCC or paravirtualized environment.\n");
++    return -EINVAL;
++  }
++
++  /* Allocate the devices */
++  sccmb_dev = alloc_netdev(sizeof(struct sccmb_priv), "mb0", sccmb_init);
++  if (!sccmb_dev) return -ENOMEM;
++
++  result = register_netdev(sccmb_dev);
++  if (result) {
++    printk(KERN_WARNING "sccmb: error %i registering device \"%s\"\n", 
++                        result, sccmb_dev->name);
++    free_netdev(sccmb_dev);
++    return -ENODEV;
++  }
++
++  return 0;
++}
++
++
++
++module_init(sccmb_init_module);
++module_exit(sccmb_cleanup);
+diff -urN linux-3.1.4/drivers/net/sccmbx.c linux-3.1.4-scc/drivers/net/sccmbx.c
+--- linux-3.1.4/drivers/net/sccmbx.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/net/sccmbx.c	2011-12-20 15:27:07.618380472 +0100
+@@ -0,0 +1,1650 @@
++/*
++ * sccmb.c -- SCC message buffer driver
++ *
++ * Portions Copyright (C) 2009 Intel Corp.
++ *
++ * The code is based on sccmb.c from the book "Linux Device
++ * Drivers" by Alessandro Rubini and Jonathan Corbet, published
++ * by O'Reilly & Associates.
++ */
++
++/* Notes:
++ * - This driver assumes that the SCC system memory driver is also
++ *   loaded as it performs the appropriate initialisation
++ */
++ 
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/moduleparam.h>
++
++#include <linux/sched.h>
++#include <linux/kernel.h>       /* printk() */
++#include <linux/slab.h>         /* kmalloc() */
++#include <linux/errno.h>        /* error codes */
++#include <linux/types.h>        /* size_t */
++#include <linux/interrupt.h>    /* mark_bh */
++
++#include <linux/in.h>
++#include <linux/netdevice.h>    /* struct device, and other headers */
++#include <linux/etherdevice.h>  /* eth_type_trans */
++#include <linux/ip.h>           /* struct iphdr */
++#include <linux/tcp.h>          /* struct tcphdr */
++#include <linux/skbuff.h>
++
++#include <linux/in6.h>
++#include <asm/checksum.h>
++
++#include <asm/io.h>             /* ioremap() & friends */
++#include <asm/pgtable.h>        /* page protection bits */
++#include <asm/apic.h>           /* apic_read() & apic_write() */
++#include <asm/lapic.h>          /* (un)set_lapic_mask */
++#include <linux/kallsyms.h>	/* print_symbol */
++
++#include <linux/sccsys.h>
++#include "sccmbx.h"
++
++MODULE_AUTHOR("Werner Haas");
++MODULE_LICENSE("GPL");
++
++
++/* DEBUG messages */
++#define DEBUG_MSG 0
++#define PRINTD(format, args...) if (DEBUG_MSG) { printk(format, ##args); }
++
++
++/*
++ * use the below define to aid in debugging
++ */
++/* #define DBG_INTERRUPT */
++
++/*
++ * runs better without NAPI poll methodology
++ */
++/* #define SCCMB_NO_NAPI*/
++
++
++
++/*
++ * Module parameters
++ */
++static int timeout = 5;
++module_param(timeout, int, 0644);
++MODULE_PARM_DESC(timeout, "Timeout period in jiffies of the NETDEV watchdog");
++
++static int mpb_size = SCC_MPB_SIZE;
++module_param(mpb_size, int, 0644);
++MODULE_PARM_DESC(mpb_size, "Available MPB space for the network layer");
++
++static int mpb_stride = SCC_TILE_SIZE;
++module_param(mpb_stride, int, 0644);
++MODULE_PARM_DESC(mpb_stride, "Stride between adjacent MPBs");
++
++static int mpb_offset = 0xC0000000;
++module_param(mpb_offset, int, 0644);
++MODULE_PARM_DESC(mpb_offset, "Start address of the on-die SRAM memory range");
++
++/* Optionally allow up to 4 packets in flight per destination */
++static int multiPacket = 0;
++module_param(multiPacket, int, 0644);
++MODULE_PARM_DESC(multiPacket, "Enable/disable multiple packets in flight");
++
++/* When interrupts are disabled the NAPI poll function is added to the queue 
++ * at startup never returns 0.
++ */
++static int noIrq = 0;
++module_param(noIrq, int, 0644);
++MODULE_PARM_DESC(noIrq, "Do not use interrupts to trigger receiver");
++
++/* Trigger mode of the receiver interrupt:
++ * level = sender sets IRQ bit, cleared by receiver
++ * edge  = sender sets and clears IRQ bit
++ * Note that the pulse generation may not work reliably on SCC!
++ */
++static int edgeIrq = 1;
++module_param(edgeIrq, int, 0644);
++MODULE_PARM_DESC(edgeIrq, "Generate an IRQ edge, i.e. set&clear status bit");
++
++/* Default: do not use the SCC test&set register so the driver does not 
++ * interfere with other software such as RCCE
++ */
++static int disable_locking = 0;
++module_param(disable_locking, int, 0644);
++MODULE_PARM_DESC(disable_locking, "Enable/disable use of the test&set bits");
++
++/* IP address of the local network the router core to enable packet forwarding.
++ * Note that the parameter format is octet0|octet1|octet2|octet3.
++ */
++static unsigned int ownIpAddress = 0xC0A80000;       /* 192.168.0.0 */
++module_param(ownIpAddress, uint, 0644);
++MODULE_PARM_DESC(ownIpAddress, "IP address of the local network");
++
++static unsigned int routerIpAddress = 0xC0A80001;    /* 192.168.0.1 */
++module_param(routerIpAddress, uint, 0644);
++MODULE_PARM_DESC(routerIpAddress, "IP address of a router core");
++
++static int retriggerInt = 1;
++#ifdef DBG_INTERRUPT
++module_param(retriggerInt, int, 0644);
++MODULE_PARM_DESC(retriggerInt, "Control retriggering of interrupt in case of timeout");
++
++
++static int pingPongTarget = 0;
++module_param(pingPongTarget, int, 0644);
++MODULE_PARM_DESC(pingPongTarget, "Ping Pong Target Core number (1 - 48)");
++#endif
++
++
++
++
++/*
++ * The SCC message buffer device
++ */
++struct net_device* sccmb_dev;
++
++struct sccmb_priv {
++  struct net_device_stats     stats;
++  struct napi_struct          napi;
++  spinlock_t                  lock;
++    
++  /* Device-specific constants:
++   * - the local IP address
++   * - the size of the data FIFO (in cache lines)
++   */
++  u8                          localIp;
++  u8                          mpb_buffersize;
++  /* SCC specific physical memory addresses are mapped into kernel space 
++   */
++  /* mpb = Message Passing Buffer */
++  void*                       mpb[SCC_CORECOUNT];
++  /* The FIFO data structure for the data transfer algorithm 
++   * - pointer to the next cache line in the circular buffer
++   * - busy flag for all peers
++   * - map indicating which peer might be accessing each cache line
++   */
++  u8                          mpb_next;
++  int                         mpb_busy[4*SCC_CORECOUNT];
++  u8                          mpb_map[SCC_MPB_SIZE/SCC_CLINE_SIZE];
++  u8                          mpb_nextDesc[SCC_CORECOUNT];
++  u8                          mpb_rxDesc[SCC_CORECOUNT];
++#ifdef DBG_PACKET_TRACE
++void*     packetTrace;
++unsigned  txTracePtr;
++unsigned  rxTracePtr;
++#endif
++
++#ifdef DBG_INTERRUPT
++unsigned txIntCount[SCC_CORECOUNT];
++unsigned txRetriggerCount[SCC_CORECOUNT];
++unsigned rxIntCount;
++#endif
++};
++
++
++
++/*
++ * SCC specific helper functions
++ */
++
++
++/* ip2phys calculates the physical address of the MPB for the
++ * core ID
++ */
++int sccmb_id2phys(u8 id)
++{
++  int tile_number = (id/2);
++  int core_number = (id%2);
++  int result;
++  
++  /* Only accept IDs for the available cores */
++  if (id >= SCC_CORECOUNT) return 0;
++  
++    result  = mpb_offset;
++    result += mpb_stride*tile_number;
++    result += SCC_MPB_SIZE*core_number;
++
++  return PAGE_ALIGN(result);
++}
++
++
++/* Calculate the descriptor address for a packet transfer from the given
++ * sender IP address. Note that the corresponding descriptor data is stored
++ * in the receiver's MPB.
++ */
++int sccmb_get_desc_address(struct net_device* dev, u8 sender_ip, u8 receiver_ip)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  int                         address;
++  
++  /* The packet descriptors are stored at the receiver side i.e. start with
++   * the message passing buffer of the destination
++   */
++  address  = (int)(priv->mpb[receiver_ip-1]);
++  /* The descriptor area is located at the top i.e. skip the data range */
++  address += (SCC_CLINE_SIZE * priv->mpb_buffersize);
++  /* Evaluate the offset corresponding to the sender IP */
++  address += sender_ip-1;
++
++  return address;
++}
++
++
++/* lock/unlock access the LOCK bit in the core register bank of the
++ * given IP address
++ */
++void sccmb_lock(struct net_device* dev, u8 ip_address)
++{
++	int pid = ip_address - 1;
++
++	if (disable_locking) return;
++
++	sccsys_acquire_pid_lock(pid);
++}
++
++void sccmb_unlock(struct net_device* dev, u8 ip_address)
++{
++	int pid = ip_address - 1;
++
++	if (disable_locking) return;
++
++	sccsys_release_pid_lock(pid);
++}
++
++
++/* trigger_irq/clear_irq access the interrupt bit in the core register bank 
++ * of the given IP address which is connected to the processor's INTR pin
++ */
++void sccmb_trigger_irq(struct net_device* dev, u8 ip_address)
++{
++	int pid = ip_address - 1;
++	sccsys_trigger_irq_direct(pid, SCC_INTR_MASK, edgeIrq);
++}
++
++
++/* reset interrupt bit for core 
++ */
++void sccmb_clear_irq(struct net_device* dev, u8 ip_address)
++{
++	int pid = ip_address - 1;
++	sccsys_clear_irq_direct(pid, SCC_INTR_MASK);
++}
++
++
++/* Flush the write-combining buffer
++ */
++void sccmb_flush_wcbuffer(struct net_device* dev)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  int                         address;
++  int                         value;
++  int                         i;
++  
++  /* Read & write back our own message buffer to flush the write-combining
++   * data. The area at the beginning of the MPB is read-only for other cores,
++   * i.e. we can safely access these cache lines. By reading/writing data
++   * from the first 2 cache lines we have at least 1 address change and thus
++   * the data is forwarded to its destination.
++   */
++  address = (int)priv->mpb[priv->localIp-1];
++  for (i=0; i<2; i++) {
++    value = *((volatile int*)address);
++    CL1FLUSHMB;
++    *((volatile int*)address) = value;
++    
++    address += SCC_CLINE_SIZE;
++  }
++}
++
++
++
++/* tx_pending returns the current status of send operations to the specified IP
++ * In case the local busy flag is set, the remote message passing buffer is
++ * queried to check whether the operation is still pending
++ */
++int sccmb_tx_pending(struct net_device* dev, u8 ip_address, int slot)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  int                         desc_address;
++  int                         i;
++  int 			      timesent;
++  static int 		      timeout_count = 0;
++
++  /* 0 is not a valid IP address and marks unused circular buffer slots */
++  if (ip_address == 0) return 0;
++  
++  /* Select the next Tx descriptor slot if none is specified */
++  if (slot < 0) slot = priv->mpb_nextDesc[ip_address-1];
++  
++  /* Check whether there is an undelivered packet */
++  if (priv->mpb_busy[slot*SCC_CORECOUNT + ip_address-1]) {
++    /* Read the descriptor from the destination to see whether it is still
++     * valid. First we have to flush potentially stale data, though.
++     */
++    CL1FLUSHMB;
++    
++    /* Calculate the descriptor address for the packet transfer from this
++     * node to the given IP address.
++     */
++    desc_address = sccmb_get_desc_address(dev, priv->localIp, ip_address)
++                 + SCC_CORECOUNT * slot;
++    
++    /* Read the packet offset
++     * 0xFF is illegal because the descriptors are located at the top i.e.
++     * this value signals transfer completed.
++     */
++    if (*((u8*)desc_address) != 0xFF) {
++      /* Check the age of the transmission and delete the packet if it is
++       * too old.
++       */
++      timesent =  priv->mpb_busy[slot*SCC_CORECOUNT+ip_address-1];
++      if (jiffies > timesent + timeout)
++      {
++        timeout_count++;
++	if (timeout_count == 1000) {
++	  printk(KERN_DEBUG "sccmb_tx_pending(): Timeout at destination %d\n", 
++		 ip_address);
++	  timeout_count = 0;
++	}
++      
++        /* Free all cache lines holding data for that destination */
++        for (i=0; i<priv->mpb_buffersize; i++) {
++          if ((priv->mpb_map[i]) == ((slot<<6)+ip_address) ) 
++            priv->mpb_map[i] = 0;
++        }
++      }
++      /* Else signal that the transmission is still pending and retrigger the target with another interrupt */
++      else {
++        if  (retriggerInt && (jiffies > timesent)) {
++          sccmb_trigger_irq(dev, ip_address);
++#ifdef DBG_INTERRUPT
++	  priv->txRetriggerCount[ip_address - 1]++;
++#endif
++	}
++	return 1;
++      }
++    }
++    
++    /* Clear the busy flag */
++    priv->mpb_busy[slot*SCC_CORECOUNT + ip_address-1] = 0;
++  }
++  
++  return 0;
++}
++
++
++/* set_descriptor updates the start of packet pointer corresponding to our
++ * own ID at the given destination
++ */
++void sccmb_set_descriptor(struct net_device* dev, u8 ip_address, u8 offset)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  int                         desc_address;
++  
++  /* Make sure that the write misses in the L1 */
++  CL1FLUSHMB;
++  
++  /* Calculate the descriptor address for the packet transfer from this
++   * node to the given IP address. In case multiple packets may be in
++   * flight, the address has to be adjusted according to the current
++   * descriptor slot.
++   */
++  desc_address = sccmb_get_desc_address(dev, priv->localIp, ip_address)
++               + SCC_CORECOUNT * priv->mpb_nextDesc[ip_address-1];
++    
++  /* Write the packet offset for the new transfer */
++  sccmb_lock(dev, ip_address);
++  (*((u8*)desc_address) ) = offset;
++  sccmb_flush_wcbuffer(dev);
++  sccmb_unlock(dev, ip_address);
++}
++
++
++/* clear_descriptor invalidates the packet offset in our own descriptor area,
++ * i.e. marks the data transfer from the specified IP address as completed.
++ */
++void sccmb_clear_descriptor(struct net_device* dev, u8 ip_address)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  int                         desc_address;
++    
++  /* Make sure that the write misses in the L1 */
++  CL1FLUSHMB;
++  
++  /* Calculate the descriptor address for the packet transfer from the
++   * given IP address to our node and adjust it according to the descriptor
++   * slot where we found the packet.
++   */
++  desc_address = sccmb_get_desc_address(dev, ip_address, priv->localIp)
++               + SCC_CORECOUNT * priv->mpb_rxDesc[ip_address-1];
++
++  /* Write 0xFF to enable message transfers again */
++  sccmb_lock(dev, priv->localIp);
++  (*((u8*)desc_address) ) = 0xFF;
++  sccmb_flush_wcbuffer(dev);
++  sccmb_unlock(dev, priv->localIp);
++}
++
++
++
++/*
++ * Open and close
++ * These functions are called when an interface is activated/stopped. Thus,
++ * any system resources should be registered and the device itself should
++ * be initialized.
++ */
++static irqreturn_t sccmb_interrupt(int, void*);
++
++void sccmb_unmap(struct net_device* dev)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  int                         i;
++
++  for (i=0; i<SCC_CORECOUNT; i++) {
++    iounmap(priv->mpb[i]);
++  }
++}
++
++int sccmb_open(struct net_device* dev)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  int                         status = 0;
++  int                         i;
++  int                         address;
++  int                         tmp;
++  int                         pid;
++
++  /* MPB initialisation */
++  
++  /* Calculate how many cache lines are available for the circular buffer
++   * We need 1 status byte per core for message descriptors; in case
++   * support for multiple packets in-flight to the same destination is
++   * enabled, the descriptor range is expanded accordingly.
++   */
++  i = SCC_CORECOUNT/SCC_CLINE_SIZE;
++  if (multiPacket) i = 4*SCC_CORECOUNT/SCC_CLINE_SIZE;
++  if (i%SCC_CLINE_SIZE) i++;
++  priv->mpb_buffersize = (mpb_size/SCC_CLINE_SIZE) - i;
++      
++  /* Map all message buffers */
++  for (i=0; i<SCC_CORECOUNT; i++) {
++    /* Map the address directly, setting the PMB bit so the memory is indeed
++     * treated as message buffer by the core. Also mark it as Write-Through
++     * in order to avoid flushing the L1 cache to get the data into the
++     * message buffer.
++     */
++    address = sccmb_id2phys(i);
++    priv->mpb[i] = ioremap_mpbt(address, mpb_size);
++    if (!priv->mpb[i]) status = -EIO;
++  }
++
++  if (status) {
++    printk(KERN_WARNING "sccmb_open(): Can't map message passing buffer\n");
++    sccmb_unmap(dev);
++    return status;
++  }
++
++  pid = sccsys_get_pid();
++  /* Add 1 to the processor ID to avoid *.*.*.0 IP addresses */
++  priv->localIp = pid + 1;
++
++#ifdef DBG_PACKET_TRACE
++/* Map 2*1MB DDR3 memory per core as packet trace buffer */
++priv->packetTrace = ioremap_nocache(0x80800000ul + 0x400000ul*x + 0x200000ul*z, 2*1024*1024);
++memset(priv->packetTrace, 0, 2*1024*1024);
++#endif
++  PRINTD(KERN_INFO "sccmb_open(): sccmb local IP = %d\n", priv->localIp);
++
++  /* Initialize the descriptor area located at the top of the message buffer */
++  address  = (int)(priv->mpb[priv->localIp-1]);
++  address += (SCC_CLINE_SIZE * priv->mpb_buffersize);
++  tmp = SCC_CORECOUNT;
++  if (multiPacket) tmp *= 4;
++  for (i=0; i<tmp; i++) *((u8*)(address+i)) = 0xFF;
++  sccmb_flush_wcbuffer(dev);
++    
++  /* Configure interrupt handling */
++  status = request_irq(dev->irq, &sccmb_interrupt, IRQF_SHARED, "sccmb", dev);
++  if (status) {
++    printk(KERN_WARNING "Can't get interrupt #%d\n", dev->irq);
++    sccmb_unmap(dev);
++    return status;
++  }
++
++  /* Assign the hardware address of the board (6 octets for Ethernet)
++   * Note that the first octet of ethernet multicast addresses is odd
++   */
++  memcpy(dev->dev_addr, "\0MPB_0", ETH_ALEN);
++    
++  netif_start_queue(dev);
++  napi_enable(&priv->napi);
++
++  /* If interrupts are not used we immediately add the polling function
++   * to the queue which would otherwise be done through the IRQ handler.
++   */
++  if (noIrq) napi_schedule(&priv->napi);
++
++  return 0;
++}
++
++
++int sccmb_close(struct net_device* dev)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  napi_disable(&priv->napi);
++
++  /* Unmap the SCC resources */
++  free_irq(dev->irq, dev);
++  sccmb_unmap(dev);
++  
++  netif_stop_queue(dev);
++  return 0;
++}
++
++
++
++/*!
++ * Configuration changes (passed on by ifconfig)
++ */
++int sccmb_config(struct net_device* dev, struct ifmap* map)
++{	
++#ifdef DBG_INTERRUPT
++	int i;
++	struct sccmb_priv*          priv = netdev_priv(dev);
++#endif
++
++/* Debugging printout trigger */
++#ifdef DBG_INTERRUPT
++	if (map->base_addr == 0xdeb9) {
++	printk(KERN_INFO "sccmb_config(): got debug trigger! (0x%08x)\n", map->base_addr);
++
++	printk(KERN_DEBUG "APIC_ID  : %lx\n", apic_read(APIC_ID));
++	printk(KERN_DEBUG "APIC_LVT0: %lx\n", apic_read(APIC_LVT0));
++	printk(KERN_DEBUG "APIC_LVT1: %lx\n", apic_read(APIC_LVT1));
++	printk(KERN_DEBUG "APIC_ESR : %lx\n", apic_read(APIC_ESR));
++	for (i=0; i < 8; i++) {
++		printk(KERN_DEBUG "APIC_ISR%i: %lx\n", i, apic_read(APIC_ISR + i*0x10));
++	}
++	for (i=0; i < 8; i++) {
++		printk(KERN_DEBUG "APIC_TMR%i: %lx\n", i, apic_read(APIC_TMR + i*0x10));
++	}
++	for (i=0; i < 8; i++) {
++		printk(KERN_DEBUG "APIC_IRR%i: %lx\n", i, apic_read(APIC_IRR + i*0x10));
++	}
++
++	return 0;
++	}
++#endif
++
++#ifdef DBG_INTERRUPT
++	if (map->base_addr == 0xdeba) {
++	for (i=0; i < 48; i++) {
++		printk(KERN_DEBUG "TX int count to core %i: %i (ReTrig: %i)\n", i, priv->txIntCount[i], priv->txRetriggerCount[i]);
++		priv->txIntCount[i] = 0;
++		priv->txRetriggerCount[i] = 0;
++	}
++	printk(KERN_DEBUG "RX int count: %i\n", priv->rxIntCount);
++	priv->rxIntCount = 0;
++	
++	return 0;
++	}
++#endif
++
++#ifdef DBG_INTERRUPT
++	if (map->base_addr == 0xdebb) {
++	  if (pingPongTarget > 0) {
++	    printk(KERN_DEBUG "Triggering Ping Pong to core %i\n", pingPongTarget);
++	    sccmb_trigger_irq(dev, pingPongTarget);
++	  }
++
++	return 0;
++	}
++#endif
++
++
++  /* Can't act on a running interface */
++  if (dev->flags & IFF_UP) return -EBUSY;
++
++  /* Don't allow changing the I/O address */
++  if (map->base_addr != dev->base_addr) {
++    printk(KERN_WARNING "sccmb: Can't change I/O address\n");
++    return -EOPNOTSUPP;
++  }
++
++  /* Allow changing the IRQ */
++  if (map->irq != dev->irq) {
++    dev->irq = map->irq;
++    /* request_irq() is delayed to open-time */
++  }
++
++  /* ignore other fields */
++  return 0;
++}
++
++
++struct sccmbx_rx {
++	struct net_device* dev;
++	u8 sourceIp;
++	u8 offset;
++	int len;
++	int cleared;
++	void* mpb_address;
++	void* mpb_start;
++};
++
++/* Clear receive descriptor */
++void sccmbx_clear_rx(struct sccmbx_rx* rx)
++{
++  if (!rx->cleared) {
++    sccmb_clear_descriptor(rx->dev, rx->sourceIp);
++    rx->cleared = 1;
++  }
++}
++EXPORT_SYMBOL(sccmbx_clear_rx)
++
++/* Get pid of source node of message */
++int sccmbx_get_rx_source(struct sccmbx_rx* rx)
++{
++  return rx->sourceIp - 1;
++}
++EXPORT_SYMBOL(sccmbx_get_rx_source)
++
++/* Get pointer(s) to body of received packet. This routine can optionally
++ * allocate an sk_buff if the caller needs to have the packet data in virtually-
++ * continuous storage.
++ *
++ * If need_skb is set to 0, the pointers to the packet's contents are simply
++ * stored in the sccmbx_bufx; the packet is not acknowledged, and no additional
++ * memory allocation is needed. The routine is guaranteed to return 1 (SUCCESS)
++ * in this case.
++ * This mode is useful when receiving packets must not fail due to low-memory
++ * situations, but the caller needs to be able to parse packets that may be
++ * broken into two fragments (in case they overlap the end of our ring buffer).
++ *
++ * If need_skb is set to anything else, an sk_buff is allocated, the packet's
++ * contents are copied, and the packet is acknowledged. If memory allocation
++ * fails, the routine returns 0, and the packet is not acknowledged.
++ *
++ * Irrespective of the value of need_skb, caller should always invoke
++ * sccmbx_retrieve_packet_body_cleanup when they are done with the packet.
++ *
++ * Please note that sccmbx_retrieve_packet_body[_cleanup] do not mark the packet
++ * as received at the sending node if allocating an sk_buff fails. If the caller
++ * wants to drop the packet completely without having the kernel try to re-
++ * deliver it, the caller needs to call sccmbx_clear_rx explicitly if the call
++ * to sccmbx_retrieve_packet_body fails.
++ */
++int sccmbx_retrieve_packet_body(struct sccmbx_rx* rx, struct sccmbx_bufx* bufx, int need_skb)
++{
++  int                         len = rx->len;
++  void*                       mpb_address = rx->mpb_address;
++  void*                       mpb_start = rx->mpb_start;
++  struct sccmb_priv*          priv = netdev_priv(rx->dev);
++  struct sk_buff*             skb = NULL;
++  int                         headroom;
++  int                         byteCount;
++  unsigned char*              local_mem;
++
++  /* Clear the returned sccmbx_bufx structure */
++  memset(bufx, 0, sizeof(struct sccmbx_bufx));
++
++  /* First calculate how much data we can fetch before the wrap-around
++   * occurs so we can determine how much to copy in the first run. Note
++   * that the headroom includes the header bytes as the entire packet
++   * is cacheline aligned!
++   */
++  headroom = (priv->mpb_buffersize - rx->offset) * SCC_CLINE_SIZE - SCCMBX_HLEN;
++  byteCount = len;
++  if (headroom < byteCount) {
++    byteCount = headroom;
++  }
++
++  /* Save pointers into the message buffer in our sccmbx_bufx structure */
++  bufx->len = len;
++  bufx->f[0].p = mpb_address;
++  bufx->f[0].len = byteCount;
++  if (byteCount < len) {
++    bufx->f[1].p = mpb_start;
++    bufx->f[1].len = len - byteCount;
++  }
++
++  /* If the caller does not need an skb, we are done now. */
++  if (!need_skb) {
++    return 1;
++  }
++
++  /* Build a skb for the packet data so upper layers can handle it
++   * Note that IP headers should be aligned on 16B boundaries!
++   */
++  skb = dev_alloc_skb(len);
++  if (!skb) {
++    return 0;
++  }
++
++  /* IP headers should be aligned on 16B boundaries, i.e. we just reserve the
++   * payload area and do not prepend the header bytes which are not used
++   * anymore.
++   */
++  local_mem = skb_put(skb, len);
++
++  /* Copy the packet data (without the header) into the buffer. Because 
++   * of the circular buffer implementation we may have to do it in 2 steps.
++   */
++  memcpy(skb->data, (void*)mpb_address, byteCount);
++
++#ifdef DBG_PACKET_TRACE
++/* Store the entire packet (including header bytes) also in the trace buffer */
++memcpy((void*)(priv->packetTrace + 1024*1024 + priv->rxTracePtr), (void*)(mpb_address-SCCMBX_HLEN), byteCount+SCCMBX_HLEN);
++priv->rxTracePtr += byteCount+SCCMBX_HLEN;
++if (priv->rxTracePtr > 1024*1024-2048) priv->rxTracePtr = 0;
++#endif
++  
++  /* Finish with the rest if we could not copy the entire packet */
++  if (byteCount < len) {
++    memcpy(skb->data+byteCount, mpb_start, len-byteCount);
++#ifdef DBG_PACKET_TRACE
++memcpy((void*)(priv->packetTrace + 1024*1024 + priv->rxTracePtr), mpb_start, len-byteCount);
++priv->rxTracePtr += len-byteCount;
++if (priv->rxTracePtr > 1024*1024-2048) priv->rxTracePtr = 0;
++#endif
++  }
++
++#ifdef DBG_PACKET_TRACE
++/* Align the rx trace pointer to cacheline boundaries */
++while (priv->rxTracePtr % SCC_CLINE_SIZE) priv->rxTracePtr++;
++#endif
++
++  /* Clear the descriptor as we no longer need the message buffer content */
++  sccmbx_clear_rx(rx);
++
++  /* Write metadata, and then pass to the receive level */
++  skb->dev        = rx->dev;
++  skb_set_transport_header(skb, 0);
++  skb_set_network_header(skb, 0);
++  skb_set_mac_header(skb, 0);
++  skb->protocol   = htons(ETH_P_IP);
++  skb->pkt_type   = PACKET_HOST;
++  skb->ip_summed  = CHECKSUM_UNNECESSARY;
++
++  bufx->skb = skb;
++
++  return 1;
++}
++EXPORT_SYMBOL(sccmbx_retrieve_packet_body)
++
++/* Mark the skb referred to by the sccmbx_bufx structure as consumed. After this
++ * call, sccmbx_retrieve_packet_body_cleanup will not free the skb.
++ */
++void sccmbx_retrieve_skb_consumed(struct sccmbx_bufx* bufx)
++{
++  bufx->skb = NULL;
++}
++EXPORT_SYMBOL(sccmbx_retrieve_skb_consumed)
++
++/* Cleanup packet state after sccmbx_retrieve_packet_body has successfully read
++ * a packet. This routine should be invoked with the same values for rx and bufx
++ * than sccmbx_retrieve_packet_body.
++ *
++ * Please note that sccmbx_retrieve_packet_body[_cleanup] do not mark the packet
++ * as received at the sending node if allocating an sk_buff fails. If the caller
++ * wants to drop the packet completely without having the kernel try to re-
++ * deliver it, the caller needs to call sccmbx_clear_rx explicitly if the call
++ * to sccmbx_retrieve_packet_body fails.
++ */
++void sccmbx_retrieve_packet_body_cleanup(struct sccmbx_rx* rx, struct sccmbx_bufx* bufx)
++{
++  /* If we did not use an sk_buff for this packet, the send descriptor has not
++   * been cleared yet because the message buffer content was still needed. In
++   * this case, clear the descriptor now. sccmbx_clear_rx makes sure not to
++   * clear more than once, so this call is safe even if an sk_buff was used. */
++  sccmbx_clear_rx(rx);
++
++  /* If there was an sk_buff allocated, free it now */
++  if (bufx->skb != NULL) {
++    dev_kfree_skb_any(bufx->skb);
++    bufx->skb = NULL;
++  }
++}
++EXPORT_SYMBOL(sccmbx_retrieve_packet_body_cleanup)
++
++/*
++ * Receive a packet for the NET subsystem
++ */
++static void sccmbx_rx_net(struct sccmbx_rx* rx, struct sccmbx_hdr* header, int len)
++{
++  struct sccmb_priv*          priv = netdev_priv(rx->dev);
++  struct sccmbx_bufx          bufx;
++
++  /* Check for reasonable sizes before processing the data to
++   * prevent nasty memory overflow errors.
++   */
++  if (len < sizeof(struct iphdr)) {
++    /* Simply drop the packet */
++    sccmbx_clear_rx(rx);
++    
++    printk(KERN_NOTICE "sccmb_rx(): illegal packet length %d => no IP hdr\n", len);
++    priv->stats.rx_dropped++;
++    return;
++  }
++
++  /* Get packet */
++  if (!sccmbx_retrieve_packet_body(rx, &bufx, 1)) {
++    if (printk_ratelimit() )
++      printk(KERN_NOTICE "sccmb rx: low on mem - packet dropped\n");
++
++    /* Note: since we do not clear the offset descriptor we do not trigger
++     * a retransmission and the packet will eventually be processed.
++     */
++    priv->stats.rx_dropped++;
++    return;
++  }
++
++  /* Update the interface statistics (also count the header bytes) */
++  priv->stats.rx_packets++;
++  priv->stats.rx_bytes += SCCMBX_HLEN+len;
++  rx->dev->last_rx = jiffies;
++
++  /* Deliver packet to upper layer */
++#ifdef SCCMB_NO_NAPI
++    netif_rx(bufx.skb);
++#else
++    netif_receive_skb(bufx.skb);
++#endif
++  sccmbx_retrieve_skb_consumed(&bufx);
++
++  /* Cleanup. This really is a NOP, as the data will always be copied into an
++   * sk_buff for the NET subsystem. */
++  sccmbx_retrieve_packet_body_cleanup(rx, &bufx);
++}
++
++static sccmbx_rx_proc sccmbx_rx_procs[256] = { 0 };
++
++static void __sccmbx_set_rx_proc(u8 subsys, sccmbx_rx_proc rx_proc)
++{
++	char subsys_name[16];
++	switch (subsys) {
++	case SCCMBX_SUBSYS_NET:
++		strcpy(subsys_name, "NET");
++		break;
++	case SCCMBX_SUBSYS_SHM:
++		strcpy(subsys_name, "SHM");
++		break;
++	default:
++		sprintf(subsys_name, "%d", subsys);
++		break;
++	}
++	printk(KERN_INFO "sccmbx: setting rx_proc for subsystem %s", subsys_name);
++	print_symbol(" to %s\n", (unsigned long)rx_proc);
++
++	sccmbx_rx_procs[subsys] = rx_proc;
++}
++
++/* Set receive callback for messages to a specific subsystem ID */
++int sccmbx_set_rx_proc(u8 subsys, sccmbx_rx_proc rx_proc)
++{
++	if (unlikely(subsys == SCCMBX_SUBSYS_NET)) {
++		return -EINVAL;
++	}
++
++	__sccmbx_set_rx_proc(subsys, rx_proc);
++	return 0;
++}
++EXPORT_SYMBOL(sccmbx_set_rx_proc)
++
++/*
++ * Receive a packet: retrieve, encapsulate and pass over to upper levels
++ */
++void sccmb_rx(struct net_device* dev, u8 sourceIp, u8 offset)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  void*                       mpb_start;
++  void*                       mpb_address;
++  int                         len, subsys;
++
++  struct sccmbx_hdr*          header;
++  struct sccmbx_rx            rx;
++  sccmbx_rx_proc              rx_proc;
++
++  /* Get address of message buffer of sending node */
++  mpb_start = priv->mpb[sourceIp-1];
++
++  /* Calculate the address of the packet */
++  mpb_address  = mpb_start + offset*SCC_CLINE_SIZE;
++  
++  /* The packet length is stored in the first 2 bytes but does not include
++   * the header.
++   */
++  header = (struct sccmbx_hdr*)mpb_address;
++  len = 256*( header->len[0] )
++      +     ( header->len[1] );
++  subsys = header->subsys;
++  mpb_address += SCCMBX_HLEN;
++
++  /* Check for reasonable sizes before processing the data to
++   * prevent nasty memory overflow errors.
++   */
++  if (len > dev->mtu) {
++    /* Simply drop the packet */
++    sccmb_clear_descriptor(dev, sourceIp);
++    
++    printk(KERN_NOTICE "sccmb_rx(): illegal packet length %d => too long\n", len);
++    priv->stats.rx_dropped++;
++    return;
++  }
++  
++  /* We need to hand the packet over to the responsible subsystem now. Check
++   * that the subsystem ID is in the allowed range and that the receive function
++   * has been registered. */
++  if (unlikely((subsys < 0) || (subsys >= sizeof(sccmbx_rx_procs) / sizeof(sccmbx_rx_procs[0])))) {
++    sccmb_clear_descriptor(dev, sourceIp);
++
++    printk(KERN_NOTICE "sccmbx_rx: invalid target subsystem id %d.\n", subsys);
++    priv->stats.rx_dropped++;
++    return;
++  }
++
++  rx_proc = sccmbx_rx_procs[subsys];
++  if (unlikely(!rx_proc)) {
++    sccmb_clear_descriptor(dev, sourceIp);
++
++    printk(KERN_NOTICE "sccmbx_rx: subsystem id %d not registered.\n", subsys);
++    priv->stats.rx_dropped++;
++    return;
++  }
++
++  /* Build external receive descriptor and invoke the callback */
++  memset(&rx, 0, sizeof(rx));
++  rx.dev = dev;
++  rx.sourceIp = sourceIp;
++  rx.offset = offset;
++  rx.len = len;
++  rx.mpb_address = mpb_address;
++  rx.mpb_start = mpb_start;
++
++#ifdef CONFIG_SCCMBX_DUMP_NONNET_PACKETS
++  if (subsys != SCCMBX_SUBSYS_NET) {
++    printk(KERN_INFO "sccmbx_rx: received packet for subsystem %d, len=%x\n", subsys, len);
++  }
++#endif
++  rx_proc(&rx, header, len);
++}
++
++
++
++/*
++ * Check the receive descriptors and return the IP address if a valid
++ * packet offset is found. Note that a round robin scheme is used to
++ * ensure fairness.
++ */
++static int sccmb_nextRxPacket(struct net_device* dev, u8* offset)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  static u8                   lastSource = 0;
++  u8                          source;
++  u8                          i;
++  u8                          nrOfDescriptors;
++  int                         desc_address;
++  
++  nrOfDescriptors = multiPacket ? 4*SCC_CORECOUNT : SCC_CORECOUNT;
++  
++  *offset = 0xFF;
++  for (i=0; i<nrOfDescriptors; i++) {
++    /* Calculate the descriptor address for the packet transfer from the
++     * given IP address to our node. Add 1 to the last found packet source
++     * so it gets processed with least priority.
++     */
++    source = (1+lastSource + i) % nrOfDescriptors;
++    desc_address = sccmb_get_desc_address(dev, 1+source, priv->localIp);
++    
++    /* Check for a valid receive descriptor */
++    *offset = *((u8*)desc_address);
++    if (*offset < 0xFF) {
++      /* Store the descriptor slot where we found the packet */
++      priv->mpb_rxDesc[source%SCC_CORECOUNT] = source/SCC_CORECOUNT;
++      
++      /* Remember the core number and return the IP address = 1+core number */
++      lastSource = source;
++      return 1 + source%SCC_CORECOUNT;
++    }
++  }
++  
++  /* Return 0 if no packet was found */
++  return 0;
++}
++
++
++/*
++ * The poll implementation processing all incoming packets
++ */
++static int sccmb_poll(struct napi_struct* napi, int to_do)
++{
++  struct sccmb_priv*          priv = container_of(napi, struct sccmb_priv, napi);
++  struct net_device*          dev = napi->dev;
++  int                         npackets = 0;
++  int                         quota = to_do;
++  u8                          sourceIp;
++  u8                          offset = 0;
++
++  /* Process up to quota packets from the receive queue */
++  while (npackets<quota) {
++    /* Flush the message buffer so we get up to date descriptor info */
++    CL1FLUSHMB;
++    sourceIp = sccmb_nextRxPacket(dev, &offset);
++    
++    /* Call the standard receive handler if there is a packet */
++    if (sourceIp) {
++      /* In case of level-triggered interrupts clear it now */
++      if (!edgeIrq) sccmb_clear_irq(dev, priv->localIp);
++      
++      sccmb_rx(dev, sourceIp, offset);
++      npackets++;
++    }
++    /* Else perform a clean exit */
++    else {
++
++      /* If interrupts are disabled we hae to remain in the polling function,
++       * i.e. we may signal that we are done with packet processing but must
++       * not remove us from the queueing list via netif_rx_complete().
++       */
++      if (noIrq) {
++        break;
++      }
++      
++      /* Tell the system we are done with polling */
++      napi_complete(&priv->napi);
++
++      /* Do not use enable_irq(dev->irq); since we might loose enables --> INT locked up */      
++      unset_lapic_mask(APIC_LVT0, dev->irq);
++
++      /* The interrupt was cleared before the Rx packet was processed,
++       * i.e. it will be re-set if another packet arrived since the last
++       * check. Thus the polling function will be scheduled again as
++       * soon as we enable interrupts again so we can safely return.
++       */
++      break;
++    }
++  }
++  
++  return npackets;
++}
++
++
++
++/*
++ * A NAPI interrupt handler since we can receive multiple packets 
++ * (from different sources) with a single interrupt.
++ */
++static irqreturn_t sccmb_interrupt(int irq, void* dev_id)
++{
++  struct net_device*          dev = (struct net_device*)dev_id;
++  struct sccmb_priv*          priv = netdev_priv(dev);
++
++#ifdef SCCMB_NO_NAPI
++  u8                          sourceIp = 0; 
++  u8                          offset = 0; 
++#endif
++
++  /* Paranoid */
++  if (!dev) {
++    printk(KERN_DEBUG "sccmb interrupt %d for unknown device\n", irq);
++    return IRQ_NONE;
++  }
++
++#ifdef DBG_INTERRUPT
++  priv->rxIntCount++;
++  
++  if (pingPongTarget > 0) {
++    sccmb_trigger_irq(dev, pingPongTarget);
++    return IRQ_HANDLED;
++  }
++#endif
++
++#ifdef SCCMB_NO_NAPI
++  CL1FLUSHMB;
++  sourceIp = sccmb_nextRxPacket(dev, &offset);
++  while (sourceIp) {
++    /* Call the standard receive handler if there is a packet */
++    sccmb_rx(dev, sourceIp, offset);
++    /* Flush the message buffer so we get up to date descriptor info */
++    CL1FLUSHMB;
++    sourceIp = sccmb_nextRxPacket(dev, &offset);
++  }
++  return IRQ_HANDLED;
++#else
++
++  /* Disable further interrupts and start the polling process. 
++   * We have to use the nosync version since we are inside the interrupt
++   * service routine!
++   * Do not use disable_irq_nosync(dev->irq); since we might loose enables --> INT locked up
++   */
++
++  set_lapic_mask(APIC_LVT0, dev->irq);
++
++  napi_schedule(&priv->napi);
++  return IRQ_HANDLED;
++#endif
++}
++
++
++
++
++/*
++ * Transmit a packet (low level interface)
++ * This function deals with HW details, i.e. it writes the packet
++ * into the message buffer and informs the destination.
++ */
++int sccmb_get_destination(struct net_device* dev, struct sccmbx_bufx* bufx, u8* destIp)
++{
++  struct iphdr*               ipHeader;
++  char                        packet_buf[SCCMBX_HLEN > sizeof(struct iphdr) ? SCCMBX_HLEN : sizeof(struct iphdr)];
++  u32*                        destAddr;
++  u8                          destCore;
++  u8                          netAddr[4];
++  int                         i;
++  struct sccmbx_hdr*          header;
++
++  *destIp = -1;
++
++  /* Verify that the packet contains at least our hardware header */
++  if (bufx->len < dev->hard_header_len) {
++    return 0;
++  }
++
++  /* Check whether we have an explicit destination */
++  header = (struct sccmbx_hdr*)packet_buf;
++  sccmbx_copy_from_bufx(header, bufx, 0, sizeof(struct sccmbx_hdr));
++  if (header->subsys != SCCMBX_SUBSYS_NET) {
++#ifdef CONFIG_SCCMBX_DUMP_NONNET_PACKETS
++    printk(KERN_INFO "sccmbx: transferring packet for subsystem %d, len = %x...\n", header->subsys, bufx->len);
++    sccutil_dump_buffer(bufx->f[0].p, bufx->f[0].len);
++    if (bufx->f[1].len > 0) {
++      sccutil_dump_buffer(bufx->f[1].p, bufx->f[1].len);
++    }
++#endif
++    destCore = header->dest;
++    if ((destCore < 1) || (destCore > 48)) {
++      printk(KERN_ERR "sccmbx: packet for subsystem %d specifies invalid destination %d\n",
++		header->subsys, destCore);
++      destCore = 1;
++    }
++    *destIp = destCore;
++    return 1;
++  }
++
++  /* This is a network packet, so we assume it contains an IP header */
++  if (bufx->len < dev->hard_header_len+sizeof(struct iphdr)) {
++    return 0;
++  }
++
++  /* Extract the destination address from the IP header.
++   * The last (4th) octet is interpreted as core ID.
++   */
++  ipHeader  = (struct iphdr*)packet_buf;
++  sccmbx_copy_from_bufx(ipHeader, bufx, dev->hard_header_len, sizeof(struct iphdr));
++  destAddr  = &(ipHeader->daddr);
++  destCore  = ((u8*)destAddr)[3];
++
++  /* Compare the network part to check if we have a local destination.
++   * Note that the module parameter is expected in A.B.C.D format to make
++   * it easier to modify so the values have to be reversed.
++   * In case a remote network is detected, the core number of the router
++   * is used as destination.
++   */
++  for (i=0; i<4; i++) netAddr[3-i] = (ownIpAddress >> 8*i) & 0xFF;
++  for (i=0; i<3; i++) {
++    if (((u8*)destAddr)[i] != netAddr[i]) destCore = routerIpAddress & 0xFF;
++  }
++  
++  /* Make sure that only valid local IP addresses are returned */
++  if ((destCore < 1) || (destCore > 48)) destCore = 1;
++  *destIp = destCore;
++
++  return 1;
++}
++
++static int sccmb_hw_tx(struct net_device* dev, struct sccmbx_bufx* bufx, u8 destIp)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  u8                          clen;
++  int                         i;
++  int                         ptr;
++  int                         owner;
++  int                         slot;
++
++  /* Determine how many cache lines we need to store the message buffer data */
++  clen = (bufx->len / SCC_CLINE_SIZE);
++  if (bufx->len % SCC_CLINE_SIZE) clen++;
++  
++  /* Check whether there is enough space in the circular buffer */
++  for (i=0; i<clen; i++) {
++    ptr = (priv->mpb_next + i) % priv->mpb_buffersize;
++    owner = priv->mpb_map[ptr] & 0x3F;
++    slot  = priv->mpb_map[ptr] >> 6;
++    if (sccmb_tx_pending(dev, owner, slot) ) return 1;
++    
++    /* This slot will be used for the new packet transfer - also mark the
++     * the descriptor slot that is being used.
++     */
++    priv->mpb_map[ptr] = (priv->mpb_nextDesc[destIp-1] << 6) + destIp;
++  }
++  
++  /* Copy the data into the circular buffer */
++  ptr  = (int)(priv->mpb[priv->localIp-1]);
++  ptr += (priv->mpb_next * SCC_CLINE_SIZE);
++  if (clen + priv->mpb_next > priv->mpb_buffersize) {
++    /* First fill up the remaining space to the top of the buffer */
++    i = (priv->mpb_buffersize - priv->mpb_next) * SCC_CLINE_SIZE;
++    sccmbx_copy_from_bufx((void*)ptr, bufx, 0, i);
++    
++    /* Copy the remaining bytes to the start */
++    ptr  = (int)(priv->mpb[priv->localIp-1]);
++    sccmbx_copy_from_bufx((void*)ptr, bufx, i, bufx->len-i);
++  }
++  else {
++    /* Simply copy all the data since there is enough space without
++     * pointer roll-over.
++     */
++    sccmbx_copy_from_bufx((void*)ptr, bufx, 0, bufx->len);
++  }
++
++#ifdef DBG_PACKET_TRACE
++/* Store the packet in the trace buffer */
++sccmbx_copy_from_bufx((void*)(priv->packetTrace + priv->txTracePtr), bufx, 0, bufx->len);
++priv->txTracePtr += clen*SCC_CLINE_SIZE;
++if (priv->txTracePtr > 1024*1024-2048) priv->txTracePtr = 0;
++#endif    
++  /* Set the descriptor on the receiver side
++   * Since different addresses are used, this automatically flushes the
++   * data inside the write-combining buffer so the receiver sees up to
++   * date message buffer content.
++   */
++  sccmb_set_descriptor(dev, destIp, priv->mpb_next);
++  
++  /* Update the pointer to the next circular buffer slot and flag the
++   * pending transmission.
++   */
++  slot = priv->mpb_nextDesc[destIp-1];
++  priv->mpb_next = (priv->mpb_next + clen) % priv->mpb_buffersize;
++  priv->mpb_busy[slot*SCC_CORECOUNT + destIp-1] = jiffies;
++
++  /* Interrupt the receiver so it starts processing the packet */
++  sccmb_trigger_irq(dev, destIp);
++  
++  /* Increment the next descriptor slot for the next transmission in case
++   * multiple packets may be in flight.
++   */
++  if (multiPacket)
++    priv->mpb_nextDesc[destIp-1] = (priv->mpb_nextDesc[destIp-1] + 1) % 4;
++      
++  /* Transmission succeeded so save the timestamp of the transmission and
++   * update the statistics
++   */
++  dev->trans_start = jiffies;
++
++  priv->stats.tx_packets++;
++  priv->stats.tx_bytes += bufx->len;
++  
++  return 0;
++}
++
++
++
++static void sccmbx_init_header(struct sccmbx_hdrbuf* buf, u8 subsys, u8 dest,
++			       unsigned int len)
++{
++  struct sccmbx_hdr* header = (struct sccmbx_hdr*)buf;
++
++  memset(header, 0, SCCMBX_HLEN);
++
++  /* Store the length starting with the MSBs */
++  header->len[0] = len/256;
++  header->len[1] = len%256;
++
++  /* Store other information */
++  header->subsys = subsys;
++  header->dest = dest;
++  header->src = sccsys_get_pid();
++}
++
++/* Initialize struct bufx with data from struct sk_buff */
++static void sccmbx_init_transmit_bufx_from_skb(struct sccmbx_bufx* bufx, struct sk_buff* skb)
++{
++	memset(bufx, 0, sizeof(struct sccmbx_bufx));
++	bufx->len = skb->len;
++	bufx->f[0].p = skb->data;
++	bufx->f[0].len = skb->len;
++}
++
++/* Initialize struct bufx for transmitting a raw packet */
++void sccmbx_init_transmit_bufx(struct sccmbx_bufx* bufx, struct sccmbx_hdrbuf* hdr, u8 subsys, u8 dest, void* data, int len)
++{
++	memset(bufx, 0, sizeof(struct sccmbx_bufx));
++	bufx->len = SCCMBX_HLEN + len;
++	bufx->f[0].p = hdr;
++	bufx->f[0].len = SCCMBX_HLEN;
++	bufx->f[1].p = data;
++	bufx->f[1].len = len;
++	sccmbx_init_header(hdr, subsys, dest + 1, len);
++}
++EXPORT_SYMBOL(sccmbx_init_transmit_bufx);
++
++
++/* Transmit a packet described by a struct sccmbx_bufx */
++static int sccmb_tx_bufx(struct net_device* dev, struct sccmbx_bufx* bufx)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  u8                          destIp;
++  u8                          slot = priv->mpb_nextDesc[destIp-1];
++  u8                          i;
++  
++  //printk(KERN_DEBUG "sccmb_tx_bufx(): start\n");
++
++  /* Perform a sanity check on the packet data, i.e. silently drop packets
++   * that are either too short or send to an illegal IP address by indicating
++   * success without executing any data transfer operations.
++   */
++  if (!sccmb_get_destination(dev, bufx, &destIp)) {
++    printk(KERN_NOTICE "sccmb_tx(): Illegal packet (%i octets to IP %d)\n", 
++                       bufx->len, destIp);
++    priv->stats.tx_errors++;
++    return 0;
++  }
++
++  /* Check if another transmission to the same destination is pending */
++  if (sccmb_tx_pending(dev, destIp, -1) ) {
++    /* If too much time elapsed since the previous transmission the receiver
++     * is probably dead and we drop the packet
++     */
++    if (jiffies > priv->mpb_busy[slot*SCC_CORECOUNT + destIp-1] + timeout) {
++      printk(KERN_NOTICE "sccmb_tx(): Timeout at destination %d\n", destIp);
++      
++      /* Also free all cache lines holding data for that destination */
++      for (i=0; i<priv->mpb_buffersize; i++) {
++        if ((priv->mpb_map[i]) == ((slot<<6)+destIp) )
++          priv->mpb_map[i] = 0;
++      }
++      
++      priv->stats.tx_errors++;
++      return 0;
++    }
++    /* Else signal the kernel that the transmission failed so it can 
++     * reschedule 
++     */
++    return 1;
++  }
++  
++  /* Now perform the low level data transfer and return the result. If it
++   * failed, e.g. because there is not enough space in the MPB, the kernel
++   * will retry transmission.
++   */
++  return sccmb_hw_tx(dev, bufx, destIp);
++}
++
++/*
++ * Transmit a packet (called by the kernel)
++ */
++int sccmb_tx(struct sk_buff* skb, struct net_device* dev)
++{
++  int                         res;
++  struct sccmbx_bufx          bufx;
++  
++  //printk(KERN_DEBUG "sccmb_tx(): start\n");
++  
++  /* Convert the socket buffer to a struct sccmbx_bufx */
++  sccmbx_init_transmit_bufx_from_skb(&bufx, skb);
++
++  /* Try to transfer packet */
++  res = sccmb_tx_bufx(dev, &bufx);
++  
++  /* Free socket buffer only if transmission was successful */
++  if (res == 0) {
++    dev_kfree_skb_any(skb);
++  }
++  return res;
++}
++
++/* Transmit a raw packet described by a struct bufx */
++int sccmbx_transmit_bufx(struct sccmbx_bufx* bufx)
++{
++  return -EINVAL;
++}
++EXPORT_SYMBOL(sccmbx_transmit_bufx);
++
++
++/*
++ * Deal with a transmit timeout.
++ */
++void sccmb_tx_timeout(struct net_device* dev)
++{
++  /* A timeout occurs if the queue was stopped because too many packet
++   * transfers were pending. Let's simply resume regular packet processing
++   * in the hope that the receiver have cleared their backlog.
++   */
++  //printk(KERN_DEBUG "sccmb_tx_timeout()\n");
++  
++  netif_wake_queue(dev);
++  return;
++}
++
++
++
++/*
++ * ioctl commands
++ */
++int sccmb_ioctl(struct net_device* dev, struct ifreq* rq, int cmd)
++{
++  /*
++   * Custom commands
++   */
++  return 0;
++}
++
++
++
++/*
++ * Return statistics to the caller
++ */
++struct net_device_stats* sccmb_stats(struct net_device* dev)
++{
++  struct sccmb_priv* priv = netdev_priv(dev);
++  
++  return &(priv->stats);
++}
++
++
++
++/*
++ * The "change_mtu" method is usually not needed.
++ * If you need it, it must be like this.
++ */
++int sccmb_change_mtu(struct net_device* dev, int new_mtu)
++{
++  struct sccmb_priv*          priv = netdev_priv(dev);
++  unsigned long               flags;
++  spinlock_t*                 lock = &(priv->lock);
++
++  /* check ranges */
++  if ((new_mtu < 68) || (new_mtu > 1500)) return -EINVAL;
++
++  /*
++   * Simply accept the value
++   */
++  spin_lock_irqsave(lock, flags);
++  dev->mtu = new_mtu;
++  spin_unlock_irqrestore(lock, flags);
++  
++  return 0;
++}
++
++
++
++/*
++ * This function is called to fill up an eth header, since ARP is not
++ * available on the interface.
++ */
++int sccmb_rebuild_header(struct sk_buff* skb)
++{
++  printk(KERN_WARNING "sccmb_rebuild_header() called - ignoring\n");
++
++  return 0;
++}
++
++static void sccmbx_create_header(struct sk_buff* skb, struct net_device* dev,
++				 u8 subsys, u8 dest, unsigned int len)
++{
++  struct sccmbx_hdr* header;
++
++  /* Prepend the message header */
++  header = (struct sccmbx_hdr*)skb_push(skb, SCCMBX_HLEN);
++  sccmbx_init_header((struct sccmbx_hdrbuf*)header, subsys, dest, len);
++}
++
++int sccmb_header(struct sk_buff* skb, struct net_device* dev,
++                 unsigned short type, const void* daddr, const void* saddr,
++                 unsigned int len)
++{
++  /* Currently, we do not support anything but IP */
++  if (type != ETH_P_IP) {
++    return -dev->hard_header_len;
++  }
++
++  /* Create header. We always use SCCMBX_SUBSYS_NET when going through the
++   * header_ops callback. */
++  sccmbx_create_header(skb, dev, SCCMBX_SUBSYS_NET, 0, len);
++      
++  return (dev->hard_header_len);
++}
++
++/* Allocate a packet */
++struct sk_buff* sccmbx_allocate_packet(u8 subsys, u8 dest, int len, void* *body)
++{
++	struct sk_buff* skb;
++	struct net_device* dev = sccmb_dev;
++
++	/* Verify parameters */
++	if (!dev || (subsys == SCCMBX_SUBSYS_NET) || (len < 0) || (len>dev->mtu)) {
++		return NULL;
++	}
++
++	/* Allocate packet */
++	skb = alloc_skb(len + LL_ALLOCATED_SPACE(dev) + 15, GFP_KERNEL);
++	if (!skb) {
++		return NULL;
++	}
++	skb_reserve(skb, LL_RESERVED_SPACE(dev));
++	*body = skb_put(skb, len);
++
++	/* Prepare header */
++	sccmbx_create_header(skb, dev, subsys, dest + 1, len);
++
++	skb->dev = dev;
++	skb->protocol = 0;
++
++	return skb;
++}
++EXPORT_SYMBOL(sccmbx_allocate_packet)
++
++static const struct net_device_ops sccmb_netdev_ops = {
++	.ndo_open		= sccmb_open,
++	.ndo_stop		= sccmb_close,
++	.ndo_set_config		= sccmb_config,
++	.ndo_start_xmit		= sccmb_tx,
++	.ndo_do_ioctl	        = sccmb_ioctl,
++	.ndo_get_stats		= sccmb_stats,
++	.ndo_change_mtu		= sccmb_change_mtu,
++	.ndo_tx_timeout		= sccmb_tx_timeout,
++};
++
++static const struct header_ops sccmb_header_ops = {
++	.create			= sccmb_header,
++	.rebuild		= sccmb_rebuild_header,
++};
++
++/*
++ * The init function (sometimes called probe).
++ * It is invoked by register_netdev()
++ */
++void sccmb_init(struct net_device* dev)
++{
++  struct sccmb_priv* priv;
++
++  /*
++   * Then initialize the priv field. This encloses the statistics
++   * and a few private fields.
++   */
++  priv = netdev_priv(dev);
++  memset(priv, 0, sizeof(struct sccmb_priv));
++  
++  spin_lock_init(&priv->lock);
++
++  /* Get meaningful default values */
++  ether_setup(dev);
++
++  /* Set the correct function pointers */
++  dev->netdev_ops = &sccmb_netdev_ops;
++  dev->header_ops = &sccmb_header_ops;
++  
++  dev->watchdog_timeo   = timeout;
++
++  /* Configure NAPI interrupt handling because we may receive multiple
++   * packets per interrupt. Note that Lehnix/MCEMU set LVT0's vector to 4.
++   */
++  netif_napi_add(dev, &priv->napi, sccmb_poll, 16);
++  dev->irq              = 4;
++
++  /* Keep the default flags; just add NOARP */
++  dev->flags           |= IFF_NOARP;
++  /* Checksum checks are not required */
++  // dev->features        |= NETIF_F_NO_CSUM;
++  /* Disable caching of (nonexistent) ARP replies */
++  //dev->hard_header_cache = NULL;
++  /* Change the hardware header as there is no need for an Ethernet format */
++  dev->hard_header_len    = SCCMBX_HLEN;
++  dev->addr_len           = 0;
++}
++
++
++
++/*
++ * Finally, the module stuff
++ */
++void sccmb_cleanup(void)
++{
++  if (sccmb_dev) {
++    unregister_netdev(sccmb_dev);
++    free_netdev(sccmb_dev);
++    sccmb_dev = NULL;
++  }
++}
++
++
++
++int sccmb_init_module(void)
++{
++  int result;
++
++  /* This driver does only work in a bare-metal environment */
++  if (!scc_bare_metal()) {
++    printk(KERN_INFO "sccmbx: startup in non-SCC or paravirtualized environment.\n");
++    return -EINVAL;
++  }
++
++  __sccmbx_set_rx_proc(SCCMBX_SUBSYS_NET, sccmbx_rx_net);
++
++  /* Allocate the devices */
++  sccmb_dev = alloc_netdev(sizeof(struct sccmb_priv), "mb0", sccmb_init);
++  if (!sccmb_dev) return -ENOMEM;
++
++  result = register_netdev(sccmb_dev);
++  if (result) {
++    printk(KERN_WARNING "sccmb: error %i registering device \"%s\"\n", 
++                        result, sccmb_dev->name);
++    free_netdev(sccmb_dev);
++    return -ENODEV;
++  }
++
++  return 0;
++}
++
++
++
++module_init(sccmb_init_module);
++module_exit(sccmb_cleanup);
+diff -urN linux-3.1.4/drivers/net/sccmbx.h linux-3.1.4-scc/drivers/net/sccmbx.h
+--- linux-3.1.4/drivers/net/sccmbx.h	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/net/sccmbx.h	2011-12-20 15:27:07.618380472 +0100
+@@ -0,0 +1,137 @@
++
++struct sccmbx_hdr {
++	unsigned char len[2];
++	unsigned char dest;
++	unsigned char src;
++	unsigned char subsys;
++} __attribute__((packed));
++
++struct sccmbx_rx;
++
++#define SCCMBX_SUBSYS_NET	0
++#define SCCMBX_SUBSYS_SHM	1
++
++#define SCCMBX_HLEN		16
++
++struct sccmbx_hdrbuf {
++	unsigned char __data[SCCMBX_HLEN];
++};
++
++struct sccmbx_fragment {
++	void* p;
++	int len;
++};
++
++#define SCCMBX_BUFX_FRAGMENTS	2
++struct sccmbx_bufx {
++	int len;
++	struct sk_buff* skb;
++	struct sccmbx_fragment f[SCCMBX_BUFX_FRAGMENTS];
++};
++
++/* Type of receive callback routines */
++typedef void (*sccmbx_rx_proc)(struct sccmbx_rx* rx, struct sccmbx_hdr* header, int len);
++
++
++/* Set receive callback for messages to a specific subsystem ID */
++extern int sccmbx_set_rx_proc(u8 subsys, sccmbx_rx_proc rx_proc);
++
++/* Clear receive descriptor */
++extern void sccmbx_clear_rx(struct sccmbx_rx* rx);
++
++/* Get pid of source node of message */
++extern int sccmbx_get_rx_source(struct sccmbx_rx* rx);
++
++/* Get pointer(s) to body of received packet. This routine can optionally
++ * allocate an sk_buff if the caller needs to have the packet data in virtually-
++ * continuous storage.
++ *
++ * If need_skb is set to 0, the pointers to the packet's contents are simply
++ * stored in the sccmbx_bufx; the packet is not acknowledged, and no additional
++ * memory allocation is needed. The routine is guaranteed to return 1 (SUCCESS)
++ * in this case.
++ * This mode is useful when receiving packets must not fail due to low-memory
++ * situations, but the caller needs to be able to parse packets that may be
++ * broken into two fragments (in case they overlap the end of our ring buffer).
++ *
++ * If need_skb is set to anything else, an sk_buff is allocated, the packet's
++ * contents are copied, and the packet is acknowledged. If memory allocation
++ * fails, the routine returns 0, and the packet is not acknowledged.
++ *
++ * Irrespective of the value of need_skb, caller should always invoke
++ * sccmbx_retrieve_packet_body_cleanup when they are done with the packet.
++ *
++ * Please note that sccmbx_retrieve_packet_body[_cleanup] do not mark the packet
++ * as received at the sending node if allocating an sk_buff fails. If the caller
++ * wants to drop the packet completely without having the kernel try to re-
++ * deliver it, the caller needs to call sccmbx_clear_rx explicitly if the call
++ * to sccmbx_retrieve_packet_body fails.
++ */
++extern int sccmbx_retrieve_packet_body(struct sccmbx_rx* rx, struct sccmbx_bufx* bufx, int need_skb);
++
++/* Mark the skb referred to by the sccmbx_bufx structure as consumed. After this
++ * call, sccmbx_retrieve_packet_body_cleanup will not free the skb.
++ */
++extern void sccmbx_retrieve_skb_consumed(struct sccmbx_bufx* bufx);
++
++/* Cleanup packet state after sccmbx_retrieve_packet_body has successfully read
++ * a packet. This routine should be invoked with the same values for rx and bufx
++ * than sccmbx_retrieve_packet_body.
++ *
++ * Please note that sccmbx_retrieve_packet_body[_cleanup] do not mark the packet
++ * as received at the sending node if allocating an sk_buff fails. If the caller
++ * wants to drop the packet completely without having the kernel try to re-
++ * deliver it, the caller needs to call sccmbx_clear_rx explicitly if the call
++ * to sccmbx_retrieve_packet_body fails.
++ */
++extern void sccmbx_retrieve_packet_body_cleanup(struct sccmbx_rx* rx, struct sccmbx_bufx* bufx);
++
++/* Copy data from struct sccmbx_bufx to regular buffer */
++static inline int sccmbx_copy_from_bufx(void* target, struct sccmbx_bufx* bufx, int offset, int len)
++{
++  int clen = 0, i;
++
++  if (offset < 0 || len < 0 || offset > bufx->len) {
++    VM_BUG_ON(1);
++    return -EINVAL;
++  }
++
++  for (i = 0; (i < SCCMBX_BUFX_FRAGMENTS) && (len > 0); i++) {
++    /* Length of current fragment. If the requested subrange is not contained
++     * in it, simply adjust the offset value for the next fragment and continue.
++     */
++    int flen = bufx->f[i].len;
++    if (offset >= flen) {
++      offset -= flen;
++      continue;
++    }
++
++    /* Adjust flen to reflect the maximum number of bytes that can be copied
++     * from the current fragment. */
++    flen -= offset;
++
++    if (flen > len) {
++      flen = len;
++    }
++
++    /* Copy data, then adjust variables for the next fragment */
++    memcpy(target, bufx->f[i].p + offset, flen);
++    offset = 0;
++    target += flen;
++    clen += flen;
++    len -= flen;
++  }
++
++  VM_BUG_ON(clen < len);
++  return clen;
++}
++
++/* Allocate a packet */
++extern struct sk_buff* sccmbx_allocate_packet(u8 subsys, u8 dest, int len, void* *body);
++
++/* Initialize struct bufx for transmitting a packet */
++extern void sccmbx_init_transmit_bufx(struct sccmbx_bufx* bufx, struct sccmbx_hdrbuf* hdr, u8 subsys, u8 dest, void* data, int len);
++
++/* Transmit a raw packet described by a struct bufx */
++extern int sccmbx_transmit_bufx(struct sccmbx_bufx* bufx);
++
+diff -urN linux-3.1.4/drivers/net/sccpc.c linux-3.1.4-scc/drivers/net/sccpc.c
+--- linux-3.1.4/drivers/net/sccpc.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/net/sccpc.c	2011-12-20 15:27:07.618380472 +0100
+@@ -0,0 +1,792 @@
++/*
++ * sccpc.c -- SCC PC network driver
++ *
++ * Portions Copyright (C) 2009 Intel Corp.
++ *
++ * The code is based on snull.c from the book "Linux Device
++ * Drivers" by Alessandro Rubini and Jonathan Corbet, published
++ * by O'Reilly & Associates.
++ */
++
++/* Notes:
++ * - This driver assumes that the SCC system memory driver is also
++ *   loaded as it performs the appropriate initialisation
++ */
++
++#include <linux/module.h>
++#include <linux/init.h>
++#include <linux/moduleparam.h>
++
++#include <linux/sched.h>
++#include <linux/kernel.h>       /* printk() */
++#include <linux/slab.h>         /* kmalloc() */
++#include <linux/errno.h>        /* error codes */
++#include <linux/types.h>        /* size_t */
++#include <linux/interrupt.h>    /* mark_bh */
++
++#include <linux/in.h>
++#include <linux/netdevice.h>    /* struct device, and other headers */
++#include <linux/etherdevice.h>  /* eth_type_trans */
++#include <linux/ip.h>           /* struct iphdr */
++#include <linux/tcp.h>          /* struct tcphdr */
++#include <linux/skbuff.h>
++
++#include <linux/sccsys.h>
++
++#include <linux/in6.h>
++#include <asm/checksum.h>
++
++#include <asm/io.h>             /* ioremap() & friends */
++#include <asm/pgtable.h>        /* page protection bits */
++#include <asm/apic.h>           /* apic_read() & apic_write() */
++#include <asm/lapic.h>          /* (un)set_lapic_mask */
++
++MODULE_AUTHOR("Werner Haas");
++MODULE_LICENSE("GPL");
++
++/* DEBUG messages */
++#define DEBUG_MSG 0
++#define PRINTD(format, args...) if (DEBUG_MSG) { printk(format, ##args); }
++
++
++/* SCC specific constants
++ * Note that values that can be changed through LUT configuration are made
++ * available as module parameters so it is not necessary to recompile the
++ * driver if a non-default setup is used.
++ */
++/* Maximum size of data transfers */
++#define MAX_PACKET_SIZE     4096
++/* Number of bytes in a cache line */
++#define SCC_CLINE_SIZE      32
++/* Size of a SCC memory tile (16MB) */
++#define SCC_TILE_SIZE       0x01000000
++
++/* Interrupt configuration (register+mask bit) */
++#define SCCPC_LVT           APIC_LVT1
++#define SCCPC_IRQ_MASK      0x00000001
++
++/* The new instruction to flush message buffer content from L1 */
++#define CL1FLUSHMB __asm__ volatile ( ".byte 0x0f; .byte 0x0a;\n" )
++
++/* Register offsets of the host mailbox registers
++ * Note that we hae to use different cachelines to use the write
++ * combining buffer (WCB) efficiently.
++ */
++#define MBX_NULL            0x00 /* Dummy address to flush WCB */
++#define MBX_CONFIG          0x20
++#define MBX_PACKETSTART     0x40
++#define MBX_PACKETDATA      0x60
++#define MBX_RXDONE          0x80
++
++
++
++/*
++ * Module parameters
++ */
++/* Make the number of packets in flight configurable. Note that an unsigend
++ * variable is used to store the status at the host, i.e. the value should
++ * be <= 32!
++ */
++static int rxPacketSlots = 16;
++module_param(rxPacketSlots, int, 0644);
++MODULE_PARM_DESC(rxPacketSlots, "Number of packet slots in DDR3 memory");
++
++/* Start address of the network buffer in the shared memory space. It is
++ * assumed that 4 consecutive memory tiles are resered for the 4 quadrants
++ * and that each core uses txPacketSlots*MAX_PACKET_SIZE bytes.
++ * In the default memory layout the shared region starts at 0x8000.0000 but
++ * we hae to leave space for the shared memory TTY.
++ */
++static int rxBaseAddress = 0x80200000;
++module_param(rxBaseAddress, int, 0644);
++MODULE_PARM_DESC(rxBaseAddress, "Start address of the packet space at the MC");
++
++/* Address of the Tx mailbox. This address is mapped to the host instead
++ * of DDR3 in the LUTs.
++ */
++static int txMailbox = 0xFA000000;
++module_param(txMailbox, int, 0644);
++MODULE_PARM_DESC(txMailbox, "Start address of the Tx mailbox at the host");
++
++/* We need the local CRB registers so we can determine our core ID and clear
++ * the interrupt.
++ */
++static int local_crb_offset = 0xF8000000;
++module_param(local_crb_offset, int, 0644);
++MODULE_PARM_DESC(local_crb_offset, "Start address of the local register bank");
++
++/* When interrupts are disabled the NAPI poll function is added to the queue
++ * at startup never returns 0.
++ */
++static int noIrq = 0;
++module_param(noIrq, int, 0644);
++MODULE_PARM_DESC(noIrq, "Do not use interrupts to trigger receiver");
++
++
++
++/*
++ * The SCC message buffer device
++ */
++struct net_device* sccpc_dev;
++
++struct sccpc_priv {
++  struct net_device_stats     stats;
++  struct napi_struct          napi;
++  spinlock_t                  lock;
++  u8                          shutdown;
++
++  /* Device-specific constants: */
++  u8                          currentSlot;
++  void*                       irqAddress;
++  /* SCC specific physical memory addresses are mapped into
++   * kernel space:  Core Register Bank
++   *                Reiceive Buffer
++   *                Host mailbox
++   */
++  void*                       crb;
++  void*                       rxb;
++  void*                       mailbox;
++};
++
++
++
++/*
++ * Open and close
++ * These functions are called when an interface is activated/stopped. Thus,
++ * any system resources should be registered and the device itself should
++ * be initialized.
++ */
++static irqreturn_t sccpc_interrupt(int, void*);
++
++void sccpc_unmap(struct net_device* dev)
++{
++  struct sccpc_priv*          priv = netdev_priv(dev);
++
++
++  iounmap(priv->crb);
++  iounmap(priv->rxb);
++  iounmap(priv->mailbox);
++}
++
++int sccpc_open(struct net_device* dev)
++{
++  struct sccpc_priv*          priv = netdev_priv(dev);
++  unsigned                    address;
++  int                         tmp;
++  int                         status = 0;
++  int                         x, y, z;
++  int                         quadrant = 0;
++  int                         position = 0;
++
++  /* First map the local CRB register space so we can determine our ID */
++  priv->crb = ioremap_nocache(local_crb_offset, PAGE_SIZE);
++  if (!priv->crb) {
++    printk(KERN_WARNING "sccpc_open: Failed to map register bank\n");
++    return -EIO;
++  }
++
++  /* Determine our location from the tile ID register */
++  tmp = readl((void*)(priv->crb + SCC_TILEID));
++  x = (tmp>>3) & 0x0f; /* bits 06:03 */
++  y = (tmp>>7) & 0x0f; /* bits 10:07 */
++  z = (tmp   ) & 0x07; /* bits 02:00 */
++
++  /* Set the interrupt register address accordingly */
++  if (z == 0) priv->irqAddress = priv->crb + SCC_GLCFG0;
++  else        priv->irqAddress = priv->crb + SCC_GLCFG1;
++
++
++  /* Calculate the quadrant and the location within. Note that rows 1/3
++   * correspond to positions 6..12!
++   */
++  position = 6*y + 2*x + z;
++  if (x > 2) {
++    quadrant += 1;
++    position -= 6;
++  }
++  if (y > 1) {
++    quadrant += 2;
++    position -= 12;
++  }
++  /* Map space for rxPacketSlots and mark it as message passing buffer so it
++   * can be easily invalidated. The write-through flag is also set so every
++   * write is immediately propagated to main memory - note that the Rx buffer
++   * is mostly read-only.
++   */
++  address = PAGE_ALIGN(rxBaseAddress
++                       + quadrant*SCC_TILE_SIZE
++                       + position*rxPacketSlots*MAX_PACKET_SIZE);
++  priv->rxb = ioremap_mpbt(address, rxPacketSlots*MAX_PACKET_SIZE);
++  if (!priv->rxb) {
++    printk(KERN_WARNING "sccpc_open: Failed to map receive buffer\n");
++    sccpc_unmap(dev);
++    return -EIO;
++  }
++  PRINTD(KERN_INFO "sccpc: core %i in quadrant %i (0x%08X)\n",
++                   position, quadrant, address);
++
++  /* Finally map the host mailbox */
++  priv->mailbox = ioremap_mpbt(txMailbox, PAGE_SIZE);
++  if (!priv->mailbox) {
++    printk(KERN_WARNING "sccpc_open: Failed to map host mailbox\n");
++    sccpc_unmap(dev);
++    return -EIO;
++  }
++  PRINTD(KERN_INFO "sccpc: rxb = %p, mailbox = %p\n", priv->rxb, priv->mailbox);
++
++  /* Configure interrupt handling */
++  status = request_irq(dev->irq, &sccpc_interrupt, IRQF_SHARED, "sccpc", dev);
++  if (status) {
++    printk(KERN_WARNING "Can't get interrupt #%d\n", dev->irq);
++    sccpc_unmap(dev);
++    return status;
++  }
++
++  /* Initialize the receive slots */
++  for (position=0; position<rxPacketSlots; position++) {
++    *((unsigned*)(priv->rxb + position*MAX_PACKET_SIZE)) = 0;
++  }
++  /* Tell the peer side we will start receiving at slot 0 and flush the
++   * write-combining buffer so all data gets out to its destination
++   */
++  priv->currentSlot = 0;
++  *((unsigned*)(priv->mailbox+MBX_CONFIG))  = 0;
++  *((unsigned*)(priv->mailbox+MBX_NULL))    = 0;
++
++
++  /* Assign the hardware address of the board (6 octets for Ethernet)
++   * Note that the first octet of ethernet multicast addresses is odd
++   */
++  memcpy(dev->dev_addr, "\0HOST0", ETH_ALEN);
++
++  netif_start_queue(dev);
++  napi_enable(&priv->napi);
++
++  PRINTD(KERN_NOTICE "sccpc_init: napi = %p, priv = %p, dev = %p\n", &priv->napi, priv, dev);
++
++  /* If interrupts are not used we immediately add the polling function
++   * to the queue which would otherwise be done through the IRQ handler.
++   */
++  if (noIrq) napi_schedule(&priv->napi);
++
++  return 0;
++}
++
++
++int sccpc_close(struct net_device* dev)
++{
++  struct sccpc_priv*          priv = netdev_priv(dev);
++  napi_disable(&priv->napi);
++
++  /* Unmap/release the SCC resources */
++  free_irq(dev->irq, dev);
++  sccpc_unmap(dev);
++
++  netif_stop_queue(dev);
++  return 0;
++}
++
++
++
++/*
++ * Configuration changes (passed on by ifconfig)
++ */
++int sccpc_config(struct net_device* dev, struct ifmap* map)
++{
++  /* Can't act on a running interface */
++  if (dev->flags & IFF_UP) return -EBUSY;
++
++  /* Don't allow changing the I/O address */
++  if (map->base_addr != dev->base_addr) {
++    printk(KERN_WARNING "sccpc: Can't change I/O address\n");
++    return -EOPNOTSUPP;
++  }
++
++  /* Allow changing the IRQ */
++  if (map->irq != dev->irq) {
++    dev->irq = map->irq;
++    /* request_irq() is delayed to open-time */
++  }
++
++  /* ignore other fields */
++  return 0;
++}
++
++
++
++/*
++ * Receive a packet: retrieve, encapsulate and pass over to upper levels
++ */
++void sccpc_rx(struct net_device* dev, u8 slot, unsigned len)
++{
++  struct sccpc_priv*          priv = netdev_priv(dev);
++  void*                       address = priv->rxb + slot*MAX_PACKET_SIZE;
++  struct sk_buff*             skb;
++
++#ifdef CONFIG_SCCPC_DUMP_PACKETS
++  printk(KERN_NOTICE "sccpc_rx(): slot = %d, len = %u\n", slot, len);
++#endif
++
++  if (len < sizeof(struct iphdr) || len > dev->mtu) {
++    /* Simply drop the packet */
++    printk(KERN_NOTICE "sccpc_rx(): illegal packet length %d => drop\n", len);
++    priv->stats.rx_errors++;
++    priv->stats.rx_dropped++;
++
++    goto rxDone;
++  }
++
++  /* Build a skb for the packet data so upper layers can handle it
++   * Note that IP headers should be aligned on 16B boundaries, i.e. skip
++   * the first 2 header bytes.
++   */
++  skb = dev_alloc_skb(len);
++  if (!skb) {
++    if (printk_ratelimit() )
++      printk(KERN_NOTICE "sccpc rx: low on mem - packet dropped\n");
++
++    /* Note: since we do not clear the offset descriptor we do not trigger
++     * a retransmission and the packet will eventually be processed.
++     */
++    priv->stats.rx_dropped++;
++    return;
++  }
++
++  /* IP headers should be aligned on 16B boundaries, i.e. we just reserve the
++   * payload area and do not prepend the header bytes which are not used
++   * anymore.
++   */
++  skb_put(skb, len);
++  memcpy(skb->data, address+2, len);
++
++#ifdef CONFIG_SCCPC_DUMP_PACKETS
++  printk(KERN_NOTICE "sccpc: received packet, len = %u\n", len);
++  sccutil_dump_buffer(skb->data, len);
++#endif
++
++  /* Update the interface statistics (also count the header bytes) */
++  priv->stats.rx_packets++;
++  priv->stats.rx_bytes += 2+len;
++  dev->last_rx = jiffies;
++
++  /* Write metadata, and then pass to the receive level */
++  skb->dev        = dev;
++  skb_set_transport_header(skb, 0);
++  skb_set_network_header(skb, 0);
++  skb_set_mac_header(skb, 0);
++  skb->protocol   = htons(ETH_P_IP);
++  skb->pkt_type   = PACKET_HOST;
++  skb->ip_summed  = CHECKSUM_UNNECESSARY;
++
++  netif_rx(skb);
++
++rxDone:
++  /* Invalidate the packet length so we do not process the data again */
++  *((unsigned*)(priv->rxb + slot*MAX_PACKET_SIZE)) = 0;
++
++  /* Tell the host we are done with the slot and move on to the next */
++  *((unsigned*)(priv->mailbox+MBX_RXDONE)) = slot;
++  *((unsigned*)(priv->mailbox+MBX_NULL)) = 0;
++  priv->currentSlot = (priv->currentSlot + 1) % rxPacketSlots;
++
++  return;
++}
++
++
++
++/*
++ * The poll function looks for valid packets in the receive buffer
++ */
++static int sccpc_poll(struct napi_struct* napi, int to_do)
++{
++  struct sccpc_priv*          priv = container_of(napi, struct sccpc_priv, napi);
++  struct net_device*          dev = napi->dev;
++  int                         npackets = 0;
++  int                         quota = to_do;
++  void*                       address;
++  unsigned                    len;
++  unsigned                    tmp;
++
++#ifdef CONFIG_SCCPC_DUMP_PACKETS
++  printk(KERN_NOTICE "sccpc_poll: entry. napi = %p, priv = %p, dev = %p, quota = %d\n", napi, priv, dev, quota);
++#endif
++
++  /* Process up to quota packets from the receive queue */
++  while (npackets<quota) {
++    /* Quit polling when told to do so */
++    if (priv->shutdown) {
++      napi_complete(napi);
++      return 0;
++    }
++    
++    
++    /* Flush the message buffer so we get up to date message buffer data */
++    CL1FLUSHMB;
++
++    /* Check for valid packet lengths */
++    address = priv->rxb + priv->currentSlot*MAX_PACKET_SIZE;
++    len = 256*( *((u8*)(address  )) )
++        +     ( *((u8*)(address+1)) );
++
++#ifdef CONFIG_SCCPC_DUMP_PACKETS
++    printk(KERN_NOTICE "sccpc_poll: currentSlot = %d, len = %u\n", priv->currentSlot, len);
++#endif
++
++    /* Call the standard receive handler if there is a packet */
++    if (len) {
++      /* Clear the interrupt bit */
++      tmp  = readl((void*)priv->irqAddress);
++      tmp &= (~SCCPC_IRQ_MASK);
++      writel(tmp, (void*)priv->irqAddress);
++
++      /* Fetch the packet data */
++      sccpc_rx(dev, priv->currentSlot, len);
++      npackets++;
++    }
++    /* Else perform a clean exit */
++    else {
++      unsigned long v;
++
++      /* If interrupts are disabled we have to remain in the polling function,
++       * i.e. we may signal that we are done with packet processing but must
++       * not remove us from the queueing list via netif_rx_complete().
++       */
++      if (noIrq) {
++        break;
++      }
++
++      /* Tell the system we are done with polling */
++      napi_complete(napi);
++
++      unset_lapic_mask(SCCPC_LVT, dev->irq);
++
++      /* The interrupt was cleared before the Rx packet was processed,
++       * i.e. it will be re-set if another packet arrived since the last
++       * check. Thus the polling function will be scheduled again as
++       * soon as we enable interrupts again so we can safely return.
++       */
++      break;
++    }
++  }
++
++  return npackets;
++}
++
++
++
++/*
++ * A NAPI interrupt handler since we can receive multiple packets
++ * with a single interrupt.
++ */
++static irqreturn_t sccpc_interrupt(int irq, void* dev_id)
++{
++  struct net_device*          dev = (struct net_device*)dev_id;
++  struct sccpc_priv*          priv = netdev_priv(dev);
++
++  unsigned long               v;
++  /* Paranoid */
++  if (!priv) {
++    printk(KERN_DEBUG "sccpc interrupt %d for unknown device\n", irq);
++    return IRQ_NONE;
++  }
++
++#ifdef CONFIG_SCCPC_DUMP_PACKETS
++  printk("sccpc_interrupt: irq = %d, napi = %p, priv = %p, dev = %p\n", irq, &priv->napi, priv, dev);
++#endif
++
++  /* Mask further interrupts and start the polling process */
++  set_lapic_mask(SCCPC_LVT, dev->irq);
++
++  napi_schedule(&priv->napi);
++  
++  return IRQ_HANDLED;
++}
++
++
++
++/*
++ * Transmit a packet (called by the kernel)
++ */
++int sccpc_tx(struct sk_buff* skb, struct net_device* dev)
++{
++  struct sccpc_priv*          priv = netdev_priv(dev);
++  unsigned                    bytesToCopy;
++  unsigned                    bytesTransferred  = 0;
++  unsigned                    bytesRemaining    = 0;
++  unsigned long               flags;
++  spinlock_t*                 lock = &(priv->lock);
++
++  spin_lock_irqsave(lock, flags);
++
++#ifdef CONFIG_SCCPC_DUMP_PACKETS
++  printk(KERN_NOTICE "sccpc_tx: sending packet. len = %u\n", skb->len);
++  sccpc_dump_buffer(skb->data, skb->len);
++#endif
++
++  /* Send the packet data to the host. Note that the first cacheline
++   * has its own mailbox address.
++   */
++  bytesToCopy = (skb->len > SCC_CLINE_SIZE) ? SCC_CLINE_SIZE : skb->len;
++  memcpy(priv->mailbox+MBX_PACKETSTART, skb->data, bytesToCopy);
++  bytesTransferred += bytesToCopy;
++  
++  /* Copy all remaining data to the PACKETDATA mailbox address */
++  while (bytesTransferred < skb->len) {
++    bytesRemaining = skb->len - bytesTransferred;
++    bytesToCopy = (bytesRemaining > SCC_CLINE_SIZE) ? SCC_CLINE_SIZE 
++                                                    : bytesRemaining;
++    
++    memcpy(priv->mailbox+MBX_PACKETDATA, 
++           skb->data+bytesTransferred, bytesToCopy);
++    bytesTransferred += bytesToCopy;
++  }
++  /* If the last memcpy did not fill the entire cache line we have to flush
++   * the write combining buffer.
++   */
++  if (bytesToCopy < SCC_CLINE_SIZE) {
++    /* Write to a different address if the partial data fits into a single
++     * packet.
++     */
++    if (bytesToCopy <= 8) *((unsigned*)(priv->mailbox+MBX_NULL)) = 0;
++    /* Else fill up the cacheline with dummy data */
++    else memcpy(priv->mailbox+MBX_PACKETDATA+bytesToCopy, skb->data, 
++                SCC_CLINE_SIZE-bytesToCopy);
++  }
++  spin_unlock_irqrestore(lock, flags);
++
++
++  /* Transmission always succeeds so save the timestamp of the transmission,
++   * update the statistics and free the socket buffer
++   */
++  dev->trans_start = jiffies;
++
++  priv->stats.tx_packets++;
++  priv->stats.tx_bytes += skb->len;
++  dev_kfree_skb_any(skb);
++
++  return NETDEV_TX_OK;
++}
++
++
++
++/*
++ * Deal with a transmit timeout.
++ */
++void sccpc_tx_timeout(struct net_device* dev)
++{
++  /* A timeout should never occur as we send all data to the host. Wake the
++   * queue in case it was stopped by someone.
++   */
++  //printk(KERN_NOTICE "sccpc_tx_timeout()\n");
++
++  netif_wake_queue(dev);
++  return;
++}
++
++
++
++/*
++ * ioctl commands
++ */
++int sccpc_ioctl(struct net_device* dev, struct ifreq* rq, int cmd)
++{
++  /*
++   * Custom commands
++   */
++  return 0;
++}
++
++
++
++/*
++ * Return statistics to the caller
++ */
++struct net_device_stats* sccpc_stats(struct net_device* dev)
++{
++  struct sccpc_priv* priv = netdev_priv(dev);
++
++  return &(priv->stats);
++}
++
++
++
++/*
++ * The "change_mtu" method is usually not needed.
++ */
++int sccpc_change_mtu(struct net_device* dev, int new_mtu)
++{
++  struct sccpc_priv*          priv = netdev_priv(dev);
++  unsigned long               flags;
++  spinlock_t*                 lock = &(priv->lock);
++
++  /* Check ranges, i.e. make sure that we send at least the IP header and
++   * do not cross the maximum packet size (note the 2 header bytes).
++   */
++  if ((new_mtu < sizeof(struct iphdr)) || (new_mtu > MAX_PACKET_SIZE-2))
++    return -EINVAL;
++
++  /*
++   * Simply accept the value
++   */
++  spin_lock_irqsave(lock, flags);
++  dev->mtu = new_mtu;
++  spin_unlock_irqrestore(lock, flags);
++
++  return 0;
++}
++
++
++
++/*
++ * This function is called to fill up an eth header, since ARP is not
++ * available on the interface.
++ */
++int sccpc_rebuild_header(struct sk_buff* skb)
++{
++  printk(KERN_WARNING "sccpc_rebuild_header() called - ignoring\n");
++
++  return 0;
++}
++
++int sccpc_header(struct sk_buff* skb, struct net_device* dev,
++                 unsigned short type, const void* daddr, const void* saddr,
++                 unsigned len)
++{
++  /* Prepend 2 header bytes containing the packet length */
++  u8* header = skb_push(skb, 2);
++
++  /* Store the length, starting with the MSBs */
++  header[0] = len/256;
++  header[1] = len%256;
++
++  return (dev->hard_header_len);
++}
++
++
++static const struct net_device_ops sccpc_netdev_ops = {
++	.ndo_open		= sccpc_open,
++	.ndo_stop		= sccpc_close,
++	.ndo_set_config		= sccpc_config,
++	.ndo_start_xmit		= sccpc_tx,
++	.ndo_do_ioctl		= sccpc_ioctl,
++	.ndo_get_stats		= sccpc_stats,
++	.ndo_change_mtu		= sccpc_change_mtu,
++	.ndo_tx_timeout		= sccpc_tx_timeout,
++};
++
++static const struct header_ops sccpc_header_ops = {
++	.create			= sccpc_header,
++	.rebuild		= sccpc_rebuild_header,
++};
++
++/*
++ * The init function (sometimes called probe).
++ * It is invoked by register_netdev()
++ */
++void sccpc_init(struct net_device* dev)
++{
++  struct sccpc_priv* priv;
++
++  /*
++   * Then initialize the priv field. This encloses the statistics
++   * and a few private fields.
++   */
++  priv = netdev_priv(dev);
++  memset(priv, 0, sizeof(struct sccpc_priv));
++
++  spin_lock_init(&priv->lock);
++
++  /* Get meaningful default values */
++  ether_setup(dev);
++
++  /* Set the correct function pointers */
++  dev->netdev_ops = &sccpc_netdev_ops;
++  dev->header_ops = &sccpc_header_ops;
++
++  dev->watchdog_timeo     = 10;
++
++  /* Configure NAPI interrupt handling because we may receive multiple
++   * packets per interrupt. Note that Lehnix/MCEMU set LVT1's vector to 3.
++   */
++  netif_napi_add(dev, &priv->napi, sccpc_poll, 16);
++  dev->irq                = 3;
++
++  /* Only set the NOARP flag as there is no broad-/multicast support */
++  dev->flags              = IFF_NOARP;
++  /* Disable caching of (nonexistent) ARP replies */
++  //dev->hard_header_cache  = NULL;
++  /* Change the hardware header as there is no need for an Ethernet format */
++  dev->hard_header_len    = 2;
++  dev->addr_len           = 0;
++}
++
++
++
++/*
++ * Finally, the module stuff
++ */
++int sccpc_dev_event_handler(struct notifier_block* self, 
++                            unsigned long event, void* data)
++{
++  struct net_device* dev  = (struct net_device*)data;
++  struct sccpc_priv* priv = netdev_priv(dev);
++
++    
++  /* Watch out for the interface going down so we can stop the polling
++   * function.
++   */
++  if ((strcmp(dev->name, "pc0") == 0) && (event == NETDEV_GOING_DOWN)) {
++    priv->shutdown = 1;
++  }
++  
++  return NOTIFY_DONE;
++}
++
++static struct notifier_block sccpc_dev_notifier = {
++  .notifier_call = sccpc_dev_event_handler
++};
++
++
++
++void sccpc_cleanup(void)
++{
++  if (sccpc_dev) {
++    unregister_netdev(sccpc_dev);
++    free_netdev(sccpc_dev);
++  }
++}
++
++
++
++int sccpc_init_module(void)
++{
++  int result;
++
++  /* This driver does only work in a bare-metal environment */
++  if (!scc_bare_metal()) {
++    printk(KERN_INFO "sccpc: startup in non-SCC or paravirtualized environment.\n");
++    return -EINVAL;
++  }
++
++  /* Allocate the devices */
++  sccpc_dev = alloc_netdev(sizeof(struct sccpc_priv), "pc0", sccpc_init);
++  if (!sccpc_dev) return -ENOMEM;
++
++  result = register_netdev(sccpc_dev);
++  if (result) {
++    printk(KERN_WARNING "sccpc: error %i registering device \"%s\"\n",
++                        result, sccpc_dev->name);
++    free_netdev(sccpc_dev);
++    return -ENODEV;
++  }
++
++  /* Make sure we are informed about events affecting this device */
++  register_netdevice_notifier(&sccpc_dev_notifier);
++
++  return 0;
++}
++
++
++
++module_init(sccpc_init_module);
++module_exit(sccpc_cleanup);
+diff -urN linux-3.1.4/drivers/tty/serial/8250.c linux-3.1.4-scc/drivers/tty/serial/8250.c
+--- linux-3.1.4/drivers/tty/serial/8250.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/drivers/tty/serial/8250.c	2011-12-20 15:24:05.000000000 +0100
+@@ -1173,7 +1173,7 @@
+ 		 */
+ 		scratch = serial_inp(up, UART_IER);
+ 		serial_outp(up, UART_IER, 0);
+-#ifdef __i386__
++#if defined(__i386__) && !defined(CONFIG_X86_SCC)
+ 		outb(0xff, 0x080);
+ #endif
+ 		/*
+@@ -1182,7 +1182,7 @@
+ 		 */
+ 		scratch2 = serial_inp(up, UART_IER) & 0x0f;
+ 		serial_outp(up, UART_IER, 0x0F);
+-#ifdef __i386__
++#if defined(__i386__) && !defined(CONFIG_X86_SCC)
+ 		outb(0, 0x080);
+ #endif
+ 		scratch3 = serial_inp(up, UART_IER) & 0x0f;
+diff -urN linux-3.1.4/drivers/video/Kconfig linux-3.1.4-scc/drivers/video/Kconfig
+--- linux-3.1.4/drivers/video/Kconfig	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/drivers/video/Kconfig	2011-12-20 15:27:07.618380472 +0100
+@@ -1836,6 +1836,15 @@
+ 	  DECstation series (Personal DECstation 5000/20, /25, /33, /50,
+ 	  Codename "Maxine").
+ 
++config FB_SCCGFX
++	tristate "SCC GFX framebuffer support"
++	depends on FB && X86
++	select FB_CFB_FILLRECT
++	select FB_CFB_COPYAREA
++	select FB_CFB_IMAGEBLIT
++	help
++	  Support for the SCC GFX framebuffer.
++
+ config FB_G364
+ 	bool "G364 frame buffer support"
+ 	depends on (FB = y) && (MIPS_MAGNUM_4000 || OLIVETTI_M700)
+diff -urN linux-3.1.4/drivers/video/Makefile linux-3.1.4-scc/drivers/video/Makefile
+--- linux-3.1.4/drivers/video/Makefile	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/drivers/video/Makefile	2011-12-20 15:27:07.618380472 +0100
+@@ -112,6 +112,7 @@
+ obj-$(CONFIG_FB_PMAG_BA)	  += pmag-ba-fb.o
+ obj-$(CONFIG_FB_PMAGB_B)	  += pmagb-b-fb.o
+ obj-$(CONFIG_FB_MAXINE)		  += maxinefb.o
++obj-$(CONFIG_FB_SCCGFX)		  += sccgfx.o
+ obj-$(CONFIG_FB_METRONOME)        += metronomefb.o
+ obj-$(CONFIG_FB_BROADSHEET)       += broadsheetfb.o
+ obj-$(CONFIG_FB_S1D13XXX)	  += s1d13xxxfb.o
+diff -urN linux-3.1.4/drivers/video/sccgfx.c linux-3.1.4-scc/drivers/video/sccgfx.c
+--- linux-3.1.4/drivers/video/sccgfx.c	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/drivers/video/sccgfx.c	2011-12-20 15:27:07.618380472 +0100
+@@ -0,0 +1,332 @@
++/*******************************************************************************
++
++  This program is free software; you can redistribute it and/or modify it
++  under the terms of the GNU General Public License as published by the Free
++  Software Foundation; either version 2 of the License, or (at your option)
++  any later version.
++
++  This program is distributed in the hope that it will be useful, but WITHOUT
++  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
++  more details.
++
++  You should have received a copy of the GNU General Public License along with
++  this program; if not, write to the Free Software Foundation, Inc., 59
++  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
++
++  The full GNU General Public License is included in this distribution in the
++  file called LICENSE.
++
++  Contact Information:
++  Jan-Michael Brummer <jan-michael.brummer@intel.com>
++  Intel Braunschweig
++
++*******************************************************************************/
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/sched.h>
++#include <linux/errno.h>
++#include <linux/string.h>
++#include <linux/mm.h>
++#include <linux/tty.h>
++#include <linux/slab.h>
++#include <linux/delay.h>
++#include <linux/init.h>
++#include <linux/fb.h>
++
++/* Change Log
++ * 0.2.0	04/19/2011
++ *   o add the possibility to set the resolution via cmdline
++ * 0.1.0	08/19/2010
++ *   o first release
++ */
++
++#define MODVERSTRING	"0.1.0"
++
++/* Default screen resolution */
++#define WIDTH	800
++#define HEIGHT	600
++#define BPP		16
++
++/* Base address (310MB) */
++#define MEGABYTE			0x100000
++#define GFX_BASE_ADDRESS	(630 * MEGABYTE)
++/* Length (10MB) */
++#define GFX_LENGTH			(10 * MEGABYTE)
++#define GFX_HEADER			4096
++
++/** framebuffer var screen information */
++static struct fb_var_screeninfo sccgfxfb_var = {
++	.xres			= WIDTH,
++	.yres			= HEIGHT,
++	.xres_virtual	= WIDTH,
++	.yres_virtual	= HEIGHT,
++	.bits_per_pixel	= BPP,
++	.activate		= FB_ACTIVATE_NOW,
++	.height			= HEIGHT,
++	.width			= WIDTH,
++	.sync			= FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
++	.vmode			= FB_VMODE_NONINTERLACED,
++};
++
++/** framebuffer fix screen information */
++static struct fb_fix_screeninfo sccgfxfb_fix = {
++	.id				= "SCC GFX",
++	.smem_len		= GFX_LENGTH,
++	.type			= FB_TYPE_PACKED_PIXELS,
++	.visual			= FB_VISUAL_PSEUDOCOLOR,
++	.line_length	= WIDTH*BPP/8,
++	.accel			= FB_ACCEL_NONE,
++};
++
++/* Our own framebuffer information structure */
++static struct fb_info fb_info;
++
++static long grb_offset = 0xF9000000;
++static unsigned long base_address = GFX_BASE_ADDRESS;
++static unsigned long memory_size = GFX_LENGTH;
++static unsigned long res_x = 0;
++static unsigned long res_y = 0;
++static unsigned long res_bpp = 0;
++
++/**
++ * \brief Set <pseudo> color register
++ * \param regno register number
++ * \param red red value
++ * \param green green value
++ * \param blue blue value
++ * \param transp alpha value
++ * \param fbinfo framebuffer information pointer
++ * \return 0 = handled, 1 = not handled
++ */
++static int sccgfx_setcolreg(unsigned regno, unsigned red, unsigned green,
++                            unsigned blue, unsigned transp,
++                            struct fb_info *fbinfo) {
++	/* if the number is above our color map length, drop it */
++	if (regno >= fbinfo->cmap.len) {
++		return 1;
++	}
++
++	if (fbinfo->var.bits_per_pixel != 8 && regno < 16) {
++		switch (fbinfo->var.bits_per_pixel) {
++			case 16:
++				if (fbinfo->var.red.offset != 10) {
++					/* 0:5:6:5 */
++					((u32*)(fbinfo->pseudo_palette))[regno] = ((red & 0xf800)) |
++                           ((green & 0xfc00) >> 5) | ((blue & 0xf800) >> 11);
++				}
++				break;
++			case 24:
++			case 32:
++				red >>= 8;
++				green >>= 8;
++				blue >>= 8;
++				((u32*)(fbinfo->pseudo_palette))[regno] = 
++                        (red << fbinfo->var.red.offset) |
++                        (green << fbinfo->var.green.offset) |
++                        (blue << fbinfo->var.blue.offset);
++				break;
++			default:
++				break;
++		}
++	}
++
++	return 0;
++}
++
++/** framebuffer operations */
++static struct fb_ops sccgfxfb_ops = {
++	.owner			= THIS_MODULE,
++	.fb_setcolreg	= sccgfx_setcolreg,
++	.fb_fillrect	= cfb_fillrect,
++	.fb_copyarea	= cfb_copyarea,
++	.fb_imageblit	= cfb_imageblit,
++};
++
++static int __init sccgfx_setup(char *options) {
++	char *this_opt;
++
++	if (!options || !*options) {
++		return 0;
++	}
++
++	while ((this_opt = strsep(&options, ",")) != NULL) {
++		if (!*this_opt) {
++			continue;
++		}
++
++		if (!strncmp(this_opt, "base:", 5)) {
++			base_address = simple_strtoul(this_opt + 5, NULL, 0) * MEGABYTE;
++		} else if (!strncmp(this_opt, "size:", 5)) {
++			memory_size = simple_strtoul(this_opt + 5, NULL, 0) * MEGABYTE;
++		} else if (!strncmp(this_opt, "x:", 2)) {
++			res_x = simple_strtoul(this_opt + 2, NULL, 0);
++		} else if (!strncmp(this_opt, "y:", 2)) {
++			res_y = simple_strtoul(this_opt + 2, NULL, 0);
++		} else if (!strncmp(this_opt, "bpp:", 4)) {
++			res_bpp = simple_strtoul(this_opt + 4, NULL, 0);
++		} else {
++			printk(KERN_INFO "Unknown value!\n");
++		}
++	}
++
++	return 0;
++}
++
++/**
++ * \brief Initialize scc graphic framebuffer
++ * \return error code, 0 = success, otherwise error
++ */
++int __init sccgfxfb_init(void) {
++	unsigned char *shm;
++	unsigned char *fb_off;
++	int x = WIDTH;
++	int y = HEIGHT;
++	int bpp = BPP;
++	char *option = NULL;
++
++	printk(KERN_INFO "sccgfxfb: Initializing framebuffer\n");
++
++	fb_get_options("rckgfx", &option);
++	sccgfx_setup(option);
++
++	if (res_x != 0 && res_y != 0 && res_bpp != 0) {
++		printk(KERN_INFO "sccgfxfb: Valid information from cmdline\n");
++		x = res_x;
++		y = res_y;
++		bpp = res_bpp;
++	} else {
++		printk(KERN_INFO "sccgfxfb: Trying FPGA values\n");
++		/* Read requested display values */
++		shm = ioremap_nocache(grb_offset, 0x10000);
++		if (shm != NULL) {
++			res_x = readl(shm + 0x8238) & 0xFFFFFFFF;
++			res_y = readl(shm + 0x823C) & 0xFFFFFFFF;
++			res_bpp = readl(shm + 0x8240) & 0xFFFFFFFF;
++			if (res_x != 0 && res_y != 0 && res_bpp != 0) {
++				printk(KERN_INFO "sccgfxfb: Valid information from FPGA\n");
++				x = res_x;
++				y = res_y;
++				bpp = res_bpp;
++			}
++			iounmap(shm);
++		} else {
++			printk(KERN_DEBUG "sccgfxfb: could not map grb and therefore not read display "
++                   "values, setting default values (%dx%dx%d)!\n", x, y, bpp);
++		}
++	}
++
++	/* Update var information */
++	sccgfxfb_var.xres = x;
++	sccgfxfb_var.yres = y;
++	sccgfxfb_var.xres_virtual = x;
++	sccgfxfb_var.yres_virtual = y;
++	sccgfxfb_var.bits_per_pixel = bpp;
++	sccgfxfb_var.width = x;
++	sccgfxfb_var.height = y;
++
++	/* Update fix information */
++	sccgfxfb_fix.line_length = x * bpp / 8;
++
++	printk(KERN_INFO "sccgfxfb: Requested display values (%dx%dx%d)\n",
++	       x, y, bpp);
++
++	/* Framebuffer display memory base address */
++	sccgfxfb_fix.smem_start = base_address;
++	/* Length of buffer */
++	sccgfxfb_fix.smem_len = memory_size;
++	/* Map in private video memory */
++	fb_off = ioremap_nocache(sccgfxfb_fix.smem_start, sccgfxfb_fix.smem_len);
++	if (fb_off == NULL) {
++		printk(KERN_INFO "sccgfxfb: cannot remap!!\n");
++		return -1;
++	}
++
++	/* Clear memory */
++	memset(fb_off, 0x00, sccgfxfb_fix.smem_len);
++
++	/* Write display informations */
++	writel(sccgfxfb_var.xres, (u8*)fb_off + 0x00);
++	writel(sccgfxfb_var.yres, (u8*)fb_off + 0x04);
++	writel(sccgfxfb_var.bits_per_pixel, (u8*)fb_off + 0x08);
++
++	/* Set start address into shared memory (sccDisplay will use this one as
++     * base address)
++     */
++	shm = ioremap_nocache(0x80000940, 4);
++	if (shm != NULL) {
++		writel(sccgfxfb_fix.smem_start, shm);
++		iounmap(shm);
++	} else {
++		printk(KERN_DEBUG "sccgfxfb: could not map crb and therefore not write base "
++               "address. sccDisplay will not work!\n");
++	}
++
++	/* Skip framebuffer header */
++	fb_off += GFX_HEADER;
++	sccgfxfb_fix.smem_start += GFX_HEADER;
++	sccgfxfb_fix.smem_len -= GFX_HEADER;
++
++	/* set color offsets/lengths */
++	if (sccgfxfb_var.bits_per_pixel != 8) {
++		sccgfxfb_fix.visual = FB_VISUAL_TRUECOLOR;
++		switch (sccgfxfb_var.bits_per_pixel) {
++			case 16:
++				sccgfxfb_var.red.offset = 11;
++				sccgfxfb_var.red.length = 5;
++				sccgfxfb_var.green.offset = 5;
++				sccgfxfb_var.green.length = 6;
++				sccgfxfb_var.blue.offset = 0;
++				sccgfxfb_var.blue.length = 5;
++				break;
++			case 32:
++				sccgfxfb_var.red.offset = 24;
++				sccgfxfb_var.red.length = 8;
++				sccgfxfb_var.green.offset = 16;
++				sccgfxfb_var.green.length = 8;
++				sccgfxfb_var.blue.offset = 8;
++				sccgfxfb_var.blue.length = 8;
++				sccgfxfb_var.transp.offset = 0;
++				sccgfxfb_var.transp.length = 8;
++				break;
++		}
++	}
++	sccgfxfb_var.yres_virtual = y;
++
++	fb_info.fbops = &sccgfxfb_ops;
++	fb_info.screen_base = fb_off;
++	fb_info.var = sccgfxfb_var;
++	fb_info.fix = sccgfxfb_fix;
++	fb_info.flags = FBINFO_FLAG_DEFAULT;
++	fb_info.pseudo_palette = kzalloc(sizeof(u32) * 256, GFP_KERNEL);
++
++	/* Allocate color map */
++	fb_alloc_cmap(&fb_info.cmap, 256, 0);
++
++	if (register_framebuffer(&fb_info) < 0) {
++		printk(KERN_WARNING "sccgfxfb: failed while register_framebuffer\n");
++		return 1;
++	}
++
++	printk(KERN_INFO "sccgfxfb: register framebuffer (%dx%dx%d)\n",
++           fb_info.var.xres, fb_info.var.yres, fb_info.var.bits_per_pixel);
++
++	return 0;
++}
++
++/**
++ * \brief Remove framebuffer
++ */
++static void __exit sccgfxfb_exit(void) {
++	unregister_framebuffer(&fb_info);
++}
++
++#ifdef MODULE
++MODULE_LICENSE("GPL");
++MODULE_AUTHOR("Jan-Michael Brummer");
++MODULE_VERSION(MODVERSTRING);
++MODULE_DESCRIPTION("Intel(R) SCC graphic driver");
++#endif
++module_init(sccgfxfb_init);
++module_exit(sccgfxfb_exit);
+diff -urN linux-3.1.4/fs/Kconfig linux-3.1.4-scc/fs/Kconfig
+--- linux-3.1.4/fs/Kconfig	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/fs/Kconfig	2011-12-20 15:27:07.618380472 +0100
+@@ -169,6 +169,12 @@
+ 
+ 	  If unsure, say N.
+ 
++config POPSHM
++	bool "POPSHM support"
++	depends on HUGETLBFS
++	help
++		POPSHM feature for Intel's Single Chip Cloud Computer.
++
+ config HUGETLB_PAGE
+ 	def_bool HUGETLBFS
+ 
+diff -urN linux-3.1.4/include/linux/clocksource.h linux-3.1.4-scc/include/linux/clocksource.h
+--- linux-3.1.4/include/linux/clocksource.h	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/include/linux/clocksource.h	2011-12-20 15:27:07.618380472 +0100
+@@ -278,7 +278,7 @@
+ extern void clocksource_change_rating(struct clocksource *cs, int rating);
+ extern void clocksource_suspend(void);
+ extern void clocksource_resume(void);
+-extern struct clocksource * __init __weak clocksource_default_clock(void);
++extern struct clocksource * __weak clocksource_default_clock(void);
+ extern void clocksource_mark_unstable(struct clocksource *cs);
+ 
+ extern void
+@@ -338,6 +338,7 @@
+ #endif
+ 
+ extern void timekeeping_notify(struct clocksource *clock);
++extern struct clocksource* timekeeping_get_clock(void);
+ 
+ extern cycle_t clocksource_mmio_readl_up(struct clocksource *);
+ extern cycle_t clocksource_mmio_readl_down(struct clocksource *);
+diff -urN linux-3.1.4/include/linux/sccsys.h linux-3.1.4-scc/include/linux/sccsys.h
+--- linux-3.1.4/include/linux/sccsys.h	1970-01-01 01:00:00.000000000 +0100
++++ linux-3.1.4-scc/include/linux/sccsys.h	2011-12-20 15:27:07.618380472 +0100
+@@ -0,0 +1,385 @@
++/*
++ *  Copyright 2011 Jan-Arne Sobania <jan-arne.sobania@hpi.uni-potsdam.de>, HPI
++ *
++ *  This program is free software; you can redistribute it and/or modify
++ *  it under the terms of the GNU General Public License as published by
++ *  the Free Software Foundation; either version 2, or (at your option)
++ *  any later version.
++ *
++ *  This program is distributed in the hope that it will be useful,
++ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ *  GNU General Public License for more details.
++ *
++ *  You should have received a copy of the GNU General Public License
++ *  along with this program; see the file COPYING.  If not, write to
++ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
++ *
++ */
++
++#ifndef __LINUX_SCCSYS_H__
++#define __LINUX_SCCSYS_H__
++
++/* Query bus frequency at boot time. */
++extern unsigned long scc_get_boot_busclock(void);
++
++/* Check whether we are running on the lowest layer on SCC hardware */
++extern int scc_bare_metal(void);
++
++/* SCC-specific constants
++ */
++
++/* Number of cores on a SCC chip */
++#define SCC_CORECOUNT		48
++/* Number of tiles on a SCC chip */
++#define SCC_TILECOUNT		24
++/* Number of bytes in a cache line */
++#define SCC_CLINE_SIZE		32
++/* Raw size of the message passing buffer (bytes per core) */
++#define SCC_MPB_SIZE		8192
++/* Raw size of the configuration register bank (bytes per tile) */
++#define SCC_CRB_SIZE		0x2000
++/* Raw size of the global register bank */
++#define SCC_GRB_SIZE		0x10000
++/* Size of a SCC memory tile (16MB) */
++#define SCC_TILE_SIZE		0x01000000
++
++/* Stride between adjacent LUT entries */
++#define SCC_LUT_STRIDE		8
++
++/* Register offsets */
++#define SCC_GLCFG0		0x0010
++#define SCC_GLCFG1		0x0018
++#define SCC_L2CFG0		0x0020
++#define SCC_L2CFG1		0x0028
++#define SCC_SENSOR		0x0040
++#define SCC_GCBCFG		0x0080
++#define SCC_TILEID		0x0100
++#define SCC_LOCK0		0x0200
++#define SCC_LOCK1		0x0400
++#define SCC_LUT0		0x0800
++#define SCC_LUT1		0x1000
++
++
++/* Mask of the interrupt bits */
++#define SCC_INTR_MASK		0x00000002
++#define SCC_NMI_MASK		0x00000001
++
++
++/* Global register offsets */
++/* Please note the GRB space is particularly nasty, as accessing an undefined
++ * register result in undefined behaviour, up to and including the whole SCC
++ * locking up. */
++#define SCCGRB_EMAC_MACBASE_HI	0x7E00
++#define SCCGRB_EMAC_MACBASE_LO	0x7E04
++#define SCCGRB_EMAC_IP_START	0x7E08
++#define SCCGRB_EMAC_HOST_IP	0x7E0C
++#define SCCGRB_EMAC_GW_IP	0x7E10
++
++#define SCCGRB_FPGA_CONFIG	0x822C
++#define SCCGRB_CLKFREQ		0x8230
++
++#define SCCGRB_PRIVATE_SLOTS	0x8244
++
++
++/* Valid sub destination IDs */
++#define SCC_SUBDEST_CORE0	0
++#define SCC_SUBDEST_CORE1	1
++#define SCC_SUBDEST_CRB		2
++#define SCC_SUBDEST_MPB		3
++#define SCC_SUBDEST_PERIE	4
++#define SCC_SUBDEST_PERIS	5
++#define SCC_SUBDEST_PERIW	6
++#define SCC_SUBDEST_PERIN	7
++
++static const char* sccsys_subdest_names[] __attribute__((unused)) = {
++	"CORE0", "CORE1", "-CRB-", "-MPB-", "PERIE", "PERIS", "PERIW", "PERIN"
++};
++
++/* The new instruction to flush message buffer content from L1 */
++#define CL1FLUSHMB __asm__ volatile ( ".byte 0x0f; .byte 0x0a;\n" )
++
++typedef unsigned char scc_pid_t;
++#define SCC_NO_PID ((scc_pid_t)(-1))
++
++/* Perform hex dump */
++static void __attribute__((unused)) sccutil_dump_buffer(unsigned char* buffer, unsigned len)
++{
++	char linebuf[16*3 + 10 + 64], *wptr;
++	int li, ci;
++	int lc = (len + 15) / 16;
++
++	printk(KERN_INFO "<-- buffer @ %p, len = %x\n", buffer, len);
++	for (li = 0; li < lc; li++) {
++		int cc;
++
++		wptr = linebuf;
++		wptr += sprintf(wptr, "%04x: ", li * 16);
++
++		cc = ((li + 1 == lc) && (len % 16)) ? (len % 16) : 16;
++
++		for (ci = 0; ci < cc; ci++) {
++			wptr += sprintf(wptr, " %02x", buffer[li*16+ci]);
++		}
++		for (; ci < 16; ci++) {
++			wptr += sprintf(wptr, "   ");
++		}
++		wptr += sprintf(wptr, "  ");
++
++		for (ci = 0; ci < cc; ci++) {
++			char c = buffer[li*16+ci];
++			if (c < 0x20 || c >= 0x7F) c = '.';
++			wptr += sprintf(wptr, "%c", c);
++		}
++		for (; ci < 16; ci++) {
++			wptr += sprintf(wptr, " ");
++		}
++
++		printk(KERN_CONT "%s\n", linebuf);
++	}
++	printk(KERN_CONT "-- end -->\n");
++}
++
++
++/* LookUp Table Entry */
++typedef union scc_lut {
++	struct {
++		unsigned int address : 10;
++		unsigned int subdest :  3;
++		unsigned int x       :  4;
++		unsigned int y       :  4;
++		unsigned int bypass  :  1;
++	};
++	unsigned int raw;
++} scc_lut_t;
++
++#define sccsys_get_route(t)		(((t).y << 4) | (t).x)
++
++/* Type for PFNs */
++typedef unsigned long pfn_t;
++
++#if PAGE_SHIFT != 12
++#error SCCSYS expects a PAGE_SHIFT of 12.
++#endif
++
++/******************************************************************************/
++/* Explicit cache control routines
++ *
++ * These routines are meant to allow direct control of the processor's caches
++ * in regards to a specific page. */
++
++/* Perform write-back/invalidate for all cachelines holding the specified pfn */
++extern void scc_cop_wbinv_pfn(pfn_t pfn);
++
++/* Perform write-back for all cachelines holding the specified pfn */
++/* NOTE: This call must only be used if no invalidation is needed. However, it
++ *       may be possible that invalidation is still performed, depending on
++ *       whether the caches support issuing write-back only. */
++#define scc_cop_wb_pfn(pfn)	scc_cop_wbinv_pfn(pfn)
++
++/* Perform invalidate for all cachelines holding the specified pfn */
++/* NOTE: This call may perform a writeback if required by the implementation.
++ *       The caller merely provides a hint that a writeback is not needed. */
++#define scc_cop_inv_pfn(pfn)	scc_cop_wbinv_pfn(pfn)
++
++/* System address. */
++typedef union scc_addr {
++	struct {
++		unsigned long long offset  : 24;
++		unsigned long long address : 10;
++		unsigned long long subdest :  3;
++		unsigned long long x       :  4;
++		unsigned long long y       :  4;
++		unsigned long long bypass  :  1;
++	};
++	unsigned long long raw;
++} scc_addr_t;
++
++/* Convert a node-local physical address into a system address */
++extern scc_addr_t sccsys_physical_to_system(scc_pid_t pid, unsigned long pa);
++
++#define sccsys_local_physical_to_system(pa) \
++	sccsys_physical_to_system(sccsys_get_pid(), pa);
++
++/* System page frame number. */
++typedef union scc_syspfn {
++	struct {
++		unsigned long long offset  : 12;
++		unsigned long long address : 10;
++		unsigned long long subdest :  3;
++		unsigned long long x       :  4;
++		unsigned long long y       :  4;
++		unsigned long long bypass  :  1;
++	};
++	unsigned long long raw;
++} scc_syspfn_t;
++
++/* Get system pfn from system address */
++static inline scc_syspfn_t sccsys_get_syspfn(scc_addr_t addr)
++{
++	scc_syspfn_t pfn;
++	pfn.offset = addr.offset >> PAGE_SHIFT;
++	pfn.address = addr.address;
++	pfn.subdest = addr.subdest;
++	pfn.x = addr.x;
++	pfn.y = addr.y;
++	pfn.bypass = addr.bypass;
++	return pfn;
++}
++
++/*
++ * Coordinates of a single component on the SCC die
++ * This structure has specially been crafted s.t. its raw fields has the same
++ * format as the TILEID configuration register.
++ */
++typedef union scc_coord {
++	struct {
++		int z : 3;
++		int x : 4;
++		int y : 4;
++	};
++	int raw;
++} scc_coord_t;
++
++/* Convert tileid into decoded coordinate structure. */
++static inline scc_coord_t scc_tileid_to_coord(int tileid)
++{
++	scc_coord_t coord;
++	coord.raw = tileid;
++	return coord;
++}
++
++/* Convert decoded coordinate structure into tileid. */
++static inline int scc_coord_to_tileid(scc_coord_t coord)
++{
++	return coord.raw;
++}
++
++/* Convert decoded coordinate structure into processor id. */
++static inline scc_pid_t scc_coord_to_pid(scc_coord_t coord)
++{
++	scc_pid_t pid;
++	pid=( ( coord.x + ( 6 * coord.y ) ) * 2 ) + coord.z;
++	return pid;
++}
++
++/* Convert processor id to decoded coordinate structure. */
++static inline scc_coord_t scc_pid_to_coord(scc_pid_t pid)
++{
++	scc_coord_t coord = { .raw = 0 };
++	coord.z = (pid % 2);
++	coord.y = (pid / 2) / 6;
++	coord.x = (pid / 2) % 6;
++	return coord;
++}
++
++/* Convert tileid to processor id. */
++static inline scc_pid_t scc_tileid_to_pid(int tileid)
++{
++	return scc_coord_to_pid(scc_tileid_to_coord(tileid));
++}
++
++/* Convert processor id to tileid. */
++static inline int scc_pid_to_tileid(scc_pid_t pid)
++{
++	return scc_coord_to_tileid(scc_pid_to_coord(pid));
++}
++
++/*
++ * Global Clock Unit (GCU) Configuration Register
++ */
++typedef union scc_gckcfg {
++	struct {
++		unsigned long RESC0 : 1;
++		unsigned long RESC1 : 1;
++		unsigned long RESL20 : 1;
++		unsigned long RESL21 : 1;
++		unsigned long SREC0 : 1;
++		unsigned long SREC1 : 1;
++		unsigned long SREL21 : 1;
++		unsigned long SREL20 : 1;
++		unsigned long divider : 4;
++		unsigned long ratio : 7;
++		unsigned long router : 7;
++		unsigned long reserved : 6;
++	};
++	unsigned long raw;
++} scc_gckcfg_t;
++
++/* Get value of own tileid. The format is 0...0_00000yyy_yxxxxzzz (in bits).
++ * Tile IDs are not consecutive; if a consecutive number is needed, consider
++ * using the PID instead.
++ */
++extern int sccsys_get_tileid(void);
++
++/* Get own processor id. This is a consecutive number from 0 to SCC_CORECOUNT-1.
++ */
++extern scc_pid_t sccsys_get_pid(void);
++
++/* Get own coordinates. This is the decoded version of the TILEID returned by
++ * sccsys_get_tileid. */
++extern scc_coord_t sccsys_get_coord(void);
++
++/* Get logically next processor id. This is a consecutive number from 0 to
++ * SCC_CORECOUNT-1, but is not neccessarily ((pid+1) % SCC_CORECOUNT). The
++ * number is usually chosen to reflect the adjacent core having the shortest
++ * distance, although it guarantees that the cycle closes after exactly
++ * SCC_CORECOUNT invocations.
++ */
++extern scc_pid_t sccsys_get_next_pid(scc_pid_t pid);
++
++/* Acquire the test&set register of the specified PID. This call returns 1 if
++ * the lock has successfully been acquired, or 0 otherwise.
++ *
++ * In the current implementation, the call does only fail if the PID is invalid
++ * (i.e., outside of the range from 0 to SCC_CORECOUNT-1) or mapping of the
++ * configuration registers has failed.
++ */
++extern int sccsys_acquire_pid_lock(scc_pid_t pid);
++
++/* Release the test&set register of the specified PID. This call returns 1 if
++ * the lock has successfully been released, or 0 otherwise.
++ *
++ * In the current implementation, the call does only fail if the PID is invalid
++ * (i.e., outside of the range from 0 to SCC_CORECOUNT-1) or mapping of the
++ * configuration registers has failed.
++ */
++extern int sccsys_release_pid_lock(scc_pid_t pid);
++
++/* Set a bit in a core's configuration register */
++extern int sccsys_set_config_bits(scc_pid_t pid, unsigned int bits);
++
++/* Clear a bit for a core's configuration register */
++extern int sccsys_clear_config_bits(scc_pid_t pid, unsigned int bits);
++
++/* Trigger an interrupt to a core (directly via the configuration register) */
++extern int sccsys_trigger_irq_direct(scc_pid_t pid, unsigned int bits, int edgeIrq);
++
++/* Clear an interrupt request bit for a processor identified by pid. */
++extern int sccsys_clear_irq_direct(scc_pid_t pid, unsigned int bits);
++
++/* Read LUT entry */
++extern scc_lut_t sccsys_read_lut_entry(scc_pid_t pid, unsigned int index);
++
++/* Write LUT entry */
++extern int sccsys_write_lut_entry(scc_pid_t pid, unsigned int index, scc_lut_t lut);
++
++/* Read Global Clock Unit (GCU) configuration register */
++extern scc_gckcfg_t sccsys_read_gcbcfg(scc_pid_t pid);
++
++/* Write Global Clock Unit (GCU) configuration register */
++extern int sccsys_write_gcbcfg(scc_pid_t pid, scc_gckcfg_t cfg);
++
++/* Get address of mapped global configuration register bank */
++extern void* sccsys_get_grb(void);
++
++/* Read global configuration register */
++extern unsigned sccsys_read_grb_entry(unsigned int offset);
++
++/* Write global configuration register */
++extern void sccsys_write_grb_entry(unsigned int offset, unsigned value);
++
++/* Read frequency of the fast clock from the global configuration register bank */
++extern unsigned short sccsys_read_grb_fastclock(void);
++
++#endif /* __LINUX_SCCSYS_H__ */
+diff -urN linux-3.1.4/init/Kconfig linux-3.1.4-scc/init/Kconfig
+--- linux-3.1.4/init/Kconfig	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/init/Kconfig	2011-12-20 15:27:07.618380472 +0100
+@@ -130,10 +130,13 @@
+ config HAVE_KERNEL_LZO
+ 	bool
+ 
++config HAVE_KERNEL_NONE
++	bool
++
+ choice
+ 	prompt "Kernel compression mode"
+ 	default KERNEL_GZIP
+-	depends on HAVE_KERNEL_GZIP || HAVE_KERNEL_BZIP2 || HAVE_KERNEL_LZMA || HAVE_KERNEL_XZ || HAVE_KERNEL_LZO
++	depends on HAVE_KERNEL_GZIP || HAVE_KERNEL_BZIP2 || HAVE_KERNEL_LZMA || HAVE_KERNEL_XZ || HAVE_KERNEL_LZO || HAVE_KERNEL_NONE
+ 	help
+ 	  The linux kernel is a kind of self-extracting executable.
+ 	  Several compression algorithms are available, which differ
+@@ -201,6 +204,12 @@
+ 	  size is about 10% bigger than gzip; however its speed
+ 	  (both compression and decompression) is the fastest.
+ 
++config KERNEL_NONE
++	bool "None"
++	depends on HAVE_KERNEL_NONE
++	help
++	  No compression.
++
+ endchoice
+ 
+ config DEFAULT_HOSTNAME
+diff -urN linux-3.1.4/kernel/time/jiffies.c linux-3.1.4-scc/kernel/time/jiffies.c
+--- linux-3.1.4/kernel/time/jiffies.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/kernel/time/jiffies.c	2011-12-20 15:27:07.618380472 +0100
+@@ -91,7 +91,7 @@
+ 
+ core_initcall(init_jiffies_clocksource);
+ 
+-struct clocksource * __init __weak clocksource_default_clock(void)
++struct clocksource * __weak clocksource_default_clock(void)
+ {
+ 	return &clocksource_jiffies;
+ }
+diff -urN linux-3.1.4/kernel/time/timekeeping.c linux-3.1.4-scc/kernel/time/timekeeping.c
+--- linux-3.1.4/kernel/time/timekeeping.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/kernel/time/timekeeping.c	2011-12-20 15:27:07.618380472 +0100
+@@ -460,6 +460,16 @@
+ }
+ 
+ /**
++ * timekeeping_get_clock - Get clock source currently used by the timekeeper
++ *
++ * returns the pointer to the clock source
++ */
++struct clocksource* timekeeping_get_clock(void)
++{
++	return timekeeper.clock;
++}
++
++/**
+  * ktime_get_real - get the real (wall-) time in ktime_t format
+  *
+  * returns the time in ktime_t format
+diff -urN linux-3.1.4/mm/hugetlb.c linux-3.1.4-scc/mm/hugetlb.c
+--- linux-3.1.4/mm/hugetlb.c	2011-11-28 23:48:14.000000000 +0100
++++ linux-3.1.4-scc/mm/hugetlb.c	2011-12-20 15:27:07.628922062 +0100
+@@ -1,6 +1,14 @@
+ /*
+  * Generic hugetlb support.
+  * (C) William Irwin, April 2004
++ *
++ * April 2011:
++ * Added POPSHM feature for Intel's Single Chip Cloud Computer.
++ *
++ * Isaias Alberto Compres Urenai(isaias.a.compres.urena@intel.com)
++ *
++ * Portions copyright 2011 Intel Corporation.
++ *
+  */
+ #include <linux/list.h>
+ #include <linux/init.h>
+@@ -30,6 +38,46 @@
+ #include <linux/node.h>
+ #include "internal.h"
+ 
++#ifdef CONFIG_POPSHM
++// legacy shared memory
++#define SHM_X0_Y0 0x80000000
++#define SHM_X5_Y0 0x81000000
++#define SHM_X0_Y2 0x82000000
++#define SHM_X5_Y2 0x83000000
++#define SHM_ADDR  SHM_X0_Y0
++// CRB of this core
++#define CRB_OWN   0xf8000000
++// LUTs
++#define LUT0     0x00800
++#define LUT1     0x01000
++// Tile ID
++#define MYTILEID 0x100
++
++#define POPSHM_PAGEDATA_BASE (SHM_X5_Y0 + 0x0800)
++#define POPSHM_PAGEDATA_SLOTSIZE 8
++#define POPSHM_PAGEDATA_LOCALSLOT (POPSHM_PAGEDATA_BASE + \
++		    (local_core_id * POPSHM_PAGEDATA_SLOTSIZE))
++#define POPSHM_LUT_BASE (CRB_OWN + (local_core_z?LUT1:LUT0))
++#define POPSHM_LUT_SLOTSIZE 8
++#define POPSHM_LUT_OFFSET ((popshm_base_address >> POPSHMPAGE_SHIFT)\
++		    * POPSHM_LUT_SLOTSIZE)
++
++#define POPSHMPAGE_MAXCOUNT  5
++#define POPSHMPAGE_SHIFT  24
++#define POPSHMPAGE_SIZE ((1UL) << POPSHMPAGE_SHIFT)
++#define POPSHMPAGE_MASK (~(POPSHMPAGE_SIZE - 1))
++
++static void free_all_popshm(struct hstate *h, nodemask_t *nodes_allowed);
++static void publish_popshm_data(struct hstate *h);
++static void try_to_free_low(struct hstate *h, unsigned long count,
++						nodemask_t *nodes_allowed);
++
++static unsigned int popshm_base_address;
++static int local_core_z, local_core_id;
++#endif
++
++#define persistent_huge_pages(h) (h->nr_huge_pages - h->surplus_huge_pages)
++
+ const unsigned long hugetlb_zero = 0, hugetlb_infinity = ~0UL;
+ static gfp_t htlb_alloc_mask = GFP_HIGHUSER;
+ unsigned long hugepages_treat_as_movable;
+@@ -659,6 +707,38 @@
+ 	return nid;
+ }
+ 
++#ifdef CONFIG_POPSHM
++static int alloc_fresh_huge_page(struct hstate *h, nodemask_t *nodes_allowed,
++		unsigned int *page_address)
++{
++	struct page *page;
++	int start_nid;
++	int next_nid;
++	int ret = 0;
++
++	start_nid = hstate_next_node_to_alloc(h, nodes_allowed);
++	next_nid = start_nid;
++
++	do {
++		page = alloc_fresh_huge_page_node(h, next_nid);
++		if (page) {
++			// privide physical address of the page
++			*page_address = page_to_phys(page);
++			printk(KERN_WARNING "fresh page address: %x\n", *page_address);
++			ret = 1;
++			break;
++		}
++		next_nid = hstate_next_node_to_alloc(h, nodes_allowed);
++	} while (next_nid != start_nid);
++
++	if (ret)
++		count_vm_event(HTLB_BUDDY_PGALLOC);
++	else
++		count_vm_event(HTLB_BUDDY_PGALLOC_FAIL);
++
++	return ret;
++}
++#else
+ static int alloc_fresh_huge_page(struct hstate *h, nodemask_t *nodes_allowed)
+ {
+ 	struct page *page;
+@@ -685,6 +765,7 @@
+ 
+ 	return ret;
+ }
++#endif
+ 
+ /*
+  * helper for free_pool_huge_page() - return the previously saved
+@@ -1130,6 +1211,129 @@
+ 	}
+ }
+ 
++
++#ifdef CONFIG_POPSHM
++static void free_all_popshm(struct hstate *h, nodemask_t *nodes_allowed){
++	int min_count;
++
++	min_count = 0;
++
++	spin_lock(&hugetlb_lock);
++	try_to_free_low(h, min_count, nodes_allowed);
++	while (min_count < persistent_huge_pages(h)) {
++		if (!free_pool_huge_page(h, nodes_allowed, 0))
++			break;
++	}
++	spin_unlock(&hugetlb_lock);
++}
++
++static void publish_popshm_data(struct hstate *h) {
++	void *lut_address, *popshm_table_address;
++	unsigned int data;
++
++	lut_address = ioremap_nocache((POPSHM_LUT_BASE +
++				POPSHM_LUT_OFFSET), sizeof(int));
++
++	popshm_table_address = ioremap_nocache(POPSHM_PAGEDATA_LOCALSLOT,
++			POPSHM_PAGEDATA_SLOTSIZE);
++
++	if (lut_address && popshm_table_address) {
++		data = readl(lut_address);
++		writel(data, popshm_table_address);
++		data = h->nr_huge_pages/4;
++		data += popshm_base_address;
++		writel(data, popshm_table_address + sizeof(int));
++
++		iounmap(lut_address);
++		iounmap(popshm_table_address);
++
++		printk(KERN_WARNING "local popshm page data published\n");
++	}
++}
++
++static void __init hugetlb_hstate_alloc_pages(struct hstate *h)
++{
++	unsigned page_address, previous_page_address;
++	int contig_pages, count, current_page_count, i;
++	void *popshm_table_address;
++
++	NODEMASK_ALLOC(nodemask_t, nodes_allowed,
++			GFP_KERNEL | __GFP_NORETRY);
++
++	printk(KERN_WARNING "hugetlb_hstate_alloc_pages with %ld\n", h->max_huge_pages);
++
++	if (h->max_huge_pages <= 0) { // no pages
++		popshm_table_address = ioremap_nocache(POPSHM_PAGEDATA_LOCALSLOT,
++				POPSHM_PAGEDATA_SLOTSIZE);
++
++		if (popshm_table_address) {
++			writel(0x00000000, popshm_table_address);
++			writel(0x00000000, popshm_table_address + sizeof(int));
++			iounmap(popshm_table_address);
++		}
++	} else { // popshm pages requested
++		if(h->max_huge_pages <= POPSHMPAGE_MAXCOUNT){
++			count = h->max_huge_pages * 4;
++		} else {
++			count = POPSHMPAGE_MAXCOUNT * 4;
++		}
++
++		contig_pages = 1;
++		previous_page_address = 0;
++		popshm_base_address = 0;
++
++		while (!popshm_base_address) {
++			if (!alloc_fresh_huge_page(h, &node_states[N_HIGH_MEMORY], &page_address)) {
++				free_all_popshm(h, nodes_allowed);
++				publish_popshm_data(h);
++				h->max_huge_pages = 0;
++				printk(KERN_ERR "Failed to allocater POPSHM pages\n");
++			}
++			if (previous_page_address - page_address == HPAGE_SIZE) {
++				contig_pages++;
++				if ((contig_pages >= count) && !(page_address & (~POPSHMPAGE_MASK))) {
++					popshm_base_address = page_address;
++					printk(KERN_WARNING "popshm base page address: %x\n", popshm_base_address);
++				}
++			} else {
++				contig_pages = 1;
++			}
++
++			previous_page_address = page_address;
++		}
++
++		// free excess pages
++		if (!( init_nodemask_of_mempolicy(nodes_allowed))) {
++			NODEMASK_FREE(nodes_allowed);
++			nodes_allowed = &node_states[N_HIGH_MEMORY];
++		}
++
++		current_page_count = 0;
++		for_each_node_mask(i, *nodes_allowed) {
++			struct page *page, *next;
++			struct list_head *freel = &h->hugepage_freelists[i];
++			list_for_each_entry_safe(page, next, freel, lru) {
++				current_page_count++;
++				if (current_page_count > count){
++					printk(KERN_WARNING "freeing page with address: %x\n", page_to_phys(page));
++					list_del(&page->lru);
++					update_and_free_page(h, page);
++					h->free_huge_pages--;
++					h->free_huge_pages_node[page_to_nid(page)]--;
++				}
++			}
++		}
++
++		if (nodes_allowed != &node_states[N_HIGH_MEMORY])
++			NODEMASK_FREE(nodes_allowed);
++
++		publish_popshm_data(h);
++	}
++
++	printk(KERN_WARNING "hugetlb_hstate_alloc_pages exit %ld\n", h->max_huge_pages);
++
++}
++#else
+ static void __init hugetlb_hstate_alloc_pages(struct hstate *h)
+ {
+ 	unsigned long i;
+@@ -1144,6 +1348,7 @@
+ 	}
+ 	h->max_huge_pages = i;
+ }
++#endif
+ 
+ static void __init hugetlb_init_hstates(void)
+ {
+@@ -1185,6 +1390,7 @@
+ 						nodemask_t *nodes_allowed)
+ {
+ 	int i;
++	printk(KERN_WARNING "try_to_free_low\n");
+ 
+ 	if (h->order >= MAX_ORDER)
+ 		return;
+@@ -1263,7 +1469,54 @@
+ 	return ret;
+ }
+ 
+-#define persistent_huge_pages(h) (h->nr_huge_pages - h->surplus_huge_pages)
++#ifdef CONFIG_POPSHM
++static unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,
++						nodemask_t *nodes_allowed)
++{
++	unsigned long min_count, ret;
++	unsigned page_address;
++	printk(KERN_WARNING "set_max_huge_pages nr max: %ld; count: %ld;\n", h->max_huge_pages, count);
++
++	if (h->order >= MAX_ORDER)
++		return h->max_huge_pages;
++
++	spin_lock(&hugetlb_lock);
++	while (h->surplus_huge_pages && count > persistent_huge_pages(h)) {
++		if (!adjust_pool_surplus(h, nodes_allowed, -1))
++			break;
++	}
++
++	while (count > persistent_huge_pages(h)) {
++		spin_unlock(&hugetlb_lock);
++
++		ret = alloc_fresh_huge_page(h, nodes_allowed, &page_address);
++		printk(KERN_WARNING "fresh page address: %x\n", page_address);
++		spin_lock(&hugetlb_lock);
++		if (!ret)
++			goto out;
++
++		/* Bail for signals. Probably ctrl-c from user */
++		if (signal_pending(current))
++			goto out;
++	}
++
++	min_count = h->resv_huge_pages + h->nr_huge_pages - h->free_huge_pages;
++	min_count = max(count, min_count);
++	try_to_free_low(h, min_count, nodes_allowed);
++	while (min_count < persistent_huge_pages(h)) {
++		if (!free_pool_huge_page(h, nodes_allowed, 0))
++			break;
++	}
++	while (count < persistent_huge_pages(h)) {
++		if (!adjust_pool_surplus(h, nodes_allowed, 1))
++			break;
++	}
++out:
++	ret = persistent_huge_pages(h);
++	spin_unlock(&hugetlb_lock);
++	return ret;
++}
++#else
+ static unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,
+ 						nodemask_t *nodes_allowed)
+ {
+@@ -1337,6 +1590,7 @@
+ 	spin_unlock(&hugetlb_lock);
+ 	return ret;
+ }
++#endif // !POPSHM
+ 
+ #define HSTATE_ATTR_RO(_name) \
+ 	static struct kobj_attribute _name##_attr = __ATTR_RO(_name)
+@@ -1767,6 +2021,22 @@
+ 
+ static int __init hugetlb_init(void)
+ {
++#ifdef CONFIG_POPSHM
++	void* coreinfo_address;
++	int config_register_data, local_core_x, local_core_y;
++
++	coreinfo_address = ioremap_nocache(CRB_OWN + MYTILEID, sizeof(int));
++	if (coreinfo_address) {
++		config_register_data = readl(coreinfo_address);
++		local_core_x = (config_register_data >> 3) & 0x0f;
++		local_core_y = (config_register_data >> 7) & 0x0f;
++		local_core_z = (config_register_data) & 0x07;
++		local_core_id = ((local_core_x + (6 * local_core_y)) * 2) + local_core_z;
++
++		iounmap(coreinfo_address);
++	}
++#endif
++
+ 	/* Some platform decide whether they support huge pages at boot
+ 	 * time. On these, such as powerpc, HPAGE_SHIFT is set to 0 when
+ 	 * there is no such support
+@@ -1776,6 +2046,7 @@
+ 
+ 	if (!size_to_hstate(default_hstate_size)) {
+ 		default_hstate_size = HPAGE_SIZE;
++		printk(KERN_WARNING "hugepages size = %lu\n", default_hstate_size );
+ 		if (!size_to_hstate(default_hstate_size))
+ 			hugetlb_add_hstate(HUGETLB_PAGE_ORDER);
+ 	}
+@@ -1824,6 +2095,37 @@
+ 	parsed_hstate = h;
+ }
+ 
++#ifdef CONFIG_POPSHM
++static int __init hugetlb_nrpages_setup(char *s)
++{
++	unsigned long *mhp;
++	static unsigned long *last_mhp;
++
++	printk(KERN_WARNING "hugetlb_nrpages_setup\n");
++
++	if (!max_hstate)
++		mhp = &default_hstate_max_huge_pages;
++	else
++		mhp = &parsed_hstate->max_huge_pages;
++
++	if (mhp == last_mhp) {
++		printk(KERN_WARNING "popshmpages= specified twice without "
++			"interleaving hugepagesz=, ignoring\n");
++		return 1;
++	}
++
++	if (sscanf(s, "%lu", mhp) <= 0)
++		*mhp = 0;
++
++	if (max_hstate && parsed_hstate->order >= MAX_ORDER)
++		hugetlb_hstate_alloc_pages(parsed_hstate);
++
++	last_mhp = mhp;
++
++	return 1;
++}
++__setup("popshmpages=", hugetlb_nrpages_setup);
++#else
+ static int __init hugetlb_nrpages_setup(char *s)
+ {
+ 	unsigned long *mhp;
+@@ -1860,6 +2162,7 @@
+ 	return 1;
+ }
+ __setup("hugepages=", hugetlb_nrpages_setup);
++#endif
+ 
+ static int __init hugetlb_default_setup(char *s)
+ {
+@@ -1978,6 +2281,17 @@
+ void hugetlb_report_meminfo(struct seq_file *m)
+ {
+ 	struct hstate *h = &default_hstate;
++#ifdef CONFIG_POPSHM
++	seq_printf(m,
++			"POPSHM pages:    %5lu\n"
++			"POPSHM page size:    %5lu kB\n"
++			"POPSHM buffer size:  %5lu kB\n"
++			"POPSHM base address: 0x%08x\n",
++			h->nr_huge_pages/4,
++			POPSHMPAGE_SIZE/1024,
++			(HPAGE_SIZE * h->nr_huge_pages )/1024,
++			popshm_base_address);
++#else
+ 	seq_printf(m,
+ 			"HugePages_Total:   %5lu\n"
+ 			"HugePages_Free:    %5lu\n"
+@@ -1989,6 +2303,7 @@
+ 			h->resv_huge_pages,
+ 			h->surplus_huge_pages,
+ 			1UL << (huge_page_order(h) + PAGE_SHIFT - 10));
++#endif
+ }
+ 
+ int hugetlb_report_node_meminfo(int nid, char *buf)
+@@ -2353,12 +2668,14 @@
+ 			unsigned long address, pte_t *ptep, pte_t pte,
+ 			struct page *pagecache_page)
+ {
+-	struct hstate *h = hstate_vma(vma);
++	struct hstate *h;
+ 	struct page *old_page, *new_page;
+ 	int avoidcopy;
+ 	int outside_reserve = 0;
+ 
++	printk(KERN_WARNING "hugetlb_cow\n");
+ 	old_page = pte_page(pte);
++	h = hstate_vma(vma);
+ 
+ retry_avoidcopy:
+ 	/* If no-one else is actually using this page, avoid the copy
diff -urN buildroot-2011.11.orig/board/intel/scc/linux-3.1.4.config buildroot-2011.11/board/intel/scc/linux-3.1.4.config
--- buildroot-2011.11.orig/board/intel/scc/linux-3.1.4.config	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/linux-3.1.4.config	2011-12-21 10:36:44.000000000 +0100
@@ -0,0 +1,1127 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/i386 3.1.4 Kernel Configuration
+#
+# CONFIG_64BIT is not set
+CONFIG_X86_32=y
+# CONFIG_X86_64 is not set
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_OUTPUT_FORMAT="elf32-i386"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/i386_defconfig"
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA=y
+# CONFIG_NEED_DMA_MAP_STATE is not set
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+# CONFIG_GENERIC_TIME_VSYSCALL is not set
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_DEFAULT_IDLE=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+# CONFIG_HAVE_CPUMASK_OF_CPU_MAP is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_ZONE_DMA32 is not set
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+# CONFIG_AUDIT_ARCH is not set
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_X86_32_SMP=y
+CONFIG_X86_HT=y
+CONFIG_X86_32_LAZY_GS=y
+CONFIG_ARCH_HWEIGHT_CFLAGS="-fcall-saved-ecx -fcall-saved-edx"
+CONFIG_KTIME_SCALAR=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE="~/Desktop/buildroot-2011.02/output/host/usr/bin/i586-linux-"
+CONFIG_LOCALVERSION="scc"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_NONE=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_KERNEL_NONE=y
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_FORCED_THREADING=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+# CONFIG_CGROUPS is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="/home.local/jbrummer/sccLinux/buildroot-2011.11/output/images/rootfs.cpio"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_INITRAMFS_COMPRESSION_NONE is not set
+CONFIG_INITRAMFS_COMPRESSION_GZIP=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+# CONFIG_ELF_CORE is not set
+# CONFIG_PCSPKR_PLATFORM is not set
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+# CONFIG_BASE_FULL is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_SHMEM is not set
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=1
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_INLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+# CONFIG_FREEZER is not set
+
+#
+# Processor type and features
+#
+CONFIG_TICK_ONESHOT=y
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_SMP=y
+CONFIG_X86_MPPARSE=y
+CONFIG_X86_BIGSMP=y
+CONFIG_X86_EXTENDED_PLATFORM=y
+# CONFIG_X86_INTEL_MID is not set
+CONFIG_X86_SCC=y
+CONFIG_SCC_BUSCLOCK=533000000
+CONFIG_SCC_QUERY_FREQUENCY_FROM_FPGA=y
+CONFIG_X86_SCC_LAPIC_TRACK_CPU_FREQ=y
+CONFIG_X86_SCC_TSC_TRACK_CPU_FREQ=y
+CONFIG_SCCSYS=y
+CONFIG_SCCSYS_FPGA_CLOCK=y
+CONFIG_SCCSYS_RECURSIVE_PID_LOCK=y
+# CONFIG_X86_RDC321X is not set
+# CONFIG_X86_32_NON_STANDARD is not set
+# CONFIG_X86_32_IRIS is not set
+# CONFIG_SCHED_OMIT_FRAME_POINTER is not set
+CONFIG_PARAVIRT_GUEST=y
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+# CONFIG_XEN_PRIVILEGED_GUEST is not set
+# CONFIG_KVM_CLOCK is not set
+# CONFIG_KVM_GUEST is not set
+CONFIG_LGUEST_GUEST=y
+CONFIG_PARAVIRT=y
+# CONFIG_PARAVIRT_SPINLOCKS is not set
+# CONFIG_PARAVIRT_DEBUG is not set
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MEMTEST is not set
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+# CONFIG_M586 is not set
+CONFIG_M586TSC=y
+# CONFIG_M586MMX is not set
+# CONFIG_M686 is not set
+# CONFIG_MPENTIUMII is not set
+# CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+# CONFIG_MK8 is not set
+# CONFIG_MCRUSOE is not set
+# CONFIG_MEFFICEON is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MELAN is not set
+# CONFIG_MGEODEGX1 is not set
+# CONFIG_MGEODE_LX is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_MVIAC7 is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+# CONFIG_X86_GENERIC is not set
+CONFIG_X86_INTERNODE_CACHE_SHIFT=5
+CONFIG_X86_CMPXCHG=y
+CONFIG_CMPXCHG_LOCAL=y
+CONFIG_CMPXCHG_DOUBLE=y
+CONFIG_X86_L1_CACHE_SHIFT=5
+CONFIG_X86_XADD=y
+# CONFIG_X86_PPRO_FENCE is not set
+CONFIG_X86_F00F_BUG=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_ALIGNMENT_16=y
+CONFIG_X86_TSC=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=4
+# CONFIG_PROCESSOR_SELECT is not set
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_CYRIX_32=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_CPU_SUP_TRANSMETA_32=y
+CONFIG_CPU_SUP_UMC_32=y
+# CONFIG_HPET_TIMER is not set
+# CONFIG_DMI is not set
+# CONFIG_IOMMU_HELPER is not set
+CONFIG_NR_CPUS=32
+# CONFIG_SCHED_SMT is not set
+# CONFIG_SCHED_MC is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+# CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS is not set
+# CONFIG_X86_MCE is not set
+# CONFIG_VM86 is not set
+# CONFIG_TOSHIBA is not set
+# CONFIG_I8K is not set
+# CONFIG_X86_REBOOTFIXUPS is not set
+# CONFIG_MICROCODE is not set
+CONFIG_X86_MSR=y
+CONFIG_X86_CPUID=y
+# CONFIG_NOHIGHMEM is not set
+CONFIG_HIGHMEM4G=y
+# CONFIG_HIGHMEM64G is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_2G_OPT is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_HIGHMEM=y
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+# CONFIG_ARCH_DMA_ADDR_T_64BIT is not set
+CONFIG_NEED_NODE_MEMMAP_SIZE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+# CONFIG_ARCH_MEMORY_PROBE is not set
+CONFIG_ILLEGAL_POINTER_VALUE=0
+CONFIG_SELECT_MEMORY_MODEL=y
+# CONFIG_FLATMEM_MANUAL is not set
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_STATIC=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_MEMORY_HOTPLUG=y
+CONFIG_MEMORY_HOTPLUG_SPARSE=y
+CONFIG_MEMORY_HOTREMOVE=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_CLEANCACHE is not set
+# CONFIG_HIGHPTE is not set
+# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
+CONFIG_X86_RESERVE_LOW=64
+# CONFIG_MATH_EMULATION is not set
+# CONFIG_MTRR is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_HZ_100 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+CONFIG_HZ_1000=y
+CONFIG_HZ=1000
+CONFIG_SCHED_HRTICK=y
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_PHYSICAL_START=0x100000
+# CONFIG_RELOCATABLE is not set
+CONFIG_PHYSICAL_ALIGN=0x100000
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_COMPAT_VDSO is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="apic=debug mem=nopentium tsc=reliable"
+# CONFIG_CMDLINE_OVERRIDE is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE=y
+
+#
+# Power management and ACPI options
+#
+# CONFIG_SUSPEND is not set
+# CONFIG_HIBERNATION is not set
+# CONFIG_PM_RUNTIME is not set
+# CONFIG_SFI is not set
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_STAT is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+
+#
+# x86 CPU frequency scaling drivers
+#
+# CONFIG_X86_POWERNOW_K6 is not set
+# CONFIG_X86_POWERNOW_K7 is not set
+# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
+# CONFIG_X86_SPEEDSTEP_ICH is not set
+# CONFIG_X86_SPEEDSTEP_SMI is not set
+# CONFIG_X86_P4_CLOCKMOD is not set
+# CONFIG_X86_CPUFREQ_NFORCE2 is not set
+CONFIG_X86_SCCFREQ=y
+# CONFIG_X86_LONGRUN is not set
+# CONFIG_X86_E_POWERSAVER is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_INTEL_IDLE=y
+
+#
+# Bus options (PCI etc.)
+#
+# CONFIG_PCI is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_ISA_DMA_API=y
+# CONFIG_ISA is not set
+# CONFIG_MCA is not set
+# CONFIG_SCx200 is not set
+# CONFIG_OLPC is not set
+# CONFIG_PCCARD is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_HAVE_ATOMIC_IOMAP=y
+CONFIG_HAVE_TEXT_POKE_SMP=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/mdev"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_VIRTIO_BLK=y
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_MII is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_NET_ETHERNET is not set
+CONFIG_NETDEV_1000=y
+CONFIG_SCCMB=y
+# CONFIG_SCCMBX is not set
+CONFIG_SCCPC=y
+# CONFIG_SCCPC_DUMP_PACKETS is not set
+CONFIG_SCCEMAC=y
+# CONFIG_STMMAC_ETH is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_VIRTIO_NET is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_WISTRON_BTNS is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_SCCMEM=y
+CONFIG_SCCPERF=y
+CONFIG_SCCPROC=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_TTY_PRINTK is not set
+CONFIG_HVC_DRIVER=y
+CONFIG_VIRTIO_CONSOLE=y
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_R3964 is not set
+# CONFIG_MWAVE is not set
+# CONFIG_PC8736x_GPIO is not set
+# CONFIG_NSC_GPIO is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+# CONFIG_RAMOOPS is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+# CONFIG_MFD_SUPPORT is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_VESA is not set
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_SCCGFX=y
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+# CONFIG_FONT_8x8 is not set
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_EDAC is not set
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+CONFIG_VIRTIO=y
+CONFIG_VIRTIO_RING=y
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_STAGING is not set
+# CONFIG_X86_PLATFORM_DEVICES is not set
+CONFIG_CLKSRC_I8253=y
+CONFIG_CLKEVT_I8253=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_IOMMU_SUPPORT is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+# CONFIG_ISCSI_IBFT_FIND is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_FSNOTIFY is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY_USER is not set
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFS_USE_NEW_IDMAPPER is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_NLS is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=7
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_HARDLOCKUP_DETECTOR=y
+# CONFIG_BOOTPARAM_HARDLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=0
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+CONFIG_DEBUG_VM=y
+CONFIG_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_DEBUG_PER_CPU_MAPS=y
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+CONFIG_DYNAMIC_DEBUG=y
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+# CONFIG_KMEMCHECK is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+CONFIG_DEBUG_STACKOVERFLOW=y
+CONFIG_X86_PTDUMP=y
+CONFIG_DEBUG_RODATA=y
+CONFIG_DEBUG_RODATA_TEST=y
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+# CONFIG_DEBUG_NX_TEST is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+# CONFIG_IO_DELAY_0X80 is not set
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+CONFIG_IO_DELAY_NONE=y
+CONFIG_DEFAULT_IO_DELAY_TYPE=3
+CONFIG_DEBUG_BOOT_PARAMS=y
+# CONFIG_CPA_DEBUG is not set
+# CONFIG_OPTIMIZE_INLINING is not set
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+# CONFIG_CRYPTO is not set
+CONFIG_HAVE_KVM=y
+CONFIG_VIRTUALIZATION=y
+# CONFIG_VHOST_NET is not set
+# CONFIG_LGUEST is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+# CONFIG_CPUMASK_OFFSTACK is not set
+CONFIG_CPU_RMAP=y
+CONFIG_NLATTR=y
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
diff -urN buildroot-2011.11.orig/board/intel/scc/Makefile.in buildroot-2011.11/board/intel/scc/Makefile.in
--- buildroot-2011.11.orig/board/intel/scc/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/Makefile.in	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,5 @@
+ifeq ($(BR2_TARGET_SCC),y)
+SCC_PATH= target/device/scc
+
+TARGET_SKELETON=$(SCC_PATH)/target_skeleton
+endif
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/banner buildroot-2011.11/board/intel/scc/target_skeleton/etc/banner
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/banner	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/banner	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,10 @@
+
+
+ ____   ____ ____   _     _                  
+/ ___| / ___/ ___| | |   (_)_ __  _   ___  __
+\___ \| |  | |     | |   | | '_ \| | | \ \/ /
+ ___) | |__| |___  | |___| | | | | |_| |>  < 
+|____/ \____\____| |_____|_|_| |_|\__,_/_/\_\
+                                             
+
+
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/br-version buildroot-2011.11/board/intel/scc/target_skeleton/etc/br-version
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/br-version	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/br-version	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1 @@
+2010.11
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/fstab buildroot-2011.11/board/intel/scc/target_skeleton/etc/fstab
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/fstab	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/fstab	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,9 @@
+# /etc/fstab: static file system information.
+#
+# <file system> <mount pt>     <type>	<options>         <dump> <pass>
+/dev/root       /              ext2	rw,noauto         0      1
+proc		/proc	       proc     defaults	  0	 0
+devpts		/dev/pts       devpts   defaults,gid=5,mode=620	  0	 0
+tmpfs           /tmp           tmpfs    defaults          0      0
+sysfs		/sys	       sysfs    defaults	  0	 0
+rckhost:/shared	/shared	nfs	hard,intr,bg,rsize=4096,wsize=4096,nolock,tcp 0	0
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/group buildroot-2011.11/board/intel/scc/target_skeleton/etc/group
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/group	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/group	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,17 @@
+root:x:0:
+daemon:x:1:
+bin:x:2:
+sys:x:3:
+adm:x:4:
+tty:x:5:
+disk:x:6:
+wheel:x:10:root
+utmp:x:43:
+staff:x:50:
+haldaemon:x:68:
+dbus:x:81:
+netdev:x:82:
+nobody:x:99:
+nogroup:x:99:
+users:x:100:
+default:x:1000:
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/hostname buildroot-2011.11/board/intel/scc/target_skeleton/etc/hostname
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/hostname	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/hostname	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1 @@
+sccLinux
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/hosts buildroot-2011.11/board/intel/scc/target_skeleton/etc/hosts
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/hosts	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/hosts	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,51 @@
+127.0.0.1       localhost.localdomain   localhost
+
+192.168.0.1       rck00.in.rck.net rck00.rck rck00
+192.168.0.2       rck01.in.rck.net rck01.rck rck01
+192.168.0.3       rck02.in.rck.net rck02.rck rck02
+192.168.0.4       rck03.in.rck.net rck03.rck rck03
+192.168.0.5       rck04.in.rck.net rck04.rck rck04
+192.168.0.6       rck05.in.rck.net rck05.rck rck05
+192.168.0.7       rck06.in.rck.net rck06.rck rck06
+192.168.0.8       rck07.in.rck.net rck07.rck rck07
+192.168.0.9       rck08.in.rck.net rck08.rck rck08
+192.168.0.10      rck09.in.rck.net rck09.rck rck09
+192.168.0.11      rck10.in.rck.net rck10.rck rck10
+192.168.0.12      rck11.in.rck.net rck11.rck rck11
+192.168.0.13      rck12.in.rck.net rck12.rck rck12
+192.168.0.14      rck13.in.rck.net rck13.rck rck13
+192.168.0.15      rck14.in.rck.net rck14.rck rck14
+192.168.0.16      rck15.in.rck.net rck15.rck rck15
+192.168.0.17      rck16.in.rck.net rck16.rck rck16
+192.168.0.18      rck17.in.rck.net rck17.rck rck17
+192.168.0.19      rck18.in.rck.net rck18.rck rck18
+192.168.0.20      rck19.in.rck.net rck19.rck rck19
+192.168.0.21      rck20.in.rck.net rck20.rck rck20
+192.168.0.22      rck21.in.rck.net rck21.rck rck21
+192.168.0.23      rck22.in.rck.net rck22.rck rck22
+192.168.0.24      rck23.in.rck.net rck23.rck rck23
+192.168.0.25      rck24.in.rck.net rck24.rck rck24
+192.168.0.26      rck25.in.rck.net rck25.rck rck25
+192.168.0.27      rck26.in.rck.net rck26.rck rck26
+192.168.0.28      rck27.in.rck.net rck27.rck rck27
+192.168.0.29      rck28.in.rck.net rck28.rck rck28
+192.168.0.30      rck29.in.rck.net rck29.rck rck29
+192.168.0.31      rck30.in.rck.net rck30.rck rck30
+192.168.0.32      rck31.in.rck.net rck31.rck rck31
+192.168.0.33      rck32.in.rck.net rck32.rck rck32
+192.168.0.34      rck33.in.rck.net rck33.rck rck33
+192.168.0.35      rck34.in.rck.net rck34.rck rck34
+192.168.0.36      rck35.in.rck.net rck35.rck rck35
+192.168.0.37      rck36.in.rck.net rck36.rck rck36
+192.168.0.38      rck37.in.rck.net rck37.rck rck37
+192.168.0.39      rck38.in.rck.net rck38.rck rck38
+192.168.0.40      rck39.in.rck.net rck39.rck rck39
+192.168.0.41      rck40.in.rck.net rck40.rck rck40
+192.168.0.42      rck41.in.rck.net rck41.rck rck41
+192.168.0.43      rck42.in.rck.net rck42.rck rck42
+192.168.0.44      rck43.in.rck.net rck43.rck rck43
+192.168.0.45      rck44.in.rck.net rck44.rck rck44
+192.168.0.46      rck45.in.rck.net rck45.rck rck45
+192.168.0.47      rck46.in.rck.net rck46.rck rck46
+192.168.0.48      rck47.in.rck.net rck47.rck rck47
+
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/rcS buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/rcS
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/rcS	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/rcS	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,60 @@
+#!/bin/sh
+
+# ANSI COLORS
+CRE="$(echo -e '\r\033[K')"
+NORMAL="$(echo -e '\033[0;39m')"
+RED="$(echo -e '\033[1;31m')"
+GREEN="$(echo -e '\033[1;32m')"
+YELLOW="$(echo -e '\033[1;33m')"
+BLUE="$(echo -e '\033[1;34m')"
+MAGENTA="$(echo -e '\033[1;35m')"
+CYAN="$(echo -e '\033[1;36m')"
+WHITE="$(echo -e '\033[1;37m')"
+
+# Start all init scripts in /etc/init.d
+# executing them in numerical order.
+#
+for i in /etc/init.d/S??* ;do
+
+     # Ignore dangling symlinks (if any).
+     [ ! -f "$i" ] && continue
+
+     case "$i" in
+	*.sh)
+	    # Source shell script for speed.
+	    (
+		trap - INT QUIT TSTP
+		set start
+		. $i
+	    )
+	    ;;
+	*)
+	    # No sh extension, so fork subprocess.
+	    $i start
+	    ;;
+    esac
+done
+
+echo -n ${BLUE}
+cat /etc/banner
+echo -n ${NORMAL}
+
+KERNEL="$(uname -r)"
+echo "Running Linux Kernel $KERNEL."
+
+# Production testing
+if [ -f /shared/bootTest/.enabled ]
+then
+  core=`pid --pid | sed s/pid=//`
+  echo "%%%% checkMesh result:" > /shared/bootTest/results/PID$core.log
+  chmod 777 /shared/bootTest/results/PID$core.log
+  checkMesh >> /shared/bootTest/results/PID$core.log
+  echo "%%%% Paranoia results:" >> /shared/bootTest/results/PID$core.log
+  paranoia | grep "The number of  " >> /shared/bootTest/results/PID$core.log
+  cp /shared/bootTest/bin/stream_* /usr/bin/
+  echo "%%%% Checking L1$ (using stream)..." >> /shared/bootTest/results/PID$core.log
+  /usr/bin/stream_16KB_L1_x586 | grep "Solution Validates" >> /shared/bootTest/results/PID$core.log
+  echo "%%%% Checking L2$ (using stream)..." >> /shared/bootTest/results/PID$core.log
+  /usr/bin/stream_200KB_L2_n1000_x586 | grep "Solution Validates" >> /shared/bootTest/results/PID$core.log
+  echo "%%%% That's it..." >> /shared/bootTest/results/PID$core.log
+fi
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S01hotplug buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S01hotplug
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S01hotplug	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S01hotplug	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,14 @@
+#! /bin/sh
+
+echo -n "Setting up mdev: "
+set -e
+trap 'echo "failed"' EXIT
+/bin/ln -s /proc/self/fd /dev/fd
+/bin/ln -s /proc/self/fd/0 /dev/stdin
+/bin/ln -s /proc/self/fd/1 /dev/stdout
+/bin/ln -s /proc/self/fd/2 /dev/stderr
+/bin/ln -s /proc/kcore /dev/core
+/bin/echo /sbin/mdev > /proc/sys/kernel/hotplug
+/sbin/mdev -s
+trap - EXIT
+echo "done"
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S02hostname buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S02hostname
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S02hostname	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S02hostname	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,50 @@
+#!/bin/sh
+
+PROGRAM=/bin/hostname
+
+echo -n "Setting hostname: "
+[ -x ${PROGRAM} ] || (echo "missing"; exit 0)
+
+/usr/bin/pid > /dev/null 2>/dev/null
+if [ $? -eq 0 ]
+then
+	core=`pid --pid | sed s/pid=//`
+	HOST=rck$core
+else
+	HOST="rckemu"
+fi
+
+start() {
+	if ${PROGRAM} "${HOST}"; then
+		echo "'${HOST}'"
+	else
+		echo "failed"
+		exit 1
+	fi
+}
+
+stop() {
+	return 0
+}
+
+restart() {
+	stop
+	start
+}
+
+case "$1" in
+  start)
+        start
+        ;;
+  stop)
+        stop
+        ;;
+  restart|reload)
+        restart
+        ;;
+  *)
+        echo $"Usage: $0 {start|stop|restart}"
+        exit 1
+esac
+
+exit $?
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S08syslog buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S08syslog
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S08syslog	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S08syslog	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,24 @@
+#!/bin/sh
+
+SYSLOGD=/sbin/syslogd
+
+echo -n "Starting syslogd: "
+if [ ! -x "${SYSLOGD}" ]; then
+	echo "missing"
+	exit 1
+fi
+
+if ${SYSLOGD}; then
+	echo "done"
+else
+	echo "failed"
+	exit 1
+fi
+
+echo -n "Log messages to syslog: "
+if echo 4 4 1 7 > /proc/sys/kernel/printk; then
+	echo "done"
+else
+	echo "failed"
+	exit 1
+fi
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S09klog buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S09klog
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S09klog	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S09klog	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+KLOGD=/sbin/klogd
+
+echo -n "Starting klogd: "
+if [ ! -x "${KLOGD}" ]; then
+	echo "missing"
+	exit 1
+fi
+
+if ${KLOGD}; then
+	echo "done"
+else
+	echo "failed"
+	exit 1
+fi
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S20urandom buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S20urandom
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S20urandom	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S20urandom	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,54 @@
+#! /bin/sh
+#
+# urandom	This script saves the random seed between reboots.
+#		It is called from the boot, halt and reboot scripts.
+#
+# Version:	@(#)urandom  1.33  22-Jun-1998  miquels@cistron.nl
+#
+
+[ -c /dev/urandom ] || exit 0
+#. /etc/default/rcS
+
+case "$1" in
+	start|"")
+		if [ "$VERBOSE" != no ]
+		then
+			echo -n "Initializing random number generator... "
+		fi
+		# Load and then save 512 bytes,
+		# which is the size of the entropy pool
+		if [ -f /etc/random-seed ]
+		then
+			cat /etc/random-seed >/dev/urandom
+		fi
+		# check for read only file system
+		if ! touch /etc/random-seed 2>/dev/null
+		then
+			echo "read-only file system detected...done"
+			exit
+		fi
+		rm -f /etc/random-seed
+		umask 077
+		dd if=/dev/urandom of=/etc/random-seed count=1 \
+			>/dev/null 2>&1 || echo "urandom start: failed."
+		umask 022
+		[ "$VERBOSE" != no ] && echo "done."
+		;;
+	stop)
+		if ! touch /etc/random-seed 2>/dev/null
+                then
+                        exit
+                fi
+		# Carry a random seed from shut-down to start-up;
+		# see documentation in linux/drivers/char/random.c
+		[ "$VERBOSE" != no ] && echo -n "Saving random seed... "
+		umask 077
+		dd if=/dev/urandom of=/etc/random-seed count=1 \
+			>/dev/null 2>&1 || echo "urandom stop: failed."
+		[ "$VERBOSE" != no ] && echo "done."
+		;;
+	*)
+		echo "Usage: urandom {start|stop}" >&2
+		exit 1
+		;;
+esac
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S40network buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S40network
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S40network	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S40network	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,25 @@
+#!/bin/sh
+#
+# Start the network....
+#
+
+case "$1" in
+  start)
+ 	echo "Starting network..."
+	/sbin/ifup -a
+	;;
+  stop)
+	echo -n "Stopping network..."
+	/sbin/ifdown -a
+	;;
+  restart|reload)
+	"$0" stop
+	"$0" start
+	;;
+  *)
+	echo $"Usage: $0 {start|stop|restart}"
+	exit 1
+esac
+
+exit $?
+
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S41scc-network buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S41scc-network
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S41scc-network	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S41scc-network	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,113 @@
+#!/bin/sh
+
+CORE=`cat /proc/scc/pid`
+
+# start scc network
+ifconfig mb0 >/dev/null 2>/dev/null
+if [ $? -eq 0 ]
+then
+	## Let's use interrupts ...
+    echo 16384 > /sys/module/sccmb/parameters/mpb_stride
+    # on chip message passing buffer is at 8019:0000 - 801E:FFFF
+    echo 2149122048 > /sys/module/sccmb/parameters/mpb_offset
+    # Size of the Subnet behind the Host IP link. This does not have to reflect normal IP 
+    # routing rules ..
+    SUBNETSIZE=1
+
+    # On Chip IP
+    OCIP=$(expr $CORE + 1)
+
+    # Last Byte of HOST IF IP
+    # HIP=$(expr \( $core / 6 \) \* 8 + \( $core % 6 \) + 1)
+    HIP=$OCIP
+
+    # Last Byte of Router IP
+    RTIP=$(expr \( $CORE / $SUBNETSIZE \) \* $SUBNETSIZE + 1)
+
+    echo "Configuring on-chip network: mb0 (192.168.253.$OCIP R:192.168.253.$RTIP)"
+    RTNUM=$(expr 3232235520 + $RTIP)
+    echo $RTNUM > /sys/module/sccmb/parameters/routerIpAddress
+    ifconfig mb0 192.168.0.$OCIP up
+
+
+     if [ "$OCIP" != "$RTIP" ]
+     then
+        # wait a short while to stop all the cores hammering on rck00
+        sleep `expr 5 + $CORE / 2`
+        # setup the default gateway
+        route add -net 0.0.0.0/0 gw 192.168.0.$RTIP
+     else
+        # enabling IP forwarding
+        echo 1 > /proc/sys/net/ipv4/conf/all/forwarding
+     fi
+fi
+
+PORT=`emactool avail`
+if [ $PORT -eq 0 ] ; then
+   echo "Loading sccpc..."
+   modprobe sccpc
+   echo "Configuring host network: pc0 (192.168.1.$HIP)"
+   ifconfig pc0 192.168.1.$HIP
+   route add -net 0.0.0.0/0 gw 192.168.1.254
+   echo "192.168.1.254   rckhost.ex.rck.net rckhost.rck rckhost" >> /etc/hosts
+else
+   modprobe sccemac
+   BASEIP=`emactool ip`
+
+   # Set network ports to quadrants depending on numports
+
+   NCORES=48
+
+   NPORTS=`emactool numports`
+   PORT0=`emactool test 0`
+   PORT1=`emactool test 1`
+   PORT2=`emactool test 2`
+   PORT3=`emactool test 3`
+   IDX=0
+
+   NDIV=$(expr $NCORES / $NPORTS)
+   DIV=$(expr $CORE / $NDIV)
+
+   if [ $PORT0 -eq 1 ]
+     then
+       if [ $IDX -eq $DIV ]
+       then
+         DEVPORT=0
+       fi
+			IDX=$(expr $IDX + 1)
+		fi
+
+		if [ $PORT1 -eq 1 ]
+		then
+			if [ $IDX -eq $DIV ]
+			then
+				DEVPORT=1
+			fi
+			IDX=$(expr $IDX + 1)
+		fi
+
+		if [ $PORT2 -eq 1 ]
+		then
+			if [ $IDX -eq $DIV ]
+			then
+				DEVPORT=2
+			fi
+			IDX=$(expr $IDX + 1)
+		fi
+
+		if [ $PORT3 -eq 1 ]
+		then
+			if [ $IDX -eq $DIV ]
+			then
+				DEVPORT=3
+			fi
+			IDX=$(expr $IDX + 1)
+		fi
+
+   IP=${BASEIP%.*}"."$(expr ${BASEIP#*.*.*.} + $CORE)
+   echo "Configuring host network: emac$DEVPORT ($IP)"
+   ifconfig emac$DEVPORT $IP netmask 255.255.255.0
+   route add -net 0.0.0.0/0 gw `emactool gw`
+   echo `emactool host` "   rckhost.ex.rck.net rckhost.rck rckhost" >> /etc/hosts
+   echo "nameserver " `emactool host` >> /etc/resolv.conf
+fi
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S42mount buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S42mount
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S42mount	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S42mount	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+mount -a
\ No newline at end of file
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S45rhid buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S45rhid
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S45rhid	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S45rhid	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,39 @@
+#!/bin/sh
+#
+# Starts rhid.
+#
+
+# Make sure the rhid progam exists
+[ -f /usr/bin/rhid ] || exit 0
+
+start() {
+ 	echo -n "Starting rhid: "
+	/usr/bin/rhid &
+	echo "OK"
+}
+stop() {
+	echo -n "Stopping rhid: "
+	killall rhid
+	echo "OK"
+}
+restart() {
+	stop
+	start
+}
+
+case "$1" in
+  start)
+  	start
+	;;
+  stop)
+  	stop
+	;;
+  restart|reload)
+  	restart
+	;;
+  *)
+	echo $"Usage: $0 {start|stop|restart}"
+	exit 1
+esac
+
+exit $?
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S55gpm buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S55gpm
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S55gpm	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S55gpm	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,39 @@
+#!/bin/sh
+#
+# Starts gpm.
+#
+
+# Make sure the gpm progam exists
+[ -f /usr/sbin/gpm ] || exit 0
+
+start() {
+ 	echo -n "Starting gpm: "
+	/usr/sbin/gpm -m /dev/input/event1 -t evdev2 -R
+	echo "OK"
+}
+stop() {
+	echo -n "Stopping gpm: "
+	/usr/sbin/gpm -k
+	echo "OK"
+}
+restart() {
+	stop
+	start
+}
+
+case "$1" in
+  start)
+  	start
+	;;
+  stop)
+  	stop
+	;;
+  restart|reload)
+  	restart
+	;;
+  *)
+	echo $"Usage: $0 {start|stop|restart}"
+	exit 1
+esac
+
+exit $?
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S60cpuutil buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S60cpuutil
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/init.d/S60cpuutil	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/init.d/S60cpuutil	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,40 @@
+#!/bin/sh
+#
+# Starts cpuutil.
+#
+
+# Make sure the cpuutil progam exists
+[ -f /usr/bin/cpuutil ] || exit 0
+
+start() {
+	echo -n "Starting cpuutil: "
+	
+	/usr/bin/cpuutil -m &
+	echo "OK"
+}
+stop() {
+	echo -n "Stopping cpuutil: "
+	killall cpuutil
+	echo "OK"
+}
+restart() {
+	stop
+	start
+}
+
+case "$1" in
+  start)
+  	start
+	;;
+  stop)
+  	stop
+	;;
+  restart|reload)
+  	restart
+	;;
+  *)
+	echo $"Usage: $0 {start|stop|restart}"
+	exit 1
+esac
+
+exit $?
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/inittab buildroot-2011.11/board/intel/scc/target_skeleton/etc/inittab
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/inittab	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/inittab	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,26 @@
+# /etc/inittab
+#
+# Copyright (C) 2001 Erik Andersen <andersen@codepoet.org>
+#
+# Note: BusyBox init doesn't support runlevels.  The runlevels field is
+# completely ignored by BusyBox init. If you want runlevels, use
+# sysvinit.
+#
+# Format for each entry: <id>:<runlevels>:<action>:<process>
+#
+# id        == tty to run on, or empty for /dev/console
+# runlevels == ignored
+# action    == one of sysinit, respawn, askfirst, wait, and once
+# process   == program to run
+
+# Startup the system
+null::sysinit:/bin/mount -o remount,rw /
+null::sysinit:/bin/mount -t proc proc /proc
+null::sysinit:/bin/mkdir -p /dev/pts
+null::sysinit:/bin/mount -a
+null::sysinit:/bin/hostname -F /etc/hostname
+# now run any rc scripts
+::sysinit:/etc/init.d/rcS
+
+# Set up a tty
+tty1::respawn:-/bin/sh
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/inputrc buildroot-2011.11/board/intel/scc/target_skeleton/etc/inputrc
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/inputrc	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/inputrc	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,44 @@
+# /etc/inputrc - global inputrc for libreadline
+# See readline(3readline) and `info readline' for more information.
+
+# Be 8 bit clean.
+set input-meta on
+set output-meta on
+set bell-style visible
+
+# To allow the use of 8bit-characters like the german umlauts, comment out
+# the line below. However this makes the meta key not work as a meta key,
+# which is annoying to those which don't need to type in 8-bit characters.
+
+# set convert-meta off
+
+"\e0d": backward-word
+"\e0c": forward-word
+"\e[h": beginning-of-line
+"\e[f": end-of-line
+"\e[1~": beginning-of-line
+"\e[4~": end-of-line
+#"\e[5~": beginning-of-history
+#"\e[6~": end-of-history
+"\e[3~": delete-char
+"\e[2~": quoted-insert
+
+# Common standard keypad and cursor
+# (codes courtsey Werner Fink, <werner@suse.de>)
+#"\e[1~": history-search-backward
+"\e[2~": yank
+"\e[3~": delete-char
+#"\e[4~": set-mark
+"\e[5~": history-search-backward
+"\e[6~": history-search-forward
+# Normal keypad and cursor of xterm
+"\e[F": end-of-line
+"\e[H": beginning-of-line
+# Application keypad and cursor of xterm
+"\eOA": previous-history
+"\eOC": forward-char
+"\eOB": next-history
+"\eOD": backward-char
+"\eOF": end-of-line
+"\eOH": beginning-of-line
+
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/issue buildroot-2011.11/board/intel/scc/target_skeleton/etc/issue
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/issue	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/issue	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1 @@
+Welcome to SCC-Linux
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/mdev.conf buildroot-2011.11/board/intel/scc/target_skeleton/etc/mdev.conf
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/mdev.conf	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/mdev.conf	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,49 @@
+# mdev.conf for ATNGW100
+#
+# Syntax:
+#  <regexp> <UID>:<GID> <PERM> [{@,$,*} <CMD>]
+#    @: run <CMD> after creating
+#    $: run <CMD> before removal
+#    *: like @ and $ at the same time
+#    <CMD> is run inside /dev using system()
+
+full	0:0	666
+null	0:0	777
+zero	0:0	666
+
+random	0:0	444
+urandom	0:0	444
+
+console	0:5	0600
+kmem	0:9	000
+mem	0:9	0640
+ptmx	0:5	0660
+
+sda.*	0:6	0660
+sdb.*	0:6	0660
+hda.*	0:6	0660
+hdb.*	0:6	0660
+mtd.*	0:6	0660
+mmc.*	0:6	0660
+
+# Move input devices to input directory
+event.*	0:0	0660	@(mkdir -p input&&mv $MDEV input)
+mice	0:0	0660	@(mkdir -p input&&mv $MDEV input)
+mouse.*	0:0	0660	@(mkdir -p input&&mv $MDEV input)
+
+# Move sound devices to sound directory
+pcm.*		0:101	0660	@(mkdir -p snd&&mv $MDEV snd)
+seq		0:101	0660	@(mkdir -p snd&&mv $MDEV snd)
+timer		0:101	0660	@(mkdir -p snd&&mv $MDEV snd)
+control.*	0:101	0660	@(mkdir -p snd&&mv $MDEV snd)
+
+tty	0:5	0660
+tty0.*	0:5	0660
+tty1.*	0:5	0660
+tty2.*	0:5	0660
+tty3.*	0:5	0660
+tty4.*	0:5	0660
+tty5.*	0:5	0660
+tty6.*	0:5	0660
+
+ttyS.*	0:20	640
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/memstat.conf buildroot-2011.11/board/intel/scc/target_skeleton/etc/memstat.conf
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/memstat.conf	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/memstat.conf	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,14 @@
+/dev
+/bin
+/usr/bin
+/usr/local/bin
+/usr/X11R6/bin
+/lib
+/usr/lib
+/usr/local/lib
+/usr/X11R6/lib
+/sbin
+/usr/sbin
+/usr/local/sbin
+/lib/libc5-compat
+/usr/lib/libc5-compat
\ No newline at end of file
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/mke2fs.conf buildroot-2011.11/board/intel/scc/target_skeleton/etc/mke2fs.conf
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/mke2fs.conf	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/mke2fs.conf	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,44 @@
+[defaults]
+	base_features = sparse_super,filetype,resize_inode,dir_index,ext_attr
+	blocksize = 4096
+	inode_size = 256
+	inode_ratio = 16384
+
+[fs_types]
+	ext3 = {
+		features = has_journal
+	}
+	ext4 = {
+		features = has_journal,extent,huge_file,flex_bg,uninit_bg,dir_nlink,extra_isize
+		inode_size = 256
+	}
+	ext4dev = {
+		features = has_journal,extent,huge_file,flex_bg,uninit_bg,dir_nlink,extra_isize
+		inode_size = 256
+		options = test_fs=1
+	}
+	small = {
+		blocksize = 1024
+		inode_size = 128
+		inode_ratio = 4096
+	}
+	floppy = {
+		blocksize = 1024
+		inode_size = 128
+		inode_ratio = 8192
+	}
+	news = {
+		inode_ratio = 4096
+	}
+	largefile = {
+		inode_ratio = 1048576
+		blocksize = -1
+	}
+	largefile4 = {
+		inode_ratio = 4194304
+		blocksize = -1
+	}
+	hurd = {
+	     blocksize = 4096
+	     inode_size = 128
+	}
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/network/interfaces buildroot-2011.11/board/intel/scc/target_skeleton/etc/network/interfaces
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/network/interfaces	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/network/interfaces	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,3 @@
+# Configure Loopback
+auto lo
+iface lo inet loopback
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/passwd buildroot-2011.11/board/intel/scc/target_skeleton/etc/passwd
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/passwd	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/passwd	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,15 @@
+root:x:0:0:root:/root:/bin/sh
+daemon:x:1:1:daemon:/usr/sbin:/bin/sh
+bin:x:2:2:bin:/bin:/bin/sh
+sys:x:3:3:sys:/dev:/bin/sh
+sync:x:4:100:sync:/bin:/bin/sync
+mail:x:8:8:mail:/var/spool/mail:/bin/sh
+proxy:x:13:13:proxy:/bin:/bin/sh
+www-data:x:33:33:www-data:/var/www:/bin/sh
+backup:x:34:34:backup:/var/backups:/bin/sh
+operator:x:37:37:Operator:/var:/bin/sh
+haldaemon:x:68:68:hald:/:/bin/sh
+dbus:x:81:81:dbus:/var/run/dbus:/bin/sh
+nobody:x:99:99:nobody:/home:/bin/sh
+sshd:x:103:99:Operator:/var:/bin/sh
+default:x:1000:1000:Default non-root user:/home/default:/bin/sh
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/profile buildroot-2011.11/board/intel/scc/target_skeleton/etc/profile
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/profile	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/profile	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,39 @@
+# ~/.bashrc: executed by bash(1) for non-login interactive shells.
+
+export PATH=\
+/bin:\
+/sbin:\
+/usr/bin:\
+/usr/sbin:\
+/usr/bin/X11:\
+/usr/local/bin
+
+# If running interactively, then:
+if [ "$PS1" ]; then
+	export PS1="\h:\W # "
+	alias ll='/bin/ls --color=tty -laFh'
+	alias ls='/bin/ls --color=tty -F'
+	export LS_COLORS='no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.png=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.mpg=01;35:*.mpeg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:';
+
+    export USER=`id -un`
+    export LOGNAME=$USER
+    export HOSTNAME=`/bin/hostname`
+    export HISTSIZE=1000
+    export HISTFILESIZE=1000
+    export PAGER='/bin/more '
+    export EDITOR='/bin/vi'
+    export INPUTRC=/etc/inputrc
+    export DMALLOC_OPTIONS=debug=0x34f47d83,inter=100,log=logfile
+
+    ### Some aliases
+    alias ps2='ps facux '
+    alias ps1='ps faxo "%U %t %p %a" '
+    alias af='ps af'
+    alias cls='clear'
+    alias df='df -h'
+    alias indent='indent -bad -bap -bbo -nbc -br -brs -c33 -cd33 -ncdb -ce -ci4 -cli0 -cp33 -cs -d0 -di1 -nfc1 -nfca -hnl -i4 -ip0 -l75 -lp -npcs -npsl -nsc -nsob -nss -ts4 '
+    #alias bc='bc -l'
+    alias minicom='minicom -c on'
+    alias calc='calc -Cd '
+    alias bc='calc -Cd '
+fi;
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/protocols buildroot-2011.11/board/intel/scc/target_skeleton/etc/protocols
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/protocols	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/protocols	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,31 @@
+# /etc/protocols:
+# $Id: protocols,v 1.1 2004/10/09 02:49:18 andersen Exp $
+#
+# Internet (IP) protocols
+#
+#	from: @(#)protocols	5.1 (Berkeley) 4/17/89
+#
+# Updated for NetBSD based on RFC 1340, Assigned Numbers (July 1992).
+
+ip	0	IP		# internet protocol, pseudo protocol number
+icmp	1	ICMP		# internet control message protocol
+igmp	2	IGMP		# Internet Group Management
+ggp	3	GGP		# gateway-gateway protocol
+ipencap	4	IP-ENCAP	# IP encapsulated in IP (officially ``IP'')
+st	5	ST		# ST datagram mode
+tcp	6	TCP		# transmission control protocol
+egp	8	EGP		# exterior gateway protocol
+pup	12	PUP		# PARC universal packet protocol
+udp	17	UDP		# user datagram protocol
+hmp	20	HMP		# host monitoring protocol
+xns-idp	22	XNS-IDP		# Xerox NS IDP
+rdp	27	RDP		# "reliable datagram" protocol
+iso-tp4	29	ISO-TP4		# ISO Transport Protocol class 4
+xtp	36	XTP		# Xpress Tranfer Protocol
+ddp	37	DDP		# Datagram Delivery Protocol
+idpr-cmtp	39	IDPR-CMTP	# IDPR Control Message Transport
+rspf	73	RSPF		#Radio Shortest Path First.
+vmtp	81	VMTP		# Versatile Message Transport
+ospf	89	OSPFIGP		# Open Shortest Path First IGP
+ipip	94	IPIP		# Yet Another IP encapsulation
+encap	98	ENCAP		# Yet Another IP encapsulation
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/resolv.conf buildroot-2011.11/board/intel/scc/target_skeleton/etc/resolv.conf
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/resolv.conf	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/resolv.conf	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,2 @@
+domain rck
+search rck in.rck.net
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/securetty buildroot-2011.11/board/intel/scc/target_skeleton/etc/securetty
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/securetty	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/securetty	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,35 @@
+tty1
+tty2
+tty3
+tty4
+tty5
+tty6
+tty7
+tty8
+ttyS0
+ttyS1
+ttyS2
+ttyS3
+ttyAMA0
+ttyAMA1
+ttyAMA2
+ttyAMA3
+ttySAC0
+ttySAC1
+ttySAC2
+ttySAC3
+ttyUL0
+ttyUL1
+ttyUL2
+ttyUL3
+ttyPSC0
+ttyPSC1
+ttyPSC2
+ttyPSC3
+ttyCPM0
+ttyCPM1
+ttyCPM2
+ttyCPM3
+ttymxc0
+ttymxc1
+ttymxc2
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/services buildroot-2011.11/board/intel/scc/target_skeleton/etc/services
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/services	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/services	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,302 @@
+# /etc/services:
+# $Id: services,v 1.1 2004/10/09 02:49:18 andersen Exp $
+#
+# Network services, Internet style
+#
+# Note that it is presently the policy of IANA to assign a single well-known
+# port number for both TCP and UDP; hence, most entries here have two entries
+# even if the protocol doesn't support UDP operations.
+# Updated from RFC 1700, ``Assigned Numbers'' (October 1994).  Not all ports
+# are included, only the more common ones.
+
+tcpmux		1/tcp				# TCP port service multiplexer
+echo		7/tcp
+echo		7/udp
+discard		9/tcp		sink null
+discard		9/udp		sink null
+systat		11/tcp		users
+daytime		13/tcp
+daytime		13/udp
+netstat		15/tcp
+qotd		17/tcp		quote
+msp		18/tcp				# message send protocol
+msp		18/udp				# message send protocol
+chargen		19/tcp		ttytst source
+chargen		19/udp		ttytst source
+ftp-data	20/tcp
+ftp		21/tcp
+fsp		21/udp		fspd
+ssh		22/tcp				# SSH Remote Login Protocol
+ssh		22/udp				# SSH Remote Login Protocol
+telnet		23/tcp
+# 24 - private
+smtp		25/tcp		mail
+# 26 - unassigned
+time		37/tcp		timserver
+time		37/udp		timserver
+rlp		39/udp		resource	# resource location
+nameserver	42/tcp		name		# IEN 116
+whois		43/tcp		nicname
+re-mail-ck	50/tcp				# Remote Mail Checking Protocol
+re-mail-ck	50/udp				# Remote Mail Checking Protocol
+domain		53/tcp		nameserver	# name-domain server
+domain		53/udp		nameserver
+mtp		57/tcp				# deprecated
+bootps		67/tcp				# BOOTP server
+bootps		67/udp
+bootpc		68/tcp				# BOOTP client
+bootpc		68/udp
+tftp		69/udp
+gopher		70/tcp				# Internet Gopher
+gopher		70/udp
+rje		77/tcp		netrjs
+finger		79/tcp
+www		80/tcp		http		# WorldWideWeb HTTP
+www		80/udp				# HyperText Transfer Protocol
+link		87/tcp		ttylink
+kerberos	88/tcp		kerberos5 krb5	# Kerberos v5
+kerberos	88/udp		kerberos5 krb5	# Kerberos v5
+supdup		95/tcp
+# 100 - reserved
+hostnames	101/tcp		hostname	# usually from sri-nic
+iso-tsap	102/tcp		tsap		# part of ISODE.
+csnet-ns	105/tcp		cso-ns		# also used by CSO name server
+csnet-ns	105/udp		cso-ns
+# unfortunately the poppassd (Eudora) uses a port which has already
+# been assigned to a different service. We list the poppassd as an
+# alias here. This should work for programs asking for this service.
+# (due to a bug in inetd the 3com-tsmux line is disabled)
+#3com-tsmux	106/tcp		poppassd
+#3com-tsmux	106/udp		poppassd
+rtelnet		107/tcp				# Remote Telnet
+rtelnet		107/udp
+pop-2		109/tcp		postoffice	# POP version 2
+pop-2		109/udp
+pop-3		110/tcp				# POP version 3
+pop-3		110/udp
+sunrpc		111/tcp		portmapper	# RPC 4.0 portmapper TCP
+sunrpc		111/udp		portmapper	# RPC 4.0 portmapper UDP
+auth		113/tcp		authentication tap ident
+sftp		115/tcp
+uucp-path	117/tcp
+nntp		119/tcp		readnews untp	# USENET News Transfer Protocol
+ntp		123/tcp
+ntp		123/udp				# Network Time Protocol
+netbios-ns	137/tcp				# NETBIOS Name Service
+netbios-ns	137/udp
+netbios-dgm	138/tcp				# NETBIOS Datagram Service
+netbios-dgm	138/udp
+netbios-ssn	139/tcp				# NETBIOS session service
+netbios-ssn	139/udp
+imap2		143/tcp				# Interim Mail Access Proto v2
+imap2		143/udp
+snmp		161/udp				# Simple Net Mgmt Proto
+snmp-trap	162/udp		snmptrap	# Traps for SNMP
+cmip-man	163/tcp				# ISO mgmt over IP (CMOT)
+cmip-man	163/udp
+cmip-agent	164/tcp
+cmip-agent	164/udp
+xdmcp		177/tcp				# X Display Mgr. Control Proto
+xdmcp		177/udp
+nextstep	178/tcp		NeXTStep NextStep	# NeXTStep window
+nextstep	178/udp		NeXTStep NextStep	# server
+bgp		179/tcp				# Border Gateway Proto.
+bgp		179/udp
+prospero	191/tcp				# Cliff Neuman's Prospero
+prospero	191/udp
+irc		194/tcp				# Internet Relay Chat
+irc		194/udp
+smux		199/tcp				# SNMP Unix Multiplexer
+smux		199/udp
+at-rtmp		201/tcp				# AppleTalk routing
+at-rtmp		201/udp
+at-nbp		202/tcp				# AppleTalk name binding
+at-nbp		202/udp
+at-echo		204/tcp				# AppleTalk echo
+at-echo		204/udp
+at-zis		206/tcp				# AppleTalk zone information
+at-zis		206/udp
+qmtp		209/tcp				# The Quick Mail Transfer Protocol
+qmtp		209/udp				# The Quick Mail Transfer Protocol
+z3950		210/tcp		wais		# NISO Z39.50 database
+z3950		210/udp		wais
+ipx		213/tcp				# IPX
+ipx		213/udp
+imap3		220/tcp				# Interactive Mail Access
+imap3		220/udp				# Protocol v3
+ulistserv	372/tcp				# UNIX Listserv
+ulistserv	372/udp
+https		443/tcp				# MCom
+https		443/udp				# MCom
+snpp		444/tcp				# Simple Network Paging Protocol
+snpp		444/udp				# Simple Network Paging Protocol
+saft		487/tcp				# Simple Asynchronous File Transfer
+saft		487/udp				# Simple Asynchronous File Transfer
+npmp-local	610/tcp		dqs313_qmaster	# npmp-local / DQS
+npmp-local	610/udp		dqs313_qmaster	# npmp-local / DQS
+npmp-gui	611/tcp		dqs313_execd	# npmp-gui / DQS
+npmp-gui	611/udp		dqs313_execd	# npmp-gui / DQS
+hmmp-ind	612/tcp		dqs313_intercell# HMMP Indication / DQS
+hmmp-ind	612/udp		dqs313_intercell# HMMP Indication / DQS
+#
+# UNIX specific services
+#
+exec		512/tcp
+biff		512/udp		comsat
+login		513/tcp
+who		513/udp		whod
+shell		514/tcp		cmd		# no passwords used
+syslog		514/udp
+printer		515/tcp		spooler		# line printer spooler
+talk		517/udp
+ntalk		518/udp
+route		520/udp		router routed	# RIP
+timed		525/udp		timeserver
+tempo		526/tcp		newdate
+courier		530/tcp		rpc
+conference	531/tcp		chat
+netnews		532/tcp		readnews
+netwall		533/udp				# -for emergency broadcasts
+uucp		540/tcp		uucpd		# uucp daemon
+afpovertcp	548/tcp				# AFP over TCP
+afpovertcp	548/udp				# AFP over TCP
+remotefs	556/tcp		rfs_server rfs	# Brunhoff remote filesystem
+klogin		543/tcp				# Kerberized `rlogin' (v5)
+kshell		544/tcp		krcmd		# Kerberized `rsh' (v5)
+kerberos-adm	749/tcp				# Kerberos `kadmin' (v5)
+#
+webster		765/tcp				# Network dictionary
+webster		765/udp
+#
+# From ``Assigned Numbers'':
+#
+#> The Registered Ports are not controlled by the IANA and on most systems
+#> can be used by ordinary user processes or programs executed by ordinary
+#> users.
+#
+#> Ports are used in the TCP [45,106] to name the ends of logical
+#> connections which carry long term conversations.  For the purpose of
+#> providing services to unknown callers, a service contact port is
+#> defined.  This list specifies the port used by the server process as its
+#> contact port.  While the IANA can not control uses of these ports it
+#> does register or list uses of these ports as a convienence to the
+#> community.
+#
+nfsdstatus	1110/tcp
+nfsd-keepalive	1110/udp
+
+ingreslock	1524/tcp
+ingreslock	1524/udp
+prospero-np	1525/tcp			# Prospero non-privileged
+prospero-np	1525/udp
+datametrics	1645/tcp	old-radius	# datametrics / old radius entry
+datametrics	1645/udp	old-radius	# datametrics / old radius entry
+sa-msg-port	1646/tcp	old-radacct	# sa-msg-port / old radacct entry
+sa-msg-port	1646/udp	old-radacct	# sa-msg-port / old radacct entry
+radius		1812/tcp			# Radius
+radius		1812/udp			# Radius
+radacct		1813/tcp			# Radius Accounting
+radacct		1813/udp			# Radius Accounting
+nfsd		2049/tcp	nfs
+nfsd		2049/udp	nfs
+cvspserver	2401/tcp			# CVS client/server operations
+cvspserver	2401/udp			# CVS client/server operations
+mysql		3306/tcp			# MySQL
+mysql		3306/udp			# MySQL
+rfe		5002/tcp			# Radio Free Ethernet
+rfe		5002/udp			# Actually uses UDP only
+cfengine	5308/tcp			# CFengine
+cfengine	5308/udp			# CFengine
+bbs		7000/tcp			# BBS service
+#
+#
+# Kerberos (Project Athena/MIT) services
+# Note that these are for Kerberos v4, and are unofficial.  Sites running
+# v4 should uncomment these and comment out the v5 entries above.
+#
+kerberos4	750/udp		kerberos-iv kdc	# Kerberos (server) udp
+kerberos4	750/tcp		kerberos-iv kdc	# Kerberos (server) tcp
+kerberos_master	751/udp				# Kerberos authentication
+kerberos_master	751/tcp				# Kerberos authentication
+passwd_server	752/udp				# Kerberos passwd server
+krb_prop	754/tcp				# Kerberos slave propagation
+krbupdate	760/tcp		kreg		# Kerberos registration
+kpasswd		761/tcp		kpwd		# Kerberos "passwd"
+kpop		1109/tcp			# Pop with Kerberos
+knetd		2053/tcp			# Kerberos de-multiplexor
+zephyr-srv	2102/udp			# Zephyr server
+zephyr-clt	2103/udp			# Zephyr serv-hm connection
+zephyr-hm	2104/udp			# Zephyr hostmanager
+eklogin		2105/tcp			# Kerberos encrypted rlogin
+#
+# Unofficial but necessary (for NetBSD) services
+#
+supfilesrv	871/tcp				# SUP server
+supfiledbg	1127/tcp			# SUP debugging
+#
+# Datagram Delivery Protocol services
+#
+rtmp		1/ddp				# Routing Table Maintenance Protocol
+nbp		2/ddp				# Name Binding Protocol
+echo		4/ddp				# AppleTalk Echo Protocol
+zip		6/ddp				# Zone Information Protocol
+#
+# Services added for the Debian GNU/Linux distribution
+poppassd	106/tcp				# Eudora
+poppassd	106/udp				# Eudora
+mailq		174/tcp				# Mailer transport queue for Zmailer
+mailq		174/tcp				# Mailer transport queue for Zmailer
+omirr		808/tcp		omirrd		# online mirror
+omirr		808/udp		omirrd		# online mirror
+rmtcfg		1236/tcp			# Gracilis Packeten remote config server
+xtel		1313/tcp			# french minitel
+coda_opcons	1355/udp			# Coda opcons            (Coda fs)
+coda_venus	1363/udp			# Coda venus             (Coda fs)
+coda_auth	1357/udp			# Coda auth              (Coda fs)
+coda_udpsrv	1359/udp			# Coda udpsrv            (Coda fs)
+coda_filesrv	1361/udp			# Coda filesrv           (Coda fs)
+codacon		1423/tcp	venus.cmu	# Coda Console           (Coda fs)
+coda_aux1	1431/tcp			# coda auxiliary service (Coda fs)
+coda_aux1	1431/udp			# coda auxiliary service (Coda fs)
+coda_aux2	1433/tcp			# coda auxiliary service (Coda fs)
+coda_aux2	1433/udp			# coda auxiliary service (Coda fs)
+coda_aux3	1435/tcp			# coda auxiliary service (Coda fs)
+coda_aux3	1435/udp			# coda auxiliary service (Coda fs)
+cfinger		2003/tcp			# GNU Finger
+afbackup	2988/tcp			# Afbackup system
+afbackup	2988/udp			# Afbackup system
+icp		3130/tcp			# Internet Cache Protocol (Squid)
+icp		3130/udp			# Internet Cache Protocol (Squid)
+postgres	5432/tcp			# POSTGRES
+postgres	5432/udp			# POSTGRES
+fax		4557/tcp			# FAX transmission service        (old)
+hylafax		4559/tcp			# HylaFAX client-server protocol  (new)
+noclog		5354/tcp			# noclogd with TCP (nocol)
+noclog		5354/udp			# noclogd with UDP (nocol)
+hostmon		5355/tcp			# hostmon uses TCP (nocol)
+hostmon		5355/udp			# hostmon uses TCP (nocol)
+ircd		6667/tcp			# Internet Relay Chat
+ircd		6667/udp			# Internet Relay Chat
+webcache	8080/tcp			# WWW caching service
+webcache	8080/udp			# WWW caching service
+tproxy		8081/tcp			# Transparent Proxy
+tproxy		8081/udp			# Transparent Proxy
+mandelspawn	9359/udp	mandelbrot	# network mandelbrot
+amanda		10080/udp			# amanda backup services
+amandaidx	10082/tcp			# amanda backup services
+amidxtape	10083/tcp			# amanda backup services
+isdnlog		20011/tcp			# isdn logging system
+isdnlog		20011/udp			# isdn logging system
+vboxd		20012/tcp			# voice box system
+vboxd		20012/udp			# voice box system
+binkp           24554/tcp			# Binkley
+binkp           24554/udp			# Binkley
+asp		27374/tcp			# Address Search Protocol
+asp		27374/udp			# Address Search Protocol
+tfido           60177/tcp			# Ifmail
+tfido           60177/udp			# Ifmail
+fido            60179/tcp			# Ifmail
+fido            60179/udp			# Ifmail
+
+# Local services
+
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/shadow buildroot-2011.11/board/intel/scc/target_skeleton/etc/shadow
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/shadow	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/shadow	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,12 @@
+root::10933:0:99999:7:::
+bin:*:10933:0:99999:7:::
+daemon:*:10933:0:99999:7:::
+adm:*:10933:0:99999:7:::
+lp:*:10933:0:99999:7:::
+sync:*:10933:0:99999:7:::
+shutdown:*:10933:0:99999:7:::
+halt:*:10933:0:99999:7:::
+uucp:*:10933:0:99999:7:::
+operator:*:10933:0:99999:7:::
+nobody:*:10933:0:99999:7:::
+default::10933:0:99999:7:::
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_config buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_config
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_config	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_config	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,47 @@
+#	$OpenBSD: ssh_config,v 1.26 2010/01/11 01:39:46 dtucker Exp $
+
+# This is the ssh client system-wide configuration file.  See
+# ssh_config(5) for more information.  This file provides defaults for
+# users, and the values can be changed in per-user configuration files
+# or on the command line.
+
+# Configuration data is parsed as follows:
+#  1. command line options
+#  2. user-specific file
+#  3. system-wide file
+# Any configuration value is only changed the first time it is set.
+# Thus, host-specific definitions should be at the beginning of the
+# configuration file, and defaults at the end.
+
+# Site-wide defaults for some commonly used options.  For a comprehensive
+# list of available options, their meanings and defaults, please see the
+# ssh_config(5) man page.
+
+# Host *
+#   ForwardAgent no
+#   ForwardX11 no
+#   RhostsRSAAuthentication no
+#   RSAAuthentication yes
+#   PasswordAuthentication yes
+#   HostbasedAuthentication no
+#   GSSAPIAuthentication no
+#   GSSAPIDelegateCredentials no
+#   BatchMode no
+#   CheckHostIP yes
+#   AddressFamily any
+#   ConnectTimeout 0
+#   StrictHostKeyChecking ask
+#   IdentityFile ~/.ssh/identity
+#   IdentityFile ~/.ssh/id_rsa
+#   IdentityFile ~/.ssh/id_dsa
+#   Port 22
+#   Protocol 2,1
+#   Cipher 3des
+#   Ciphers aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,3des-cbc
+#   MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160
+#   EscapeChar ~
+#   Tunnel no
+#   TunnelDevice any:any
+#   PermitLocalCommand no
+#   VisualHostKey no
+#   ProxyCommand ssh -q -W %h:%p gateway.example.com
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/sshd_config buildroot-2011.11/board/intel/scc/target_skeleton/etc/sshd_config
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/sshd_config	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/sshd_config	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,118 @@
+#	$OpenBSD: sshd_config,v 1.82 2010/09/06 17:10:19 naddy Exp $
+
+# This is the sshd server system-wide configuration file.  See
+# sshd_config(5) for more information.
+
+# This sshd was compiled with PATH=/usr/bin:/bin:/usr/sbin:/sbin
+
+# The strategy used for options in the default sshd_config shipped with
+# OpenSSH is to specify options with their default value where
+# possible, but leave them commented.  Uncommented options change a
+# default value.
+
+#Port 22
+#AddressFamily any
+#ListenAddress 0.0.0.0
+#ListenAddress ::
+
+# The default requires explicit activation of protocol 1
+#Protocol 2
+
+# HostKey for protocol version 1
+#HostKey /etc/ssh_host_key
+# HostKeys for protocol version 2
+#HostKey /etc/ssh_host_rsa_key
+#HostKey /etc/ssh_host_dsa_key
+#HostKey /etc/ssh_host_ecdsa_key
+
+# Lifetime and size of ephemeral version 1 server key
+#KeyRegenerationInterval 1h
+#ServerKeyBits 1024
+
+# Logging
+# obsoletes QuietMode and FascistLogging
+#SyslogFacility AUTH
+#LogLevel INFO
+
+# Authentication:
+
+#LoginGraceTime 2m
+#PermitRootLogin yes
+#StrictModes yes
+#MaxAuthTries 6
+#MaxSessions 10
+
+#RSAAuthentication yes
+#PubkeyAuthentication yes
+#AuthorizedKeysFile	.ssh/authorized_keys
+
+# For this to work you will also need host keys in /etc/ssh_known_hosts
+#RhostsRSAAuthentication no
+# similar for protocol version 2
+#HostbasedAuthentication no
+# Change to yes if you don't trust ~/.ssh/known_hosts for
+# RhostsRSAAuthentication and HostbasedAuthentication
+#IgnoreUserKnownHosts no
+# Don't read the user's ~/.rhosts and ~/.shosts files
+#IgnoreRhosts yes
+
+# To disable tunneled clear text passwords, change to no here!
+#PasswordAuthentication yes
+#PermitEmptyPasswords no
+
+# Change to no to disable s/key passwords
+#ChallengeResponseAuthentication yes
+
+# Kerberos options
+#KerberosAuthentication no
+#KerberosOrLocalPasswd yes
+#KerberosTicketCleanup yes
+#KerberosGetAFSToken no
+
+# GSSAPI options
+#GSSAPIAuthentication no
+#GSSAPICleanupCredentials yes
+
+# Set this to 'yes' to enable PAM authentication, account processing, 
+# and session processing. If this is enabled, PAM authentication will 
+# be allowed through the ChallengeResponseAuthentication and
+# PasswordAuthentication.  Depending on your PAM configuration,
+# PAM authentication via ChallengeResponseAuthentication may bypass
+# the setting of "PermitRootLogin without-password".
+# If you just want the PAM account and session checks to run without
+# PAM authentication, then enable this but set PasswordAuthentication
+# and ChallengeResponseAuthentication to 'no'.
+#UsePAM no
+
+AllowAgentForwarding yes
+AllowTcpForwarding yes
+#GatewayPorts no
+X11Forwarding yes
+X11DisplayOffset 10
+X11UseLocalhost no
+#PrintMotd yes
+#PrintLastLog yes
+#TCPKeepAlive yes
+#UseLogin no
+#UsePrivilegeSeparation yes
+#PermitUserEnvironment no
+#Compression delayed
+#ClientAliveInterval 0
+#ClientAliveCountMax 3
+#UseDNS yes
+#PidFile /var/run/sshd.pid
+#MaxStartups 10
+#PermitTunnel no
+#ChrootDirectory none
+
+# no default banner path
+#Banner none
+
+# override default of no subsystems
+Subsystem	sftp	/usr/lib/sftp-server
+
+# Example of overriding settings on a per-user basis
+#Match User anoncvs
+#	X11Forwarding no
+#	AllowTcpForwarding no
+#	ForceCommand cvs server
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_host_dsa_key buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_host_dsa_key
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_host_dsa_key	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_host_dsa_key	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,12 @@
+-----BEGIN DSA PRIVATE KEY-----
+MIIBugIBAAKBgQCpqEkkbd/1SgfO607FHA/rQaU2oREhcjHevbXoQaL5sd1LLXBa
+6xZwcFNFSF6S9QX+G/0KcIv3/tyQTPe5R3HuV8s+ZgneY73Rdp9S/eO4goLZROBz
+aqC3QtQW8YTM5DmVpQpzIVobUTzT4O2gWxeU5Ok7IMo3IWBrl5/EgSLRMQIVAO9x
+XmrhF5ogxy73T107czUmzw3zAoGAM7OYSz9bCA02Z3Jx+gJgdY35NuP2eVzUEPdc
+LxzncoFVkQTHBWI4gnLbQvhm4NwfsbgXpUeYKnOP2aXSh7mGBmRQMr+iDEoDTCIy
+Gk1CnBwMhyDNYZzzkvBa4xZjNRIvj0KutAKBT0XnMxWUqxbiviJ2qbAg/UXYgeZM
+ZQmOSb8CgYBwK1jY7393FJ2j1I18bOSgCRFtv6SaN1HkyzGd8vjEhP8RVfjB+9fa
++3sZI4IIXPvHWXmbdtfKfIc2CWzzOSDaqAvKRn0s++HT560Hs2Pt/YaItvQwagQf
+1QxHSXFXiYN5YkHtY26z2BI1RBFkddVy77TbGS5/suzq6pgZ8ZzmUQIUdnTZ0Qmh
+I85RLPTDYvVrvnybM9Y=
+-----END DSA PRIVATE KEY-----
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_host_dsa_key.pub buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_host_dsa_key.pub
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_host_dsa_key.pub	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_host_dsa_key.pub	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1 @@
+ssh-dss AAAAB3NzaC1kc3MAAACBAKmoSSRt3/VKB87rTsUcD+tBpTahESFyMd69tehBovmx3UstcFrrFnBwU0VIXpL1Bf4b/Qpwi/f+3JBM97lHce5Xyz5mCd5jvdF2n1L947iCgtlE4HNqoLdC1BbxhMzkOZWlCnMhWhtRPNPg7aBbF5Tk6TsgyjchYGuXn8SBItExAAAAFQDvcV5q4ReaIMcu909dO3M1Js8N8wAAAIAzs5hLP1sIDTZncnH6AmB1jfk24/Z5XNQQ91wvHOdygVWRBMcFYjiCcttC+Gbg3B+xuBelR5gqc4/ZpdKHuYYGZFAyv6IMSgNMIjIaTUKcHAyHIM1hnPOS8FrjFmM1Ei+PQq60AoFPReczFZSrFuK+InapsCD9RdiB5kxlCY5JvwAAAIBwK1jY7393FJ2j1I18bOSgCRFtv6SaN1HkyzGd8vjEhP8RVfjB+9fa+3sZI4IIXPvHWXmbdtfKfIc2CWzzOSDaqAvKRn0s++HT560Hs2Pt/YaItvQwagQf1QxHSXFXiYN5YkHtY26z2BI1RBFkddVy77TbGS5/suzq6pgZ8ZzmUQ== 
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_host_ecdsa_key buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_host_ecdsa_key
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_host_ecdsa_key	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_host_ecdsa_key	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,5 @@
+-----BEGIN EC PRIVATE KEY-----
+MHcCAQEEIPWLwRAUQf9C+SZHEPBBOd2qbDct3YDlpaczeSr66Sg0oAoGCCqGSM49
+AwEHoUQDQgAENOwmnQDX5+jtg+MVQKHBEeV3eqf3c2xU52KC6aY3sYaSmG077gVf
+7ROjyjFn7eEJ1Ld0r6fANm0N7VcgkxUk/g==
+-----END EC PRIVATE KEY-----
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_host_ecdsa_key.pub buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_host_ecdsa_key.pub
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_host_ecdsa_key.pub	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_host_ecdsa_key.pub	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1 @@
+ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4= 
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_host_key.pub buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_host_key.pub
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_host_key.pub	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_host_key.pub	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1 @@
+2048 65537 22612172734469514687200137122895553201220252575443552955261233369568430677494959410141477548662417980803077327909023172108852621351573323256369354623278854151985051114622381562625003314111717573760927160997249720393100913538656367395497472011117339372375187213714386263283024089967968265001628099787841390341562839083129066056485270388989949434730669281938579379193341030794703460914871539861545728168728575700855880992623025237011361844335902228707153927333641670123069285516558642234958339794316597717677588193691949539629430383936334493048353391585417602515859721518868380630260517298608335823289912319465044832741 
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_host_rsa_key buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_host_rsa_key
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_host_rsa_key	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_host_rsa_key	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEowIBAAKCAQEA0+bVubmYxaFHo91QY4dSJDrIz4/RyNWPLnlmkQviTLlD9IWl
+oxOAIbsC0vuq+Qq1QNQUMz7bXYD67pkQHqnVkf8TbQTL4sjK6UnvMbvf7zlixAA+
+cyslt2Qdami9wmiy3hYe7AOrGoxWLHl9G14ZajnUlckCM5cccezDQEYLv6AJlltO
+XY6NgaWbFyuuvO6MR95UCfcePl0dEUO86UOQPPdLNid0L26krmHbqwfFKbzJYshq
+CN9c2PNGhFn8+cAdNtrty8MG7I/tMmwHs1qSbh7H3Z1/YSLzQY4/0rzfWZvMVEzx
+FGsHQ5Z2fT7kmQbCXE+lCqW1GWTTfgri458DFQIDAQABAoIBABqcNF68Zej7lemI
+E15MUg5mq20VXHziBLcLW8v/OA32fggo+GIAQuj5eSNRo2je5WAcweSlkhqt5dUs
+t4+COGW7KI9aONhj6sddF4KhWz/JbxO6DB2eX4AmPGNuf9X4G+4zzPJKi6Qr126C
+WymiqYJjfMTKl1IvOc08tFBP+422qoEmnN/fvOt+hD7tyxQTCeDc3N2MSHf+hkFm
+HcQrE53Q949DLhlMoJTkQTosp2ki/ifmWPuILylzGJSbf6CRFvxYiXIxEtf5mOhM
+QNpynFx04q3bHf4FiBuWBN6RuZFSyEaAU6QIQGH4xnJliN/Qo8/afrYssNugWM15
+wzZGS0ECgYEA/ukuA5HV5VuMy87uTLF6yfrr+YjzFNq534zxT3x+jKdRth2lWWGC
+8lmZv4BiL+sb6EgekLiuLwWcERent1gk2kntWK3V784TMUW01rSHNPpiYHABOk2e
+Dh1XelNnz3V70rmFfgvsVkTjbCJH/Roo44IVYrX4M82lhRqzoJeNC6kCgYEA1M6c
+plsZfs1Wt9iBwMv+Lk17yXnzPTPj/p+fCSGXi01Wx6qerftP/DDsAJf0upP4TvEX
+MGm5hl0hhPCk85KHbg453DOvGHSDDVzYv+954T6xa2L6hlzhlgk10vqd6ErDSuAA
+bjtTMVSD3wUNEwBn7eRrsxloqsfyLoqUJH8pP40CgYBqcicD2JdQYo2F4hCCuC5F
+P+HgXv7a+4dYwbtW7O7Pf2NQwEp265BJ8X6RiGP4DJ6nvc39sxERk68bOBySJF2n
+Re219Ul8DTrYfXpJmjNHvTLtgHgSx6yzyi7oZwHXkQC2+z+yZfo4ACZT1nDnUVA3
+yO9zO/e8ciinT4IpEoAUmQKBgQCX+1tLP+KsedAGCt1YKRhGT1Yp5St/uVCKZ8t4
+BQKrHTft73/WN5a/QN0760p/+e+ryWlLTSaPvHGU9RyJTEvmoMhX6J2TdJqn73hp
+U4mTAWhKjmzniuwdcER9gjlGTia9kc8c6seWgoqPu5bDzFVtQ+ZbCbmDxrrC3HvC
+uQJnfQKBgEyeQnIOMuDHRVJW0/O2XfKaGPilwY6xrqdB7ZtPnXp0+X0s+byoZnDi
+eWHmxaXOhNKog4+iKRqT6aaj9hmvXwQ5daqiN3CbT5MuDZihl3FQ08rEmChVYDVR
+UNhljkRQHGov2ZHDS4Tp2Vy3l33jPuXXvwsIRpS64H/crfsoWmm3
+-----END RSA PRIVATE KEY-----
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_host_rsa_key.pub buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_host_rsa_key.pub
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/ssh_host_rsa_key.pub	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/ssh_host_rsa_key.pub	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1 @@
+ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDT5tW5uZjFoUej3VBjh1IkOsjPj9HI1Y8ueWaRC+JMuUP0haWjE4AhuwLS+6r5CrVA1BQzPttdgPrumRAeqdWR/xNtBMviyMrpSe8xu9/vOWLEAD5zKyW3ZB1qaL3CaLLeFh7sA6sajFYseX0bXhlqOdSVyQIzlxxx7MNARgu/oAmWW05djo2BpZsXK6687oxH3lQJ9x4+XR0RQ7zpQ5A890s2J3QvbqSuYdurB8UpvMliyGoI31zY80aEWfz5wB022u3Lwwbsj+0ybAezWpJuHsfdnX9hIvNBjj/SvN9Zm8xUTPEUawdDlnZ9PuSZBsJcT6UKpbUZZNN+CuLjnwMV 
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/TZ buildroot-2011.11/board/intel/scc/target_skeleton/etc/TZ
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/etc/TZ	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/etc/TZ	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1 @@
+MST7MDT
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/root/.ashrc buildroot-2011.11/board/intel/scc/target_skeleton/root/.ashrc
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/root/.ashrc	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/root/.ashrc	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,14 @@
+###########################
+# Set system vars        #
+##########################
+export PS1="\u@`hostname`:\w\> "
+
+##########################
+# Define some aliases    #
+##########################
+
+# Misc
+alias ll="ls -al"
+alias .='source'
+
+#alias ssh="ssh -i /root/.ssh/identity"
\ No newline at end of file
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/root/.ssh/authorized_keys buildroot-2011.11/board/intel/scc/target_skeleton/root/.ssh/authorized_keys
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/root/.ssh/authorized_keys	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/root/.ssh/authorized_keys	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,2 @@
+ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgwCesdu3dLsnAlu6kES0l6tkWp/kH3Qq5LkLNlmbOxZ/yUsjS8O/x+zRIyMm7fUHKO7hF1vrzWuAOuD0hhP7VHwIob7S/NB+vI13zYbtQq5ZzGEfpjG2mKJIKn7w8OxEAPwePGfoQWgoPKzvauIG9O9+FidUkIK/WG6vJ3M/GLIwjGFv root@rckhost
+ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAzN00GtafaJFTM4rQxh7sfUOd6hNweWm/lGUDae/k8QJPInbSvJAJH97ebludUUmVsNRKhCGElzl/9Ufi4wwy87EEwY/3OgTviZDSIr7goOkdW9Nbn85tEmIu7CAGg/MpKbp6iEnVyfOixVQuVzveU9E5nMHVYkF+CuLBZ+ZaOmDDL52XLGCkEOkCfnciDXA+8woSPOErYho+Jhtz0gHPopl6LBPEraAMI7e88C+EXJfP3x/yQsyHEW90vmh9ad7kMQTUH+rEeHMFLBvIC25nY12SbyWNWYsnV3u9TOU9Mb5Pms/0GkDVhWPJ3Tiw1INTeHI0fydwvEvTPcnMWD3Maw== root@rckhost
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/root/.ssh/identity.pub buildroot-2011.11/board/intel/scc/target_skeleton/root/.ssh/identity.pub
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/root/.ssh/identity.pub	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/root/.ssh/identity.pub	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1 @@
+ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgwCesdu3dLsnAlu6kES0l6tkWp/kH3Qq5LkLNlmbOxZ/yUsjS8O/x+zRIyMm7fUHKO7hF1vrzWuAOuD0hhP7VHwIob7S/NB+vI13zYbtQq5ZzGEfpjG2mKJIKn7w8OxEAPwePGfoQWgoPKzvauIG9O9+FidUkIK/WG6vJ3M/GLIwjGFv root@rckemu
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/root/.ssh/id_rsa buildroot-2011.11/board/intel/scc/target_skeleton/root/.ssh/id_rsa
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/root/.ssh/id_rsa	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/root/.ssh/id_rsa	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEogIBAAKCAQEAzN00GtafaJFTM4rQxh7sfUOd6hNweWm/lGUDae/k8QJPInbS
+vJAJH97ebludUUmVsNRKhCGElzl/9Ufi4wwy87EEwY/3OgTviZDSIr7goOkdW9Nb
+n85tEmIu7CAGg/MpKbp6iEnVyfOixVQuVzveU9E5nMHVYkF+CuLBZ+ZaOmDDL52X
+LGCkEOkCfnciDXA+8woSPOErYho+Jhtz0gHPopl6LBPEraAMI7e88C+EXJfP3x/y
+QsyHEW90vmh9ad7kMQTUH+rEeHMFLBvIC25nY12SbyWNWYsnV3u9TOU9Mb5Pms/0
+GkDVhWPJ3Tiw1INTeHI0fydwvEvTPcnMWD3MawIBIwKCAQEAu03mfvAct2BMEd4A
+tSOWY+YMuMFQ5AjprD8ZEGZNqSauwGyjapJRfDl66I5GsLhOWIeUlhAEMn220aDP
+cIAulako63xPwASDO/IfNbXUsGAa15yristcaJRIKFfLcVNY1bHPHYVVv/SyE4Aq
+XmKfYpNn38cpfmfDsi5nr3OFsbXrH4GZNWJDBG+U5x7bq3LYd3BqSTWHVrI43dWo
+t9ITCku2LG+DomF3tVyTzUKXpS9cdN1Rsa80I2gmYVQ+awY+LPthCK4Tzhl+Nc1d
+XlJQBjYL/7fhBZsegj0trLF1WvAxFX/Rnv0R4dL+fb0ZetdWVBj0ejZJvfoWq8We
+dsZtiwKBgQDlpi+j/r0G70u6ac4e5iOcTE82xYHAu9YBurM0q3dMZZ+bDifODoMY
+v9jp+pEfZgilZrMPmfmiNIve+45dh5bE/uNPFj8gobvabg911YmXJPDh/vHPHuRs
+Rgaq8Qo1wXNxz+TqOI0P5RZGmi2swZk34PZoEZHK+tt3k6cuh501cwKBgQDkXvgz
+m0Aj1MM9N99C48cF5BfnN0zen3FOOMaOnXy+abcP3VH+pYJYdYGRTR2PGeNdWJrR
+TntD1imryGX7nTlLMO6S6C0+LUtIszO0FrrIt6GTUIKgHIURswIoZvjvFNQoG2c8
+m876EU686YQwNI6VK4CBB+pFGabS3kJ4frePKQKBgA0fcG/FaeMjne1lIbifb7/J
+2KQLST42noPBhpVLoGrD+n3jjT75g9WHTjlBhKK1X5RsRL8QHOSyi6ZXhHpfhPVQ
+ZMKw0GhDwZd0AOIpdZObtf5JFSHHQECzi1o5qM/fKysTMab76s21UbrkPR/QjGmX
+05DrD6Uy5/g0UrIzopVXAoGAe/kKZShkpbykgFGH09q8f4pzYEKXcYnBKnaXrIFg
++acaO8/qrs7gW+gEghPreZG18NhUCzk7mdqo6DmWcqXOpSkxDevAyftUwRDS7Lvh
+vWr/8OKQDcZW3bjyivYSG2MUFcW7szACpQIUzPPLaqAwJRedh9+5sHujtEzE/5U/
+EzMCgYEAhc1VIdwApFKbHnNY/87ESB90YYtUFYHp+bqb3j72dlMd2ZjWp5BOeQZH
+5lXvho0hR3za79NxCASzujHMOg1cT8A8pMipywI/qaowvSH5UUw+iUlV85vX7E+a
+PPxZDcVXjaiyBn7wuS2ZLeyY4Ml7P9OgHcuQt6C2eM/eR4/87Yw=
+-----END RSA PRIVATE KEY-----
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/root/.ssh/known_hosts buildroot-2011.11/board/intel/scc/target_skeleton/root/.ssh/known_hosts
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/root/.ssh/known_hosts	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/root/.ssh/known_hosts	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,48 @@
+rck00,192.168.0.1 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck01,192.168.0.2 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck02,192.168.0.3 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck03,192.168.0.4 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck04,192.168.0.5 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck05,192.168.0.6 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck06,192.168.0.7 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck07,192.168.0.8 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck08,192.168.0.9 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck09,192.168.0.10 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck10,192.168.0.11 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck11,192.168.0.12 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck12,192.168.0.13 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck13,192.168.0.14 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck14,192.168.0.15 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck15,192.168.0.16 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck16,192.168.0.17 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck17,192.168.0.18 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck18,192.168.0.19 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck19,192.168.0.20 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck20,192.168.0.21 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck21,192.168.0.22 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck22,192.168.0.23 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck23,192.168.0.24 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck24,192.168.0.25 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck25,192.168.0.26 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck26,192.168.0.27 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck27,192.168.0.28 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck28,192.168.0.29 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck29,192.168.0.30 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck30,192.168.0.31 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck31,192.168.0.32 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck32,192.168.0.33 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck33,192.168.0.34 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck34,192.168.0.35 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck35,192.168.0.36 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck36,192.168.0.37 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck37,192.168.0.38 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck38,192.168.0.39 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck39,192.168.0.40 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck40,192.168.0.41 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck41,192.168.0.42 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck42,192.168.0.43 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck43,192.168.0.44 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck44,192.168.0.45 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck45,192.168.0.46 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck46,192.168.0.47 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
+rck47,192.168.0.48 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDTsJp0A1+fo7YPjFUChwRHld3qn93NsVOdigummN7GGkphtO+4FX+0To8oxZ+3hCdS3dK+nwDZtDe1XIJMVJP4=
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/usr/bin/imaze buildroot-2011.11/board/intel/scc/target_skeleton/usr/bin/imaze
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/usr/bin/imaze	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/usr/bin/imaze	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,2 @@
+#!/bin/sh
+/usr/games/imaze -S /usr/share/games/imaze/sounds -H rck00
diff -urN buildroot-2011.11.orig/board/intel/scc/target_skeleton/usr/bin/sccdsp buildroot-2011.11/board/intel/scc/target_skeleton/usr/bin/sccdsp
--- buildroot-2011.11.orig/board/intel/scc/target_skeleton/usr/bin/sccdsp	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/board/intel/scc/target_skeleton/usr/bin/sccdsp	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,23 @@
+#!/bin/sh
+
+PULSE_SERVER=rckhost
+export PULSE_SERVER
+
+if [ -e "/tmp/audio" ]
+then
+	PADSP_MUTE=0
+else
+	PADSP_MUTE=1
+fi
+
+export PADSP_MUTE
+
+if [ x"$LD_PRELOAD" = x ] ; then
+   LD_PRELOAD="libpulsedsp.so"
+else
+   LD_PRELOAD="$LD_PRELOAD libpulsedsp.so"
+fi
+
+export LD_PRELOAD
+
+exec "$@"
diff -urN buildroot-2011.11.orig/boot/Config.in buildroot-2011.11/boot/Config.in
--- buildroot-2011.11.orig/boot/Config.in	2011-12-20 16:31:25.000000000 +0100
+++ buildroot-2011.11/boot/Config.in	2011-12-21 10:41:24.615855069 +0100
@@ -6,6 +6,7 @@
 source "boot/uboot/Config.in"
 source "boot/at91bootstrap/Config.in"
 source "boot/at91dataflashboot/Config.in"
+source "boot/sccboot/Config.in"
 source "boot/xloader/Config.in"
 
 endmenu
diff -urN buildroot-2011.11.orig/boot/sccboot/Config.in buildroot-2011.11/boot/sccboot/Config.in
--- buildroot-2011.11.orig/boot/sccboot/Config.in	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/boot/sccboot/Config.in	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,4 @@
+menuconfig BR2_TARGET_SCCBOOT
+	bool "SCC Boot"
+	help
+	  The SCC bootloader.
diff -urN buildroot-2011.11.orig/boot/sccboot/sccboot.mk buildroot-2011.11/boot/sccboot/sccboot.mk
--- buildroot-2011.11.orig/boot/sccboot/sccboot.mk	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/boot/sccboot/sccboot.mk	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,43 @@
+#############################################################
+#
+# SCC-Boot
+#
+#############################################################
+
+SCCBOOT_VERSION:=2.1.0
+SCCBOOT_SOURCE:=sccboot-$(SCCBOOT_VERSION).tar.bz2
+#SCCBOOT_SITE:=https://github.com/hpi-scc/reset-vector
+#SCCBOOT_SITE_METHOD:=git
+SCCBOOT_DIR:=$(BUILD_DIR)/sccboot-$(SCCBOOT_VERSION)
+SCCBOOT_CAT:=$(BZCAT)
+
+SCCBOOT_MAKE_FLAGS = CROSS_COMPILE=$(TARGET_CROSS)
+
+$(DL_DIR)/$(SCCBOOT_SOURCE):
+	 $(call DOWNLOAD,$(SCCBOOT_SITE),$(SCCBOOT_SOURCE))
+
+$(SCCBOOT_DIR)/.unpacked: $(DL_DIR)/$(SCCBOOT_SOURCE)
+	mkdir -p $(@D)
+	$(INFLATE$(suffix $(SCCBOOT_SOURCE))) $(DL_DIR)/$(SCCBOOT_SOURCE) \
+		| tar $(TAR_STRIP_COMPONENTS)=1 -C $(@D) $(TAR_OPTIONS) -
+	touch $@
+
+$(SCCBOOT_DIR)/.configured: $(SCCBOOT_DIR)/.unpacked
+	$(MAKE) $(SCCBOOT_MAKE_FLAGS) -C $(SCCBOOT_DIR)
+	touch $@
+
+$(SCCBOOT_DIR)/.built: $(SCCBOOT_DIR)/.configured
+	$(MAKE) $(SCCBOOT_MAKE_FLAGS) -C $(SCCBOOT_DIR)
+	touch $@
+
+$(SCCBOOT_DIR)/.installed: $(SCCBOOT_DIR)/.built
+	cp $(SCCBOOT_DIR)/ivt.bin $(BINARIES_DIR)
+	cp $(SCCBOOT_DIR)/sccboot.bin $(BINARIES_DIR)
+	cp $(SCCBOOT_DIR)/scc_bios.bin $(BINARIES_DIR)
+	touch $@
+
+sccboot: $(SCCBOOT_DIR)/.installed
+
+ifeq ($(BR2_TARGET_SCCBOOT),y)
+TARGETS+=sccboot
+endif
diff -urN buildroot-2011.11.orig/configs/scc_defconfig buildroot-2011.11/configs/scc_defconfig
--- buildroot-2011.11.orig/configs/scc_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/configs/scc_defconfig	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,689 @@
+#
+# Automatically generated make config: don't edit
+# Buildroot 2011.11 Configuration
+# Mon Dec 19 10:32:22 2011
+#
+BR2_HAVE_DOT_CONFIG=y
+# BR2_arm is not set
+# BR2_armeb is not set
+# BR2_avr32 is not set
+# BR2_bfin is not set
+BR2_i386=y
+# BR2_mips is not set
+# BR2_mipsel is not set
+# BR2_powerpc is not set
+# BR2_sh is not set
+# BR2_sh64 is not set
+# BR2_sparc is not set
+# BR2_x86_64 is not set
+# BR2_xtensa is not set
+# BR2_x86_i386 is not set
+# BR2_x86_i486 is not set
+BR2_x86_i586=y
+# BR2_x86_i686 is not set
+# BR2_x86_pentiumpro is not set
+# BR2_x86_pentium_mmx is not set
+# BR2_x86_pentium_m is not set
+# BR2_x86_pentium2 is not set
+# BR2_x86_pentium3 is not set
+# BR2_x86_pentium4 is not set
+# BR2_x86_prescott is not set
+# BR2_x86_nocona is not set
+# BR2_x86_core2 is not set
+# BR2_x86_k6 is not set
+# BR2_x86_k6_2 is not set
+# BR2_x86_athlon is not set
+# BR2_x86_athlon_4 is not set
+# BR2_x86_opteron is not set
+# BR2_x86_opteron_sse3 is not set
+# BR2_x86_barcelona is not set
+# BR2_x86_geode is not set
+# BR2_x86_c3 is not set
+# BR2_x86_c32 is not set
+# BR2_x86_winchip_c6 is not set
+# BR2_x86_winchip2 is not set
+BR2_ARCH="i586"
+BR2_ENDIAN="LITTLE"
+BR2_GCC_TARGET_TUNE="i586"
+BR2_GCC_TARGET_ARCH="i586"
+
+#
+# Build options
+#
+
+#
+# Commands
+#
+BR2_WGET="wget --passive-ftp -nd -t 3"
+BR2_SVN="svn"
+BR2_BZR="bzr"
+BR2_GIT="git"
+BR2_LOCALFILES="cp"
+BR2_ZCAT="gzip -d -c"
+BR2_BZCAT="bzcat"
+BR2_XZCAT="xzcat"
+BR2_TAR_OPTIONS=""
+BR2_DL_DIR="$(TOPDIR)/dl"
+BR2_HOST_DIR="$(BASE_DIR)/host"
+
+#
+# Mirrors and Download locations
+#
+BR2_PRIMARY_SITE=""
+BR2_BACKUP_SITE="http://sources.buildroot.net/"
+BR2_SOURCEFORGE_MIRROR="kent"
+BR2_KERNEL_MIRROR="http://www.kernel.org/pub/"
+BR2_GNU_MIRROR="http://ftp.gnu.org/pub/gnu"
+BR2_DEBIAN_MIRROR="http://ftp.debian.org"
+BR2_JLEVEL=8
+BR2_CCACHE=y
+# BR2_DEPRECATED is not set
+# BR2_ENABLE_DEBUG is not set
+BR2_STRIP_strip=y
+# BR2_STRIP_sstrip is not set
+# BR2_STRIP_none is not set
+# BR2_OPTIMIZE_0 is not set
+# BR2_OPTIMIZE_1 is not set
+BR2_OPTIMIZE_2=y
+# BR2_OPTIMIZE_3 is not set
+# BR2_OPTIMIZE_S is not set
+# BR2_PREFER_STATIC_LIB is not set
+# BR2_HAVE_DOCUMENTATION is not set
+# BR2_HAVE_DEVFILES is not set
+BR2_PACKAGE_OVERRIDE_FILE="$(TOPDIR)/local.mk"
+
+#
+# Toolchain
+#
+# BR2_TOOLCHAIN_BUILDROOT is not set
+# BR2_TOOLCHAIN_EXTERNAL is not set
+BR2_TOOLCHAIN_CTNG=y
+# BR2_TOOLCHAIN_CTNG_uClibc is not set
+# BR2_TOOLCHAIN_CTNG_eglibc is not set
+BR2_TOOLCHAIN_CTNG_glibc=y
+BR2_TOOLCHAIN_CTNG_LIBC="glibc"
+BR2_TOOLCHAIN_CTNG_CONFIG="board/intel/scc/crosstool-ng.config"
+BR2_TOOLCHAIN_CTNG_CXX=y
+# BR2_TOOLCHAIN_CTNG_THREADS_PTHREADS is not set
+BR2_TOOLCHAIN_CTNG_THREADS_NPTL=y
+
+#
+# Gdb Options
+#
+# BR2_PACKAGE_GDB is not set
+# BR2_PACKAGE_GDB_SERVER is not set
+# BR2_PACKAGE_GDB_HOST is not set
+BR2_LARGEFILE=y
+BR2_INET_IPV6=y
+BR2_INET_RPC=y
+BR2_USE_WCHAR=y
+BR2_ENABLE_LOCALE=y
+BR2_INSTALL_LIBSTDCPP=y
+BR2_TOOLCHAIN_HAS_THREADS=y
+BR2_TOOLCHAIN_HAS_THREADS_DEBUG_IF_NEEDED=y
+BR2_TOOLCHAIN_HAS_SHADOW_PASSWORDS=y
+# BR2_ENABLE_LOCALE_PURGE is not set
+BR2_USE_MMU=y
+BR2_TARGET_OPTIMIZATION="-pipe"
+BR2_TARGET_LDFLAGS=""
+
+#
+# System configuration
+#
+BR2_TARGET_GENERIC_HOSTNAME="buildroot"
+BR2_TARGET_GENERIC_ISSUE="Welcome to Buildroot"
+# BR2_ROOTFS_DEVICE_CREATION_STATIC is not set
+BR2_ROOTFS_DEVICE_CREATION_DYNAMIC_DEVTMPFS=y
+# BR2_ROOTFS_DEVICE_CREATION_DYNAMIC_MDEV is not set
+# BR2_ROOTFS_DEVICE_CREATION_DYNAMIC_UDEV is not set
+BR2_ROOTFS_DEVICE_TABLE="board/intel/scc/device_table.txt"
+# BR2_ROOTFS_SKELETON_DEFAULT is not set
+BR2_ROOTFS_SKELETON_CUSTOM=y
+BR2_ROOTFS_SKELETON_CUSTOM_PATH="board/intel/scc/target_skeleton/"
+BR2_ROOTFS_POST_BUILD_SCRIPT=""
+
+#
+# Package Selection for the target
+#
+BR2_PACKAGE_BUSYBOX=y
+BR2_BUSYBOX_VERSION_1_18_X=y
+# BR2_BUSYBOX_VERSION_1_19_X is not set
+# BR2_PACKAGE_BUSYBOX_SNAPSHOT is not set
+BR2_BUSYBOX_VERSION="1.18.5"
+BR2_PACKAGE_BUSYBOX_CONFIG="package/busybox/busybox-1.18.x.config"
+# BR2_PACKAGE_BUSYBOX_SHOW_OTHERS is not set
+# BR2_PACKAGE_CUSTOMIZE is not set
+
+#
+# Audio and video libraries and applications
+#
+# BR2_PACKAGE_ALSA_LIB is not set
+# BR2_PACKAGE_ALSA_UTILS is not set
+# BR2_PACKAGE_AUMIX is not set
+# BR2_PACKAGE_FAAD2 is not set
+# BR2_PACKAGE_FLAC is not set
+# BR2_PACKAGE_FFMPEG is not set
+# BR2_PACKAGE_GSTREAMER is not set
+# BR2_PACKAGE_LAME is not set
+# BR2_PACKAGE_LIBAO is not set
+# BR2_PACKAGE_LIBCDAUDIO is not set
+# BR2_PACKAGE_LIBCUE is not set
+# BR2_PACKAGE_LIBCUEFILE is not set
+# BR2_PACKAGE_LIBDVDREAD is not set
+# BR2_PACKAGE_LIBDVDNAV is not set
+# BR2_PACKAGE_LIBID3TAG is not set
+# BR2_PACKAGE_LIBMAD is not set
+# BR2_PACKAGE_LIBMMS is not set
+# BR2_PACKAGE_LIBMPD is not set
+# BR2_PACKAGE_LIBMPEG2 is not set
+# BR2_PACKAGE_LIBOGG is not set
+# BR2_PACKAGE_LIBPLAYER is not set
+# BR2_PACKAGE_LIBREPLAYGAIN is not set
+# BR2_PACKAGE_LIBSAMPLERATE is not set
+# BR2_PACKAGE_LIBSNDFILE is not set
+# BR2_PACKAGE_LIBTHEORA is not set
+# BR2_PACKAGE_LIBVORBIS is not set
+# BR2_PACKAGE_LIVE555 is not set
+# BR2_PACKAGE_MADPLAY is not set
+# BR2_PACKAGE_MPD is not set
+# BR2_PACKAGE_MPG123 is not set
+# BR2_PACKAGE_MPLAYER is not set
+# BR2_PACKAGE_MUSEPACK is not set
+# BR2_PACKAGE_PORTAUDIO is not set
+# BR2_PACKAGE_PULSEAUDIO is not set
+# BR2_PACKAGE_SPEEX is not set
+# BR2_PACKAGE_TAGLIB is not set
+# BR2_PACKAGE_TREMOR is not set
+# BR2_PACKAGE_VORBIS_TOOLS is not set
+# BR2_PACKAGE_WAVPACK is not set
+
+#
+# Compressors and decompressors
+#
+# BR2_PACKAGE_BZIP2 is not set
+# BR2_PACKAGE_LZOP is not set
+# BR2_PACKAGE_XZ is not set
+
+#
+# Debugging, profiling and benchmark
+#
+# BR2_PACKAGE_BONNIE is not set
+# BR2_PACKAGE_DHRYSTONE is not set
+# BR2_PACKAGE_DMALLOC is not set
+# BR2_PACKAGE_KEXEC is not set
+# BR2_PACKAGE_LMBENCH is not set
+# BR2_PACKAGE_LSOF is not set
+# BR2_PACKAGE_LTP_TESTSUITE is not set
+# BR2_PACKAGE_LTRACE is not set
+# BR2_PACKAGE_MEMSTAT is not set
+# BR2_PACKAGE_NETPERF is not set
+# BR2_PACKAGE_OPROFILE is not set
+# BR2_PACKAGE_STRACE is not set
+# BR2_PACKAGE_WHETSTONE is not set
+# BR2_PACKAGE_VALGRIND is not set
+# BR2_PACKAGE_PV is not set
+
+#
+# Development tools
+#
+# BR2_PACKAGE_AUTOCONF is not set
+# BR2_PACKAGE_AUTOMAKE is not set
+# BR2_PACKAGE_BINUTILS is not set
+# BR2_PACKAGE_BISON is not set
+# BR2_PACKAGE_BSDIFF is not set
+# BR2_PACKAGE_CCACHE is not set
+# BR2_PACKAGE_CVS is not set
+# BR2_PACKAGE_DISTCC is not set
+# BR2_PACKAGE_FLEX is not set
+# BR2_PACKAGE_GMP is not set
+# BR2_PACKAGE_GPERF is not set
+# BR2_PACKAGE_MAKE is not set
+# BR2_PACKAGE_MPC is not set
+# BR2_PACKAGE_MPFR is not set
+# BR2_PACKAGE_LIBTOOL is not set
+# BR2_PACKAGE_M4 is not set
+# BR2_PACKAGE_PKG_CONFIG is not set
+# BR2_PACKAGE_SSTRIP is not set
+
+#
+# Games
+#
+# BR2_PACKAGE_GNUCHESS is not set
+# BR2_PACKAGE_PRBOOM is not set
+
+#
+# Graphic libraries and applications (graphic/text)
+#
+
+#
+# Graphic applications
+#
+# BR2_PACKAGE_RRDTOOL is not set
+
+#
+# graphic libraries
+#
+# BR2_PACKAGE_DIRECTFB is not set
+# BR2_PACKAGE_FBDUMP is not set
+# BR2_PACKAGE_FBGRAB is not set
+# BR2_PACKAGE_FBV is not set
+# BR2_PACKAGE_IMAGEMAGICK is not set
+# BR2_PACKAGE_LINUX_FUSION is not set
+# BR2_PACKAGE_SDL is not set
+
+#
+# other GUIs
+#
+# BR2_PACKAGE_QT is not set
+# BR2_PACKAGE_XORG7 is not set
+
+#
+# X libraries and helper libraries
+#
+# BR2_PACKAGE_LIBERATION is not set
+
+#
+# X Window managers
+#
+
+#
+# X applications
+#
+# BR2_PACKAGE_GOB2 is not set
+
+#
+# midori requires C++, WCHAR in toolchain and libgtk2
+#
+# BR2_PACKAGE_VALA is not set
+
+#
+# Hardware handling
+#
+# BR2_PACKAGE_ACPID is not set
+# BR2_PACKAGE_CDRKIT is not set
+# BR2_PACKAGE_CRAMFS is not set
+
+#
+# dbus not available (need expat or libxml2)
+#
+# BR2_PACKAGE_DMRAID is not set
+# BR2_PACKAGE_DOSFSTOOLS is not set
+# BR2_PACKAGE_E2FSPROGS is not set
+# BR2_PACKAGE_EEPROG is not set
+# BR2_PACKAGE_FCONFIG is not set
+# BR2_PACKAGE_FIS is not set
+# BR2_PACKAGE_GADGETFS_TEST is not set
+# BR2_PACKAGE_GDISK is not set
+# BR2_PACKAGE_GENEXT2FS is not set
+# BR2_PACKAGE_GENROMFS is not set
+# BR2_PACKAGE_GPSD is not set
+# BR2_PACKAGE_GVFS is not set
+# BR2_PACKAGE_HWDATA is not set
+# BR2_PACKAGE_I2C_TOOLS is not set
+# BR2_PACKAGE_INPUT_EVENT_DAEMON is not set
+# BR2_PACKAGE_INPUT_TOOLS is not set
+# BR2_PACKAGE_IOSTAT is not set
+# BR2_PACKAGE_IRDA_UTILS is not set
+# BR2_PACKAGE_KBD is not set
+# BR2_PACKAGE_LIBV4L is not set
+# BR2_PACKAGE_LM_SENSORS is not set
+# BR2_PACKAGE_LSUIO is not set
+# BR2_PACKAGE_LVM2 is not set
+# BR2_PACKAGE_MAKEDEVS is not set
+# BR2_PACKAGE_MDADM is not set
+# BR2_PACKAGE_MEMTESTER is not set
+# BR2_PACKAGE_MTD is not set
+# BR2_PACKAGE_NTFS_3G is not set
+# BR2_PACKAGE_OPENOCD is not set
+# BR2_PACKAGE_PCIUTILS is not set
+# BR2_PACKAGE_PICOCOM is not set
+# BR2_PACKAGE_RNG_TOOLS is not set
+# BR2_PACKAGE_SDPARM is not set
+# BR2_PACKAGE_SETSERIAL is not set
+# BR2_PACKAGE_SMARTMONTOOLS is not set
+# BR2_PACKAGE_SQUASHFS is not set
+# BR2_PACKAGE_SREDIRD is not set
+# BR2_PACKAGE_SSHFS is not set
+# BR2_PACKAGE_STATSERIAL is not set
+# BR2_PACKAGE_SYSSTAT is not set
+# BR2_PACKAGE_TI_UTILS is not set
+# BR2_PACKAGE_UBOOT_TOOLS is not set
+
+#
+# udev requires /dev mgmnt set to udev under System configuration
+#
+# BR2_PACKAGE_USB_MODESWITCH is not set
+# BR2_PACKAGE_USBUTILS is not set
+# BR2_PACKAGE_WIPE is not set
+# BR2_PACKAGE_XFSPROGS is not set
+
+#
+# Interpreter languages and scripting
+#
+# BR2_PACKAGE_HASERL is not set
+# BR2_PACKAGE_LUA is not set
+# BR2_PACKAGE_MICROPERL is not set
+# BR2_PACKAGE_PHP is not set
+# BR2_PACKAGE_PYTHON is not set
+# BR2_PACKAGE_RUBY is not set
+# BR2_PACKAGE_TCL is not set
+
+#
+# Libraries
+#
+
+#
+# Compression and decompression
+#
+# BR2_PACKAGE_LIBARCHIVE is not set
+# BR2_PACKAGE_LZO is not set
+BR2_PACKAGE_ZLIB=y
+
+#
+# Crypto
+#
+# BR2_PACKAGE_BEECRYPT is not set
+# BR2_PACKAGE_GNUTLS is not set
+# BR2_PACKAGE_LIBGCRYPT is not set
+# BR2_PACKAGE_LIBGPG_ERROR is not set
+# BR2_PACKAGE_LIBNSS is not set
+BR2_PACKAGE_OPENSSL=y
+# BR2_PACKAGE_OPENSSL_BIN is not set
+# BR2_PACKAGE_OPENSSL_ENGINES is not set
+# BR2_PACKAGE_OPENSSL_OCF is not set
+
+#
+# Database
+#
+# BR2_PACKAGE_BERKELEYDB is not set
+# BR2_PACKAGE_MYSQL_CLIENT is not set
+# BR2_PACKAGE_SQLITE is not set
+
+#
+# Filesystem
+#
+# BR2_PACKAGE_GAMIN is not set
+# BR2_PACKAGE_LIBCONFIG is not set
+# BR2_PACKAGE_LIBCONFUSE is not set
+# BR2_PACKAGE_LIBFUSE is not set
+# BR2_PACKAGE_LIBLOCKFILE is not set
+# BR2_PACKAGE_LIBSYSFS is not set
+
+#
+# Graphics
+#
+# BR2_PACKAGE_ATK is not set
+# BR2_PACKAGE_CAIRO is not set
+# BR2_PACKAGE_FONTCONFIG is not set
+# BR2_PACKAGE_FREETYPE is not set
+# BR2_PACKAGE_JPEG is not set
+# BR2_PACKAGE_LIBART is not set
+# BR2_PACKAGE_LIBEXIF is not set
+# BR2_PACKAGE_LIBGEOTIFF is not set
+# BR2_PACKAGE_GDK_PIXBUF is not set
+# BR2_PACKAGE_LIBPNG is not set
+# BR2_PACKAGE_LIBRAW is not set
+# BR2_PACKAGE_LIBSVGTINY is not set
+# BR2_PACKAGE_LIBUNGIF is not set
+# BR2_PACKAGE_OPENCV is not set
+# BR2_PACKAGE_PANGO is not set
+# BR2_PACKAGE_PIXMAN is not set
+# BR2_PACKAGE_TIFF is not set
+
+#
+# webkit requires C++, WCHAR in toolchain and libgtk2
+#
+
+#
+# Hardware handling
+#
+# BR2_PACKAGE_LIBAIO is not set
+# BR2_PACKAGE_LIBRAW1394 is not set
+# BR2_PACKAGE_TSLIB is not set
+# BR2_PACKAGE_LIBFTDI is not set
+# BR2_PACKAGE_LIBHID is not set
+# BR2_PACKAGE_LIBIQRF is not set
+# BR2_PACKAGE_LIBUSB is not set
+
+#
+# Networking
+#
+# BR2_PACKAGE_LIBCGI is not set
+# BR2_PACKAGE_LIBCGICC is not set
+# BR2_PACKAGE_LIBCURL is not set
+# BR2_PACKAGE_LIBDNET is not set
+# BR2_PACKAGE_LIBEXOSIP2 is not set
+# BR2_PACKAGE_LIBIDN is not set
+# BR2_PACKAGE_LIBMICROHTTPD is not set
+# BR2_PACKAGE_NEON is not set
+# BR2_PACKAGE_LIBMNL is not set
+# BR2_PACKAGE_LIBMODBUS is not set
+# BR2_PACKAGE_LIBNL is not set
+# BR2_PACKAGE_LIBPCAP is not set
+# BR2_PACKAGE_LIBOSIP2 is not set
+# BR2_PACKAGE_LIBRSYNC is not set
+# BR2_PACKAGE_LIBSOUP is not set
+# BR2_PACKAGE_LIBUPNP is not set
+
+#
+# Other
+#
+# BR2_PACKAGE_FFTW is not set
+# BR2_PACKAGE_LIBARGTABLE2 is not set
+# BR2_PACKAGE_ARGP_STANDALONE is not set
+# BR2_PACKAGE_LIBATOMIC_OPS is not set
+# BR2_PACKAGE_LIBCAP is not set
+# BR2_PACKAGE_LIBDAEMON is not set
+# BR2_PACKAGE_LIBELF is not set
+# BR2_PACKAGE_LIBEVENT is not set
+# BR2_PACKAGE_LIBEV is not set
+# BR2_PACKAGE_LIBFFI is not set
+# BR2_PACKAGE_LIBGLIB2 is not set
+# BR2_PACKAGE_LIBNSPR is not set
+# BR2_PACKAGE_LIBSIGC is not set
+# BR2_PACKAGE_ORC is not set
+# BR2_PACKAGE_POCO is not set
+
+#
+# Text and terminal handling
+#
+# BR2_PACKAGE_ENCHANT is not set
+# BR2_PACKAGE_ICU is not set
+# BR2_PACKAGE_NCURSES is not set
+# BR2_PACKAGE_NEWT is not set
+# BR2_PACKAGE_PCRE is not set
+# BR2_PACKAGE_POPT is not set
+# BR2_PACKAGE_READLINE is not set
+# BR2_PACKAGE_SLANG is not set
+
+#
+# JSON/XML
+#
+# BR2_PACKAGE_EXPAT is not set
+# BR2_PACKAGE_EZXML is not set
+# BR2_PACKAGE_JSON_C is not set
+# BR2_PACKAGE_LIBROXML is not set
+# BR2_PACKAGE_LIBXML2 is not set
+# BR2_PACKAGE_LIBXSLT is not set
+# BR2_PACKAGE_LIBYAML is not set
+# BR2_PACKAGE_MXML is not set
+# BR2_PACKAGE_XERCES is not set
+# BR2_PACKAGE_YAJL is not set
+
+#
+# Miscellaneous
+#
+# BR2_PACKAGE_SHARED_MIME_INFO is not set
+
+#
+# Networking applications
+#
+# BR2_PACKAGE_ARGUS is not set
+# BR2_PACKAGE_AVAHI is not set
+# BR2_PACKAGE_AXEL is not set
+# BR2_PACKAGE_BLUEZ_UTILS is not set
+# BR2_PACKAGE_BIND is not set
+# BR2_PACKAGE_BMON is not set
+# BR2_PACKAGE_BRIDGE_UTILS is not set
+# BR2_PACKAGE_BWM_NG is not set
+# BR2_PACKAGE_CAN_UTILS is not set
+# BR2_PACKAGE_CTORRENT is not set
+# BR2_PACKAGE_CIFS_UTILS is not set
+# BR2_PACKAGE_CUPS is not set
+# BR2_PACKAGE_DHCPDUMP is not set
+# BR2_PACKAGE_DNSMASQ is not set
+# BR2_PACKAGE_DROPBEAR is not set
+# BR2_PACKAGE_EBTABLES is not set
+# BR2_PACKAGE_ETHTOOL is not set
+# BR2_PACKAGE_HOSTAPD is not set
+BR2_PACKAGE_IPERF=y
+# BR2_PACKAGE_IPROUTE2 is not set
+# BR2_PACKAGE_IPSEC_TOOLS is not set
+# BR2_PACKAGE_IPSET is not set
+# BR2_PACKAGE_IPTABLES is not set
+# BR2_PACKAGE_IW is not set
+# BR2_PACKAGE_KISMET is not set
+# BR2_PACKAGE_LINKS is not set
+# BR2_PACKAGE_LRZSZ is not set
+# BR2_PACKAGE_MII_DIAG is not set
+# BR2_PACKAGE_MROUTED is not set
+# BR2_PACKAGE_MUTT is not set
+# BR2_PACKAGE_NBD is not set
+# BR2_PACKAGE_NCFTP is not set
+# BR2_PACKAGE_NETPLUG is not set
+# BR2_PACKAGE_NETSNMP is not set
+# BR2_PACKAGE_NETSTAT_NAT is not set
+# BR2_PACKAGE_NOIP is not set
+# BR2_PACKAGE_NFS_UTILS is not set
+# BR2_PACKAGE_NGIRCD is not set
+# BR2_PACKAGE_NGREP is not set
+# BR2_PACKAGE_NTP is not set
+# BR2_PACKAGE_NUTTCP is not set
+# BR2_PACKAGE_OLSR is not set
+# BR2_PACKAGE_OPENNTPD is not set
+BR2_PACKAGE_OPENSSH=y
+# BR2_PACKAGE_OPENVPN is not set
+# BR2_PACKAGE_PORTMAP is not set
+# BR2_PACKAGE_PPPD is not set
+# BR2_PACKAGE_PPTP_LINUX is not set
+# BR2_PACKAGE_PROFTPD is not set
+# BR2_PACKAGE_QUAGGA is not set
+# BR2_PACKAGE_RADVD is not set
+# BR2_PACKAGE_RSH_REDONE is not set
+# BR2_PACKAGE_RSYNC is not set
+# BR2_PACKAGE_SAMBA is not set
+# BR2_PACKAGE_SER2NET is not set
+# BR2_PACKAGE_SOCAT is not set
+# BR2_PACKAGE_SPAWN_FCGI is not set
+# BR2_PACKAGE_SQUID is not set
+# BR2_PACKAGE_STUNNEL is not set
+# BR2_PACKAGE_TCPDUMP is not set
+# BR2_PACKAGE_TCPREPLAY is not set
+# BR2_PACKAGE_TN5250 is not set
+# BR2_PACKAGE_TTCP is not set
+# BR2_PACKAGE_UDPCAST is not set
+# BR2_PACKAGE_VPNC is not set
+# BR2_PACKAGE_VSFTPD is not set
+# BR2_PACKAGE_VTUN is not set
+# BR2_PACKAGE_WIRELESS_TOOLS is not set
+# BR2_PACKAGE_WPA_SUPPLICANT is not set
+# BR2_PACKAGE_XL2TP is not set
+
+#
+# Package managers
+#
+# BR2_PACKAGE_IPKG is not set
+
+#
+# Real-Time
+#
+# BR2_PACKAGE_XENOMAI is not set
+
+#
+# Single-chip cloud computer related applications
+#
+BR2_PACKAGE_RHID=y
+BR2_PACKAGE_GPM=y
+BR2_PACKAGE_SCCAPPS=y
+# BR2_PACKAGE_USBIP is not set
+
+#
+# Shell and utilities
+#
+# BR2_PACKAGE_AT is not set
+# BR2_PACKAGE_DIALOG is not set
+# BR2_PACKAGE_FILE is not set
+# BR2_PACKAGE_INOTIFY_TOOLS is not set
+# BR2_PACKAGE_LOCKFILE_PROGS is not set
+# BR2_PACKAGE_LOGROTATE is not set
+# BR2_PACKAGE_SCREEN is not set
+# BR2_PACKAGE_SUDO is not set
+# BR2_PACKAGE_XMLSTARLET is not set
+
+#
+# System tools
+#
+# BR2_PACKAGE_ACL is not set
+# BR2_PACKAGE_ATTR is not set
+# BR2_PACKAGE_HTOP is not set
+# BR2_PACKAGE_UTIL_LINUX is not set
+
+#
+# Text editors and viewers
+#
+# BR2_PACKAGE_ED is not set
+# BR2_PACKAGE_NANO is not set
+# BR2_PACKAGE_UEMACS is not set
+
+#
+# Filesystem images
+#
+# BR2_TARGET_ROOTFS_CRAMFS is not set
+# BR2_TARGET_ROOTFS_CLOOP is not set
+# BR2_TARGET_ROOTFS_EXT2 is not set
+# BR2_TARGET_ROOTFS_JFFS2 is not set
+# BR2_TARGET_ROOTFS_UBIFS is not set
+# BR2_TARGET_ROOTFS_SQUASHFS is not set
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_TARGET_ROOTFS_CPIO=y
+BR2_TARGET_ROOTFS_CPIO_NONE=y
+# BR2_TARGET_ROOTFS_CPIO_GZIP is not set
+# BR2_TARGET_ROOTFS_CPIO_BZIP2 is not set
+# BR2_TARGET_ROOTFS_CPIO_LZMA is not set
+# BR2_TARGET_ROOTFS_ISO9660 is not set
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_ROMFS is not set
+BR2_TARGET_ROOTFS_SCCFS=y
+BR2_TARGET_ROOTFS_SCCFS_MERGED=y
+
+#
+# Bootloaders
+#
+# BR2_TARGET_BAREBOX is not set
+# BR2_TARGET_GRUB is not set
+# BR2_TARGET_SYSLINUX is not set
+# BR2_TARGET_UBOOT is not set
+BR2_TARGET_SCCBOOT=y
+
+#
+# Kernel
+#
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_3_1=y
+# BR2_LINUX_KERNEL_CUSTOM_VERSION is not set
+# BR2_LINUX_KERNEL_CUSTOM_TARBALL is not set
+# BR2_LINUX_KERNEL_CUSTOM_GIT is not set
+BR2_LINUX_KERNEL_VERSION="3.1.4"
+BR2_LINUX_KERNEL_PATCH="board/intel/scc/kernel-patches/linux-3.1.4-100-scc.patch"
+# BR2_LINUX_KERNEL_USE_DEFCONFIG is not set
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="board/intel/scc/linux-3.1.4.config"
+BR2_LINUX_KERNEL_BZIMAGE=y
+# BR2_LINUX_KERNEL_VMLINUX is not set
+# BR2_LINUX_KERNEL_IMAGE_TARGET_CUSTOM is not set
+
+#
+# Linux Kernel Extensions
+#
+# BR2_LINUX_KERNEL_EXT_XENOMAI is not set
+# BR2_LINUX_KERNEL_EXT_RTAI is not set
diff -urN buildroot-2011.11.orig/configs/sccDemo_defconfig buildroot-2011.11/configs/sccDemo_defconfig
--- buildroot-2011.11.orig/configs/sccDemo_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/configs/sccDemo_defconfig	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,719 @@
+#
+# Automatically generated make config: don't edit
+# Buildroot 2011.11 Configuration
+# Mon Dec 19 15:20:11 2011
+#
+BR2_HAVE_DOT_CONFIG=y
+# BR2_arm is not set
+# BR2_armeb is not set
+# BR2_avr32 is not set
+# BR2_bfin is not set
+BR2_i386=y
+# BR2_mips is not set
+# BR2_mipsel is not set
+# BR2_powerpc is not set
+# BR2_sh is not set
+# BR2_sh64 is not set
+# BR2_sparc is not set
+# BR2_x86_64 is not set
+# BR2_xtensa is not set
+# BR2_x86_i386 is not set
+# BR2_x86_i486 is not set
+BR2_x86_i586=y
+# BR2_x86_i686 is not set
+# BR2_x86_pentiumpro is not set
+# BR2_x86_pentium_mmx is not set
+# BR2_x86_pentium_m is not set
+# BR2_x86_pentium2 is not set
+# BR2_x86_pentium3 is not set
+# BR2_x86_pentium4 is not set
+# BR2_x86_prescott is not set
+# BR2_x86_nocona is not set
+# BR2_x86_core2 is not set
+# BR2_x86_k6 is not set
+# BR2_x86_k6_2 is not set
+# BR2_x86_athlon is not set
+# BR2_x86_athlon_4 is not set
+# BR2_x86_opteron is not set
+# BR2_x86_opteron_sse3 is not set
+# BR2_x86_barcelona is not set
+# BR2_x86_geode is not set
+# BR2_x86_c3 is not set
+# BR2_x86_c32 is not set
+# BR2_x86_winchip_c6 is not set
+# BR2_x86_winchip2 is not set
+BR2_ARCH="i586"
+BR2_ENDIAN="LITTLE"
+BR2_GCC_TARGET_TUNE="i586"
+BR2_GCC_TARGET_ARCH="i586"
+
+#
+# Build options
+#
+
+#
+# Commands
+#
+BR2_WGET="wget --passive-ftp -nd -t 3"
+BR2_SVN="svn"
+BR2_BZR="bzr"
+BR2_GIT="git"
+BR2_LOCALFILES="cp"
+BR2_ZCAT="gzip -d -c"
+BR2_BZCAT="bzcat"
+BR2_XZCAT="xzcat"
+BR2_TAR_OPTIONS=""
+BR2_DL_DIR="$(TOPDIR)/dl"
+BR2_HOST_DIR="$(BASE_DIR)/host"
+
+#
+# Mirrors and Download locations
+#
+BR2_PRIMARY_SITE=""
+BR2_BACKUP_SITE="http://sources.buildroot.net/"
+BR2_SOURCEFORGE_MIRROR="kent"
+BR2_KERNEL_MIRROR="http://www.kernel.org/pub/"
+BR2_GNU_MIRROR="http://ftp.gnu.org/pub/gnu"
+BR2_DEBIAN_MIRROR="http://ftp.debian.org"
+BR2_JLEVEL=8
+BR2_CCACHE=y
+# BR2_DEPRECATED is not set
+# BR2_ENABLE_DEBUG is not set
+BR2_STRIP_strip=y
+# BR2_STRIP_sstrip is not set
+# BR2_STRIP_none is not set
+# BR2_OPTIMIZE_0 is not set
+# BR2_OPTIMIZE_1 is not set
+BR2_OPTIMIZE_2=y
+# BR2_OPTIMIZE_3 is not set
+# BR2_OPTIMIZE_S is not set
+# BR2_PREFER_STATIC_LIB is not set
+# BR2_HAVE_DOCUMENTATION is not set
+# BR2_HAVE_DEVFILES is not set
+BR2_PACKAGE_OVERRIDE_FILE="$(TOPDIR)/local.mk"
+
+#
+# Toolchain
+#
+# BR2_TOOLCHAIN_BUILDROOT is not set
+# BR2_TOOLCHAIN_EXTERNAL is not set
+BR2_TOOLCHAIN_CTNG=y
+# BR2_TOOLCHAIN_CTNG_uClibc is not set
+# BR2_TOOLCHAIN_CTNG_eglibc is not set
+BR2_TOOLCHAIN_CTNG_glibc=y
+BR2_TOOLCHAIN_CTNG_LIBC="glibc"
+BR2_TOOLCHAIN_CTNG_CONFIG="board/intel/scc/crosstool-ng.config"
+BR2_TOOLCHAIN_CTNG_CXX=y
+# BR2_TOOLCHAIN_CTNG_THREADS_PTHREADS is not set
+BR2_TOOLCHAIN_CTNG_THREADS_NPTL=y
+
+#
+# Gdb Options
+#
+# BR2_PACKAGE_GDB is not set
+# BR2_PACKAGE_GDB_SERVER is not set
+# BR2_PACKAGE_GDB_HOST is not set
+BR2_LARGEFILE=y
+BR2_INET_IPV6=y
+BR2_INET_RPC=y
+BR2_USE_WCHAR=y
+BR2_ENABLE_LOCALE=y
+BR2_INSTALL_LIBSTDCPP=y
+BR2_TOOLCHAIN_HAS_THREADS=y
+BR2_TOOLCHAIN_HAS_THREADS_DEBUG_IF_NEEDED=y
+BR2_TOOLCHAIN_HAS_SHADOW_PASSWORDS=y
+# BR2_ENABLE_LOCALE_PURGE is not set
+BR2_USE_MMU=y
+BR2_TARGET_OPTIMIZATION="-pipe"
+BR2_TARGET_LDFLAGS=""
+
+#
+# System configuration
+#
+BR2_TARGET_GENERIC_HOSTNAME="buildroot"
+BR2_TARGET_GENERIC_ISSUE="Welcome to Buildroot"
+# BR2_ROOTFS_DEVICE_CREATION_STATIC is not set
+BR2_ROOTFS_DEVICE_CREATION_DYNAMIC_DEVTMPFS=y
+# BR2_ROOTFS_DEVICE_CREATION_DYNAMIC_MDEV is not set
+# BR2_ROOTFS_DEVICE_CREATION_DYNAMIC_UDEV is not set
+BR2_ROOTFS_DEVICE_TABLE="board/intel/scc/device_table.txt"
+# BR2_ROOTFS_SKELETON_DEFAULT is not set
+BR2_ROOTFS_SKELETON_CUSTOM=y
+BR2_ROOTFS_SKELETON_CUSTOM_PATH="board/intel/scc/target_skeleton/"
+BR2_ROOTFS_POST_BUILD_SCRIPT=""
+
+#
+# Package Selection for the target
+#
+BR2_PACKAGE_BUSYBOX=y
+BR2_BUSYBOX_VERSION_1_18_X=y
+# BR2_BUSYBOX_VERSION_1_19_X is not set
+# BR2_PACKAGE_BUSYBOX_SNAPSHOT is not set
+BR2_BUSYBOX_VERSION="1.18.5"
+BR2_PACKAGE_BUSYBOX_CONFIG="package/busybox/busybox-1.18.x.config"
+# BR2_PACKAGE_BUSYBOX_SHOW_OTHERS is not set
+# BR2_PACKAGE_CUSTOMIZE is not set
+
+#
+# Audio and video libraries and applications
+#
+# BR2_PACKAGE_ALSA_LIB is not set
+# BR2_PACKAGE_ALSA_UTILS is not set
+# BR2_PACKAGE_AUMIX is not set
+# BR2_PACKAGE_FAAD2 is not set
+# BR2_PACKAGE_FLAC is not set
+# BR2_PACKAGE_FFMPEG is not set
+# BR2_PACKAGE_GSTREAMER is not set
+# BR2_PACKAGE_LAME is not set
+# BR2_PACKAGE_LIBAO is not set
+# BR2_PACKAGE_LIBCDAUDIO is not set
+# BR2_PACKAGE_LIBCUE is not set
+# BR2_PACKAGE_LIBCUEFILE is not set
+# BR2_PACKAGE_LIBDVDREAD is not set
+# BR2_PACKAGE_LIBDVDNAV is not set
+# BR2_PACKAGE_LIBID3TAG is not set
+# BR2_PACKAGE_LIBMAD is not set
+# BR2_PACKAGE_LIBMMS is not set
+# BR2_PACKAGE_LIBMPD is not set
+# BR2_PACKAGE_LIBMPEG2 is not set
+BR2_PACKAGE_LIBOGG=y
+# BR2_PACKAGE_LIBPLAYER is not set
+# BR2_PACKAGE_LIBREPLAYGAIN is not set
+# BR2_PACKAGE_LIBSAMPLERATE is not set
+BR2_PACKAGE_LIBSNDFILE=y
+# BR2_PACKAGE_LIBTHEORA is not set
+# BR2_PACKAGE_LIBVORBIS is not set
+# BR2_PACKAGE_LIVE555 is not set
+# BR2_PACKAGE_MADPLAY is not set
+# BR2_PACKAGE_MPD is not set
+# BR2_PACKAGE_MPG123 is not set
+BR2_PACKAGE_MPLAYER=y
+BR2_PACKAGE_MPLAYER_MPLAYER=y
+# BR2_PACKAGE_MPLAYER_MENCODER is not set
+# BR2_PACKAGE_MUSEPACK is not set
+# BR2_PACKAGE_PORTAUDIO is not set
+BR2_PACKAGE_PULSEAUDIO=y
+BR2_PACKAGE_SPEEX=y
+# BR2_PACKAGE_TAGLIB is not set
+# BR2_PACKAGE_TREMOR is not set
+# BR2_PACKAGE_VORBIS_TOOLS is not set
+# BR2_PACKAGE_WAVPACK is not set
+
+#
+# Compressors and decompressors
+#
+# BR2_PACKAGE_BZIP2 is not set
+# BR2_PACKAGE_LZOP is not set
+# BR2_PACKAGE_XZ is not set
+
+#
+# Debugging, profiling and benchmark
+#
+# BR2_PACKAGE_BONNIE is not set
+# BR2_PACKAGE_DHRYSTONE is not set
+# BR2_PACKAGE_DMALLOC is not set
+# BR2_PACKAGE_KEXEC is not set
+# BR2_PACKAGE_LMBENCH is not set
+# BR2_PACKAGE_LSOF is not set
+# BR2_PACKAGE_LTP_TESTSUITE is not set
+# BR2_PACKAGE_LTRACE is not set
+# BR2_PACKAGE_MEMSTAT is not set
+# BR2_PACKAGE_NETPERF is not set
+# BR2_PACKAGE_OPROFILE is not set
+# BR2_PACKAGE_STRACE is not set
+# BR2_PACKAGE_WHETSTONE is not set
+# BR2_PACKAGE_VALGRIND is not set
+# BR2_PACKAGE_PV is not set
+
+#
+# Development tools
+#
+# BR2_PACKAGE_AUTOCONF is not set
+# BR2_PACKAGE_AUTOMAKE is not set
+# BR2_PACKAGE_BINUTILS is not set
+# BR2_PACKAGE_BISON is not set
+# BR2_PACKAGE_BSDIFF is not set
+# BR2_PACKAGE_CCACHE is not set
+# BR2_PACKAGE_CVS is not set
+# BR2_PACKAGE_DISTCC is not set
+# BR2_PACKAGE_FLEX is not set
+# BR2_PACKAGE_GMP is not set
+# BR2_PACKAGE_GPERF is not set
+# BR2_PACKAGE_MAKE is not set
+# BR2_PACKAGE_MPC is not set
+# BR2_PACKAGE_MPFR is not set
+BR2_PACKAGE_LIBTOOL=y
+# BR2_PACKAGE_M4 is not set
+# BR2_PACKAGE_PKG_CONFIG is not set
+# BR2_PACKAGE_SSTRIP is not set
+
+#
+# Games
+#
+# BR2_PACKAGE_GNUCHESS is not set
+BR2_PACKAGE_PRBOOM=y
+BR2_PACKAGE_DOOM_WAD=y
+
+#
+# Graphic libraries and applications (graphic/text)
+#
+
+#
+# Graphic applications
+#
+# BR2_PACKAGE_RRDTOOL is not set
+
+#
+# graphic libraries
+#
+# BR2_PACKAGE_DIRECTFB is not set
+# BR2_PACKAGE_FBDUMP is not set
+# BR2_PACKAGE_FBGRAB is not set
+BR2_PACKAGE_FBV=y
+# BR2_PACKAGE_IMAGEMAGICK is not set
+# BR2_PACKAGE_LINUX_FUSION is not set
+BR2_PACKAGE_SDL=y
+BR2_PACKAGE_SDL_FBCON=y
+BR2_PACKAGE_SDL_IMAGE=y
+
+#
+# SDL_image file format support
+#
+BR2_PACKAGE_SDL_IMAGE_BMP=y
+# BR2_PACKAGE_SDL_IMAGE_GIF is not set
+BR2_PACKAGE_SDL_IMAGE_JPEG=y
+# BR2_PACKAGE_SDL_IMAGE_LBM is not set
+# BR2_PACKAGE_SDL_IMAGE_PCX is not set
+BR2_PACKAGE_SDL_IMAGE_PNG=y
+# BR2_PACKAGE_SDL_IMAGE_PNM is not set
+# BR2_PACKAGE_SDL_IMAGE_TARGA is not set
+# BR2_PACKAGE_SDL_IMAGE_TIFF is not set
+# BR2_PACKAGE_SDL_IMAGE_XCF is not set
+# BR2_PACKAGE_SDL_IMAGE_XPM is not set
+# BR2_PACKAGE_SDL_IMAGE_XV is not set
+BR2_PACKAGE_SDL_MIXER=y
+# BR2_PACKAGE_SDL_SOUND is not set
+BR2_PACKAGE_SDL_NET=y
+# BR2_PACKAGE_SDL_TTF is not set
+# BR2_PACKAGE_SDL_GFX is not set
+
+#
+# other GUIs
+#
+# BR2_PACKAGE_QT is not set
+# BR2_PACKAGE_XORG7 is not set
+
+#
+# X libraries and helper libraries
+#
+# BR2_PACKAGE_LIBERATION is not set
+
+#
+# X Window managers
+#
+
+#
+# X applications
+#
+# BR2_PACKAGE_GOB2 is not set
+
+#
+# midori requires C++, WCHAR in toolchain and libgtk2
+#
+# BR2_PACKAGE_VALA is not set
+
+#
+# Hardware handling
+#
+# BR2_PACKAGE_ACPID is not set
+# BR2_PACKAGE_CDRKIT is not set
+# BR2_PACKAGE_CRAMFS is not set
+
+#
+# dbus not available (need expat or libxml2)
+#
+# BR2_PACKAGE_DMRAID is not set
+# BR2_PACKAGE_DOSFSTOOLS is not set
+# BR2_PACKAGE_E2FSPROGS is not set
+# BR2_PACKAGE_EEPROG is not set
+# BR2_PACKAGE_FCONFIG is not set
+# BR2_PACKAGE_FIS is not set
+# BR2_PACKAGE_GADGETFS_TEST is not set
+# BR2_PACKAGE_GDISK is not set
+# BR2_PACKAGE_GENEXT2FS is not set
+# BR2_PACKAGE_GENROMFS is not set
+# BR2_PACKAGE_GPSD is not set
+# BR2_PACKAGE_GVFS is not set
+# BR2_PACKAGE_HWDATA is not set
+# BR2_PACKAGE_I2C_TOOLS is not set
+# BR2_PACKAGE_INPUT_EVENT_DAEMON is not set
+# BR2_PACKAGE_INPUT_TOOLS is not set
+# BR2_PACKAGE_IOSTAT is not set
+# BR2_PACKAGE_IRDA_UTILS is not set
+# BR2_PACKAGE_KBD is not set
+# BR2_PACKAGE_LIBV4L is not set
+# BR2_PACKAGE_LM_SENSORS is not set
+# BR2_PACKAGE_LSUIO is not set
+# BR2_PACKAGE_LVM2 is not set
+# BR2_PACKAGE_MAKEDEVS is not set
+# BR2_PACKAGE_MDADM is not set
+# BR2_PACKAGE_MEMTESTER is not set
+# BR2_PACKAGE_MTD is not set
+# BR2_PACKAGE_NTFS_3G is not set
+# BR2_PACKAGE_OPENOCD is not set
+# BR2_PACKAGE_PCIUTILS is not set
+# BR2_PACKAGE_PICOCOM is not set
+# BR2_PACKAGE_RNG_TOOLS is not set
+# BR2_PACKAGE_SDPARM is not set
+# BR2_PACKAGE_SETSERIAL is not set
+# BR2_PACKAGE_SMARTMONTOOLS is not set
+# BR2_PACKAGE_SQUASHFS is not set
+# BR2_PACKAGE_SREDIRD is not set
+# BR2_PACKAGE_SSHFS is not set
+# BR2_PACKAGE_STATSERIAL is not set
+# BR2_PACKAGE_SYSSTAT is not set
+# BR2_PACKAGE_TI_UTILS is not set
+# BR2_PACKAGE_UBOOT_TOOLS is not set
+
+#
+# udev requires /dev mgmnt set to udev under System configuration
+#
+# BR2_PACKAGE_USB_MODESWITCH is not set
+# BR2_PACKAGE_USBUTILS is not set
+# BR2_PACKAGE_WIPE is not set
+# BR2_PACKAGE_XFSPROGS is not set
+
+#
+# Interpreter languages and scripting
+#
+# BR2_PACKAGE_HASERL is not set
+# BR2_PACKAGE_LUA is not set
+# BR2_PACKAGE_MICROPERL is not set
+# BR2_PACKAGE_PHP is not set
+# BR2_PACKAGE_PYTHON is not set
+# BR2_PACKAGE_RUBY is not set
+# BR2_PACKAGE_TCL is not set
+
+#
+# Libraries
+#
+
+#
+# Compression and decompression
+#
+# BR2_PACKAGE_LIBARCHIVE is not set
+# BR2_PACKAGE_LZO is not set
+BR2_PACKAGE_ZLIB=y
+
+#
+# Crypto
+#
+# BR2_PACKAGE_BEECRYPT is not set
+# BR2_PACKAGE_GNUTLS is not set
+# BR2_PACKAGE_LIBGCRYPT is not set
+# BR2_PACKAGE_LIBGPG_ERROR is not set
+# BR2_PACKAGE_LIBNSS is not set
+BR2_PACKAGE_OPENSSL=y
+# BR2_PACKAGE_OPENSSL_BIN is not set
+# BR2_PACKAGE_OPENSSL_ENGINES is not set
+# BR2_PACKAGE_OPENSSL_OCF is not set
+
+#
+# Database
+#
+# BR2_PACKAGE_BERKELEYDB is not set
+# BR2_PACKAGE_MYSQL_CLIENT is not set
+# BR2_PACKAGE_SQLITE is not set
+
+#
+# Filesystem
+#
+# BR2_PACKAGE_GAMIN is not set
+# BR2_PACKAGE_LIBCONFIG is not set
+# BR2_PACKAGE_LIBCONFUSE is not set
+# BR2_PACKAGE_LIBFUSE is not set
+# BR2_PACKAGE_LIBLOCKFILE is not set
+# BR2_PACKAGE_LIBSYSFS is not set
+
+#
+# Graphics
+#
+# BR2_PACKAGE_ATK is not set
+# BR2_PACKAGE_CAIRO is not set
+# BR2_PACKAGE_FONTCONFIG is not set
+# BR2_PACKAGE_FREETYPE is not set
+BR2_PACKAGE_JPEG=y
+# BR2_PACKAGE_LIBART is not set
+# BR2_PACKAGE_LIBEXIF is not set
+# BR2_PACKAGE_LIBGEOTIFF is not set
+# BR2_PACKAGE_GDK_PIXBUF is not set
+BR2_PACKAGE_LIBPNG=y
+# BR2_PACKAGE_LIBRAW is not set
+# BR2_PACKAGE_LIBSVGTINY is not set
+BR2_PACKAGE_LIBUNGIF=y
+# BR2_PACKAGE_OPENCV is not set
+# BR2_PACKAGE_PANGO is not set
+# BR2_PACKAGE_PIXMAN is not set
+# BR2_PACKAGE_TIFF is not set
+
+#
+# webkit requires C++, WCHAR in toolchain and libgtk2
+#
+
+#
+# Hardware handling
+#
+# BR2_PACKAGE_LIBAIO is not set
+# BR2_PACKAGE_LIBRAW1394 is not set
+# BR2_PACKAGE_TSLIB is not set
+# BR2_PACKAGE_LIBFTDI is not set
+# BR2_PACKAGE_LIBHID is not set
+# BR2_PACKAGE_LIBIQRF is not set
+# BR2_PACKAGE_LIBUSB is not set
+
+#
+# Networking
+#
+# BR2_PACKAGE_LIBCGI is not set
+# BR2_PACKAGE_LIBCGICC is not set
+# BR2_PACKAGE_LIBCURL is not set
+# BR2_PACKAGE_LIBDNET is not set
+# BR2_PACKAGE_LIBEXOSIP2 is not set
+# BR2_PACKAGE_LIBIDN is not set
+# BR2_PACKAGE_LIBMICROHTTPD is not set
+# BR2_PACKAGE_NEON is not set
+# BR2_PACKAGE_LIBMNL is not set
+# BR2_PACKAGE_LIBMODBUS is not set
+# BR2_PACKAGE_LIBNL is not set
+# BR2_PACKAGE_LIBPCAP is not set
+# BR2_PACKAGE_LIBOSIP2 is not set
+# BR2_PACKAGE_LIBRSYNC is not set
+# BR2_PACKAGE_LIBSOUP is not set
+# BR2_PACKAGE_LIBUPNP is not set
+
+#
+# Other
+#
+# BR2_PACKAGE_FFTW is not set
+# BR2_PACKAGE_LIBARGTABLE2 is not set
+# BR2_PACKAGE_ARGP_STANDALONE is not set
+# BR2_PACKAGE_LIBATOMIC_OPS is not set
+# BR2_PACKAGE_LIBCAP is not set
+# BR2_PACKAGE_LIBDAEMON is not set
+# BR2_PACKAGE_LIBELF is not set
+# BR2_PACKAGE_LIBEVENT is not set
+# BR2_PACKAGE_LIBEV is not set
+# BR2_PACKAGE_LIBFFI is not set
+# BR2_PACKAGE_LIBGLIB2 is not set
+# BR2_PACKAGE_LIBNSPR is not set
+# BR2_PACKAGE_LIBSIGC is not set
+# BR2_PACKAGE_ORC is not set
+# BR2_PACKAGE_POCO is not set
+
+#
+# Text and terminal handling
+#
+# BR2_PACKAGE_ENCHANT is not set
+# BR2_PACKAGE_ICU is not set
+BR2_PACKAGE_NCURSES=y
+# BR2_PACKAGE_NCURSES_TARGET_PANEL is not set
+# BR2_PACKAGE_NCURSES_TARGET_FORM is not set
+# BR2_PACKAGE_NCURSES_TARGET_MENU is not set
+# BR2_PACKAGE_NEWT is not set
+# BR2_PACKAGE_PCRE is not set
+# BR2_PACKAGE_POPT is not set
+# BR2_PACKAGE_READLINE is not set
+# BR2_PACKAGE_SLANG is not set
+
+#
+# JSON/XML
+#
+# BR2_PACKAGE_EXPAT is not set
+# BR2_PACKAGE_EZXML is not set
+BR2_PACKAGE_JSON_C=y
+# BR2_PACKAGE_LIBROXML is not set
+# BR2_PACKAGE_LIBXML2 is not set
+# BR2_PACKAGE_LIBXSLT is not set
+# BR2_PACKAGE_LIBYAML is not set
+# BR2_PACKAGE_MXML is not set
+# BR2_PACKAGE_XERCES is not set
+# BR2_PACKAGE_YAJL is not set
+
+#
+# Miscellaneous
+#
+# BR2_PACKAGE_SHARED_MIME_INFO is not set
+
+#
+# Networking applications
+#
+# BR2_PACKAGE_ARGUS is not set
+# BR2_PACKAGE_AVAHI is not set
+# BR2_PACKAGE_AXEL is not set
+# BR2_PACKAGE_BLUEZ_UTILS is not set
+# BR2_PACKAGE_BIND is not set
+# BR2_PACKAGE_BMON is not set
+# BR2_PACKAGE_BRIDGE_UTILS is not set
+# BR2_PACKAGE_BWM_NG is not set
+# BR2_PACKAGE_CAN_UTILS is not set
+# BR2_PACKAGE_CTORRENT is not set
+# BR2_PACKAGE_CIFS_UTILS is not set
+# BR2_PACKAGE_CUPS is not set
+# BR2_PACKAGE_DHCPDUMP is not set
+# BR2_PACKAGE_DNSMASQ is not set
+# BR2_PACKAGE_DROPBEAR is not set
+# BR2_PACKAGE_EBTABLES is not set
+# BR2_PACKAGE_ETHTOOL is not set
+# BR2_PACKAGE_HOSTAPD is not set
+BR2_PACKAGE_IPERF=y
+# BR2_PACKAGE_IPROUTE2 is not set
+# BR2_PACKAGE_IPSEC_TOOLS is not set
+# BR2_PACKAGE_IPSET is not set
+# BR2_PACKAGE_IPTABLES is not set
+# BR2_PACKAGE_IW is not set
+# BR2_PACKAGE_KISMET is not set
+BR2_PACKAGE_LINKS=y
+BR2_PACKAGE_LINKS_GRAPHICS=y
+# BR2_PACKAGE_LRZSZ is not set
+# BR2_PACKAGE_MII_DIAG is not set
+# BR2_PACKAGE_MROUTED is not set
+# BR2_PACKAGE_MUTT is not set
+# BR2_PACKAGE_NBD is not set
+# BR2_PACKAGE_NCFTP is not set
+# BR2_PACKAGE_NETPLUG is not set
+# BR2_PACKAGE_NETSNMP is not set
+# BR2_PACKAGE_NETSTAT_NAT is not set
+# BR2_PACKAGE_NOIP is not set
+# BR2_PACKAGE_NFS_UTILS is not set
+# BR2_PACKAGE_NGIRCD is not set
+# BR2_PACKAGE_NGREP is not set
+# BR2_PACKAGE_NTP is not set
+# BR2_PACKAGE_NUTTCP is not set
+# BR2_PACKAGE_OLSR is not set
+# BR2_PACKAGE_OPENNTPD is not set
+BR2_PACKAGE_OPENSSH=y
+# BR2_PACKAGE_OPENVPN is not set
+# BR2_PACKAGE_PORTMAP is not set
+# BR2_PACKAGE_PPPD is not set
+# BR2_PACKAGE_PPTP_LINUX is not set
+# BR2_PACKAGE_PROFTPD is not set
+# BR2_PACKAGE_QUAGGA is not set
+# BR2_PACKAGE_RADVD is not set
+# BR2_PACKAGE_RSH_REDONE is not set
+# BR2_PACKAGE_RSYNC is not set
+# BR2_PACKAGE_SAMBA is not set
+# BR2_PACKAGE_SER2NET is not set
+# BR2_PACKAGE_SOCAT is not set
+# BR2_PACKAGE_SPAWN_FCGI is not set
+# BR2_PACKAGE_SQUID is not set
+# BR2_PACKAGE_STUNNEL is not set
+# BR2_PACKAGE_TCPDUMP is not set
+# BR2_PACKAGE_TCPREPLAY is not set
+# BR2_PACKAGE_TN5250 is not set
+# BR2_PACKAGE_TTCP is not set
+# BR2_PACKAGE_UDPCAST is not set
+# BR2_PACKAGE_VPNC is not set
+# BR2_PACKAGE_VSFTPD is not set
+# BR2_PACKAGE_VTUN is not set
+# BR2_PACKAGE_WIRELESS_TOOLS is not set
+# BR2_PACKAGE_WPA_SUPPLICANT is not set
+# BR2_PACKAGE_XL2TP is not set
+
+#
+# Package managers
+#
+# BR2_PACKAGE_IPKG is not set
+
+#
+# Real-Time
+#
+# BR2_PACKAGE_XENOMAI is not set
+
+#
+# Single-chip cloud computer related applications
+#
+BR2_PACKAGE_RHID=y
+BR2_PACKAGE_GPM=y
+BR2_PACKAGE_SCCAPPS=y
+# BR2_PACKAGE_USBIP is not set
+
+#
+# Shell and utilities
+#
+# BR2_PACKAGE_AT is not set
+# BR2_PACKAGE_DIALOG is not set
+# BR2_PACKAGE_FILE is not set
+# BR2_PACKAGE_INOTIFY_TOOLS is not set
+# BR2_PACKAGE_LOCKFILE_PROGS is not set
+# BR2_PACKAGE_LOGROTATE is not set
+# BR2_PACKAGE_SCREEN is not set
+# BR2_PACKAGE_SUDO is not set
+# BR2_PACKAGE_XMLSTARLET is not set
+
+#
+# System tools
+#
+# BR2_PACKAGE_ACL is not set
+# BR2_PACKAGE_ATTR is not set
+# BR2_PACKAGE_HTOP is not set
+# BR2_PACKAGE_UTIL_LINUX is not set
+
+#
+# Text editors and viewers
+#
+# BR2_PACKAGE_ED is not set
+BR2_PACKAGE_NANO=y
+# BR2_PACKAGE_UEMACS is not set
+
+#
+# Filesystem images
+#
+# BR2_TARGET_ROOTFS_CRAMFS is not set
+# BR2_TARGET_ROOTFS_CLOOP is not set
+# BR2_TARGET_ROOTFS_EXT2 is not set
+# BR2_TARGET_ROOTFS_JFFS2 is not set
+# BR2_TARGET_ROOTFS_UBIFS is not set
+# BR2_TARGET_ROOTFS_SQUASHFS is not set
+# BR2_TARGET_ROOTFS_TAR is not set
+BR2_TARGET_ROOTFS_CPIO=y
+BR2_TARGET_ROOTFS_CPIO_NONE=y
+# BR2_TARGET_ROOTFS_CPIO_GZIP is not set
+# BR2_TARGET_ROOTFS_CPIO_BZIP2 is not set
+# BR2_TARGET_ROOTFS_CPIO_LZMA is not set
+# BR2_TARGET_ROOTFS_ISO9660 is not set
+BR2_TARGET_ROOTFS_INITRAMFS=y
+# BR2_TARGET_ROOTFS_ROMFS is not set
+BR2_TARGET_ROOTFS_SCCFS=y
+BR2_TARGET_ROOTFS_SCCFS_MERGED=y
+
+#
+# Bootloaders
+#
+# BR2_TARGET_BAREBOX is not set
+# BR2_TARGET_GRUB is not set
+# BR2_TARGET_SYSLINUX is not set
+# BR2_TARGET_UBOOT is not set
+BR2_TARGET_SCCBOOT=y
+
+#
+# Kernel
+#
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_3_1=y
+# BR2_LINUX_KERNEL_CUSTOM_VERSION is not set
+# BR2_LINUX_KERNEL_CUSTOM_TARBALL is not set
+# BR2_LINUX_KERNEL_CUSTOM_GIT is not set
+BR2_LINUX_KERNEL_VERSION="3.1.4"
+BR2_LINUX_KERNEL_PATCH="board/intel/scc/kernel-patches/linux-3.1.4-100-scc.patch"
+# BR2_LINUX_KERNEL_USE_DEFCONFIG is not set
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="board/intel/scc/linux-3.1.4.config"
+BR2_LINUX_KERNEL_BZIMAGE=y
+# BR2_LINUX_KERNEL_VMLINUX is not set
+# BR2_LINUX_KERNEL_IMAGE_TARGET_CUSTOM is not set
+
+#
+# Linux Kernel Extensions
+#
+# BR2_LINUX_KERNEL_EXT_XENOMAI is not set
+# BR2_LINUX_KERNEL_EXT_RTAI is not set
diff -urN buildroot-2011.11.orig/fs/Config.in buildroot-2011.11/fs/Config.in
--- buildroot-2011.11.orig/fs/Config.in	2011-12-20 16:31:25.000000000 +0100
+++ buildroot-2011.11/fs/Config.in	2011-12-21 10:41:24.615855069 +0100
@@ -11,5 +11,6 @@
 source "fs/iso9660/Config.in"
 source "fs/initramfs/Config.in"
 source "fs/romfs/Config.in"
+source "fs/sccfs/Config.in"
 
 endmenu
diff -urN buildroot-2011.11.orig/fs/sccfs/Config.in buildroot-2011.11/fs/sccfs/Config.in
--- buildroot-2011.11.orig/fs/sccfs/Config.in	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/fs/sccfs/Config.in	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,18 @@
+config BR2_TARGET_ROOTFS_SCCFS
+	bool "scc image"
+	depends on (BR2_i386 || BR2_x86_64)
+	depends on BR2_LINUX_KERNEL
+	select BR2_TARGET_ROOTFS_INITRAMFS
+	select BR2_TARGET_SCCBOOT
+	help
+	  Build a bootable scc image (./linux.obj)
+
+comment "scc image requires a Linux kernel to be built"
+	depends on (BR2_i386 || BR2_x86_64) && !BR2_LINUX_KERNEL
+
+config BR2_TARGET_ROOTFS_SCCFS_MERGED
+	bool "scc premerged image"
+	depends on BR2_TARGET_ROOTFS_SCCFS
+	help
+	  Build a premerged bootable scc image (./selfboot/resource folder)
+          Attention: Requires sourced sccKit (equal or higher V. 1.4.1)...
diff -urN buildroot-2011.11.orig/fs/sccfs/sccfs.mk buildroot-2011.11/fs/sccfs/sccfs.mk
--- buildroot-2011.11.orig/fs/sccfs/sccfs.mk	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/fs/sccfs/sccfs.mk	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,32 @@
+SCCFS_TARGET_DIR=$(BUILD_DIR)/sccfs
+SCCFS_OPTS:=
+MAPFILE=images/load.map
+
+$(BINARIES_DIR)/rootfs.scc: host-fakeroot linux
+	@$(call MESSAGE,"Generating root filesystem image rootfs.scc")
+	@echo "0x00000000 output/images/ivt.bin" > ${MAPFILE}
+	@echo "0x00007C00 output/build/linux-${BR2_LINUX_KERNEL_VERSION}/arch/x86/boot/setup.bin" >> ${MAPFILE}
+	@echo "0x000F0000 output/images/scc_bios.bin" >> ${MAPFILE}
+	@echo "0x00099000 images/commandline.bin" >> ${MAPFILE}
+	@echo "0x00100000 output/build/linux-${BR2_LINUX_KERNEL_VERSION}/arch/x86/boot/vmlinux.bin" >> ${MAPFILE}
+	@echo "0xFFFFF000 output/images/sccboot.bin" >> ${MAPFILE}
+	@make -C bin2obj
+	@bin2obj/bin2obj -m ${MAPFILE} -o linux.obj
+
+rootfs-scc: $(BINARIES_DIR)/rootfs.scc
+
+rootfsmrg-scc: rootfs-scc
+	@cd selfboot; chmod a+rx preMergeImage.csh; ./preMergeImage.csh ../linux.obj
+
+#############################################################
+#
+# Toplevel Makefile options
+#
+#############################################################
+ifeq ($(BR2_TARGET_ROOTFS_SCCFS),y)
+  TARGETS+=rootfs-scc
+  ifeq ($(BR2_TARGET_ROOTFS_SCCFS_MERGED),y)
+    TARGETS+=rootfsmrg-scc
+  endif
+endif
+
diff -urN buildroot-2011.11.orig/images/commandline.bin buildroot-2011.11/images/commandline.bin
--- buildroot-2011.11.orig/images/commandline.bin	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/images/commandline.bin	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1 @@
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
\ No newline at end of file
diff -urN buildroot-2011.11.orig/package/Config.in buildroot-2011.11/package/Config.in
--- buildroot-2011.11.orig/package/Config.in	2011-12-20 16:31:25.000000000 +0100
+++ buildroot-2011.11/package/Config.in	2011-12-21 10:41:24.615855069 +0100
@@ -501,6 +501,9 @@
 source "package/rtai/Config.in"
 endmenu
 
+# SCC related applications
+source "package/scc/Config.in"
+
 menu "Shell and utilities"
 source "package/at/Config.in"
 if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
diff -urN buildroot-2011.11.orig/package/Config.in.orig buildroot-2011.11/package/Config.in.orig
--- buildroot-2011.11.orig/package/Config.in.orig	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/package/Config.in.orig	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,554 @@
+menu "Package Selection for the target"
+
+source "package/busybox/Config.in"
+source "package/customize/Config.in"
+
+# Audio and video applications
+source "package/multimedia/Config.in"
+
+menu "Compressors and decompressors"
+source "package/bzip2/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/gzip/Config.in"
+endif
+source "package/lzop/Config.in"
+source "package/lzma/Config.in"
+source "package/xz/Config.in"
+endmenu
+
+menu "Debugging, profiling and benchmark"
+source "package/bonnie/Config.in"
+source "package/dhrystone/Config.in"
+source "package/dmalloc/Config.in"
+source "package/kexec/Config.in"
+source "package/lmbench/Config.in"
+source "package/lsof/Config.in"
+source "package/ltp-testsuite/Config.in"
+source "package/ltrace/Config.in"
+source "package/memstat/Config.in"
+source "package/netperf/Config.in"
+source "package/oprofile/Config.in"
+source "package/strace/Config.in"
+source "package/whetstone/Config.in"
+source "package/valgrind/Config.in"
+source "package/pv/Config.in"
+endmenu
+
+menu "Development tools"
+source "package/autoconf/Config.in"
+source "package/automake/Config.in"
+source "package/binutils/Config.in"
+source "package/bison/Config.in"
+source "package/bsdiff/Config.in"
+source "package/ccache/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/coreutils/Config.in"
+endif
+source "package/cvs/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/diffutils/Config.in"
+endif
+source "package/distcc/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/findutils/Config.in"
+endif
+source "package/flex/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/gawk/Config.in"
+endif
+source "toolchain/gcc/Config.in.2"
+source "package/gettext/Config.in"
+source "package/gmp/Config.in"
+source "package/gperf/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/grep/Config.in"
+endif
+source "package/intltool/Config.in"
+source "package/make/Config.in"
+source "package/mpc/Config.in"
+source "package/mpfr/Config.in"
+source "package/libtool/Config.in"
+source "package/m4/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/patch/Config.in"
+endif
+source "package/pkg-config/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/sed/Config.in"
+endif
+source "package/sstrip/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/tar/Config.in"
+endif
+endmenu
+
+menu "Games"
+source "package/games/gnuchess/Config.in"
+source "package/games/prboom/Config.in"
+source "package/games/doom-wad/Config.in"
+source "package/games/rubix/Config.in"
+endmenu
+
+menu "Graphic libraries and applications (graphic/text)"
+
+comment "Graphic applications"
+source "package/rrdtool/Config.in"
+
+comment "graphic libraries"
+source "package/directfb/Config.in"
+source "package/directfb-examples/Config.in"
+source "package/divine/Config.in"
+source "package/fbdump/Config.in"
+source "package/fbgrab/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/fbset/Config.in"
+endif
+source "package/fbv/Config.in"
+source "package/imagemagick/Config.in"
+source "package/linux-fusion/Config.in"
+source "package/lite/Config.in"
+source "package/sawman/Config.in"
+source "package/sdl/Config.in"
+source "package/sdl_image/Config.in"
+source "package/sdl_mixer/Config.in"
+source "package/sdl_sound/Config.in"
+source "package/sdl_net/Config.in"
+source "package/sdl_ttf/Config.in"
+source "package/sdl_gfx/Config.in"
+
+comment "other GUIs"
+source "package/qt/Config.in"
+source "package/x11r7/Config.in"
+
+comment "X libraries and helper libraries"
+source "package/liberation/Config.in"
+source "package/libsexy/Config.in"
+
+comment "X Window managers"
+source "package/matchbox/Config.in"
+source "package/metacity/Config.in"
+source "package/blackbox/Config.in"
+source "package/fluxbox/Config.in"
+
+comment "X applications"
+source "package/alsamixergui/Config.in"
+source "package/docker/Config.in"
+source "package/gqview/Config.in"
+source "package/gmpc/Config.in"
+source "package/gob2/Config.in"
+source "package/gtkperf/Config.in"
+source "package/leafpad/Config.in"
+source "package/midori/Config.in"
+source "package/pcmanfm/Config.in"
+source "package/rdesktop/Config.in"
+source "package/sylpheed/Config.in"
+source "package/synergy/Config.in"
+source "package/torsmo/Config.in"
+source "package/vala/Config.in"
+source "package/x11vnc/Config.in"
+source "package/xstroke/Config.in"
+source "package/xterm/Config.in"
+source "package/xvkbd/Config.in"
+endmenu
+
+menu "Hardware handling"
+source "package/acpid/Config.in"
+source "package/cdrkit/Config.in"
+source "package/cramfs/Config.in"
+source "package/dbus/Config.in"
+source "package/dbus-glib/Config.in"
+source "package/dbus-python/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/devmem2/Config.in"
+endif
+source "package/dmraid/Config.in"
+source "package/dosfstools/Config.in"
+source "package/e2fsprogs/Config.in"
+source "package/eeprog/Config.in"
+source "package/fconfig/Config.in"
+source "package/fis/Config.in"
+source "package/gadgetfs-test/Config.in"
+source "package/gdisk/Config.in"
+source "package/genext2fs/Config.in"
+source "package/genromfs/Config.in"
+source "package/gpsd/Config.in"
+source "package/gvfs/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/hdparm/Config.in"
+endif
+source "package/hwdata/Config.in"
+source "package/i2c-tools/Config.in"
+source "package/input-event-daemon/Config.in"
+source "package/input-tools/Config.in"
+source "package/iostat/Config.in"
+source "package/irda-utils/Config.in"
+source "package/kbd/Config.in"
+source "package/libv4l/Config.in"
+source "package/lm-sensors/Config.in"
+source "package/lsuio/Config.in"
+source "package/lvm2/Config.in"
+source "package/makedevs/Config.in"
+source "package/mdadm/Config.in"
+source "package/memtester/Config.in"
+source "package/mtd/Config.in"
+source "package/ntfs-3g/Config.in"
+source "package/ntfsprogs/Config.in"
+source "package/openocd/Config.in"
+source "package/pciutils/Config.in"
+source "package/picocom/Config.in"
+source "package/rng-tools/Config.in"
+source "package/sdparm/Config.in"
+source "package/setserial/Config.in"
+source "package/smartmontools/Config.in"
+source "package/squashfs/Config.in"
+source "package/squashfs3/Config.in"
+source "package/sredird/Config.in"
+source "package/sshfs/Config.in"
+source "package/statserial/Config.in"
+source "package/sysstat/Config.in"
+source "package/ti-utils/Config.in"
+source "package/uboot-tools/Config.in"
+source "package/udev/Config.in"
+source "package/usb_modeswitch/Config.in"
+source "package/usbmount/Config.in"
+source "package/usbutils/Config.in"
+source "package/wipe/Config.in"
+source "package/xfsprogs/Config.in"
+endmenu
+
+menu "Interpreter languages and scripting"
+source "package/haserl/Config.in"
+source "package/java/jamvm/Config.in"
+source "package/lua/Config.in"
+if BR2_PACKAGE_LUA
+menu "LUA libraries/modules"
+source "package/cgilua/Config.in"
+source "package/copas/Config.in"
+source "package/coxpcall/Config.in"
+source "package/luafilesystem/Config.in"
+source "package/luasocket/Config.in"
+source "package/rings/Config.in"
+source "package/wsapi/Config.in"
+source "package/xavante/Config.in"
+endmenu
+endif
+source "package/microperl/Config.in"
+source "package/php/Config.in"
+source "package/python/Config.in"
+source "package/ruby/Config.in"
+source "package/tcl/Config.in"
+endmenu
+
+menu "Libraries"
+
+menu "Compression and decompression"
+source "package/libarchive/Config.in"
+source "package/lzo/Config.in"
+source "package/zlib/Config.in"
+endmenu
+
+menu "Crypto"
+source "package/beecrypt/Config.in"
+source "package/gnutls/Config.in"
+source "package/libgcrypt/Config.in"
+source "package/libgpg-error/Config.in"
+source "package/libnss/Config.in"
+source "package/openssl/Config.in"
+endmenu
+
+menu "Database"
+source "package/berkeleydb/Config.in"
+source "package/mysql_client/Config.in"
+source "package/sqlite/Config.in"
+endmenu
+
+menu "Filesystem"
+source "package/gamin/Config.in"
+source "package/libconfig/Config.in"
+source "package/libconfuse/Config.in"
+source "package/libfuse/Config.in"
+source "package/liblockfile/Config.in"
+source "package/libsysfs/Config.in"
+endmenu
+
+menu "Graphics"
+source "package/atk/Config.in"
+source "package/cairo/Config.in"
+source "package/fltk/Config.in"
+source "package/fontconfig/Config.in"
+source "package/freetype/Config.in"
+source "package/gtk2-engines/Config.in"
+source "package/gtk2-themes/Config.in"
+source "package/jpeg/Config.in"
+source "package/libart/Config.in"
+source "package/libdrm/Config.in"
+source "package/libexif/Config.in"
+source "package/libgail/Config.in"
+source "package/libgeotiff/Config.in"
+source "package/libglade/Config.in"
+source "package/gdk-pixbuf/Config.in"
+source "package/libgtk2/Config.in"
+source "package/libpng/Config.in"
+source "package/libraw/Config.in"
+source "package/librsvg/Config.in"
+source "package/libsvgtiny/Config.in"
+source "package/libungif/Config.in"
+source "package/opencv/Config.in"
+source "package/pango/Config.in"
+source "package/pixman/Config.in"
+source "package/tiff/Config.in"
+source "package/webkit/Config.in"
+endmenu
+
+menu "Hardware handling"
+source "package/libaio/Config.in"
+source "package/libraw1394/Config.in"
+source "package/tslib/Config.in"
+source "package/libftdi/Config.in"
+source "package/libhid/Config.in"
+source "package/libiqrf/Config.in"
+source "package/libusb/Config.in"
+source "package/libusb-compat/Config.in"
+source "package/python-serial/Config.in"
+endmenu
+
+if BROKEN
+menu "Java"
+source "package/java/classpath/Config.in"
+source "package/java/concierge/Config.in"
+endmenu
+endif
+
+menu "Networking"
+source "package/libcgi/Config.in"
+source "package/libcgicc/Config.in"
+source "package/libcurl/Config.in"
+source "package/libdnet/Config.in"
+source "package/libeXosip2/Config.in"
+source "package/libidn/Config.in"
+source "package/libmicrohttpd/Config.in"
+source "package/neon/Config.in"
+source "package/libmnl/Config.in"
+source "package/libmodbus/Config.in"
+source "package/libnl/Config.in"
+source "package/libpcap/Config.in"
+source "package/libosip2/Config.in"
+source "package/librsync/Config.in"
+source "package/libsoup/Config.in"
+source "package/libupnp/Config.in"
+endmenu
+
+menu "Other"
+source "package/fftw/Config.in"
+source "package/libargtable2/Config.in"
+source "package/argp-standalone/Config.in"
+source "package/libatomic_ops/Config.in"
+source "package/libcap/Config.in"
+source "package/libdaemon/Config.in"
+source "package/libelf/Config.in"
+source "package/libevent/Config.in"
+source "package/libev/Config.in"
+source "package/libffi/Config.in"
+source "package/libglib2/Config.in"
+source "package/libnspr/Config.in"
+source "package/libsigc/Config.in"
+source "package/orc/Config.in"
+source "package/poco/Config.in"
+source "package/startup-notification/Config.in"
+endmenu
+
+menu "Text and terminal handling"
+source "package/enchant/Config.in"
+source "package/icu/Config.in"
+source "package/libiconv/Config.in"
+source "package/ncurses/Config.in"
+source "package/newt/Config.in"
+source "package/pcre/Config.in"
+source "package/popt/Config.in"
+source "package/readline/Config.in"
+source "package/slang/Config.in"
+endmenu
+
+menu "JSON/XML"
+source "package/expat/Config.in"
+source "package/ezxml/Config.in"
+source "package/json-c/Config.in"
+source "package/libroxml/Config.in"
+source "package/libxml-parser-perl/Config.in"
+source "package/libxml2/Config.in"
+source "package/libxslt/Config.in"
+source "package/libyaml/Config.in"
+source "package/mxml/Config.in"
+source "package/xerces/Config.in"
+source "package/yajl/Config.in"
+endmenu
+
+endmenu
+
+menu "Miscellaneous"
+source "package/shared-mime-info/Config.in"
+endmenu
+
+menu "Networking applications"
+source "package/argus/Config.in"
+source "package/avahi/Config.in"
+source "package/axel/Config.in"
+source "package/bluez_utils/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/boa/Config.in"
+endif
+source "package/bind/Config.in"
+source "package/bmon/Config.in"
+source "package/bridge-utils/Config.in"
+source "package/bwm-ng/Config.in"
+source "package/can-utils/Config.in"
+source "package/ctorrent/Config.in"
+source "package/cifs-utils/Config.in"
+source "package/cups/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/dhcp/Config.in"
+endif
+source "package/dhcpdump/Config.in"
+source "package/dnsmasq/Config.in"
+source "package/dropbear/Config.in"
+source "package/ebtables/Config.in"
+source "package/ethtool/Config.in"
+source "package/hostapd/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/ifplugd/Config.in"
+endif
+source "package/iperf/Config.in"
+source "package/iproute2/Config.in"
+source "package/ipsec-tools/Config.in"
+source "package/ipset/Config.in"
+source "package/iptables/Config.in"
+source "package/iw/Config.in"
+source "package/kismet/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/lighttpd/Config.in"
+endif
+source "package/links/Config.in"
+source "package/lrzsz/Config.in"
+source "package/mii-diag/Config.in"
+source "package/mrouted/Config.in"
+source "package/mutt/Config.in"
+source "package/nbd/Config.in"
+source "package/ncftp/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/netcat/Config.in"
+source "package/netkitbase/Config.in"
+source "package/netkittelnet/Config.in"
+endif
+source "package/netplug/Config.in"
+source "package/netsnmp/Config.in"
+source "package/netstat-nat/Config.in"
+source "package/noip/Config.in"
+source "package/nfs-utils/Config.in"
+source "package/ngircd/Config.in"
+source "package/ngrep/Config.in"
+source "package/ntp/Config.in"
+source "package/nuttcp/Config.in"
+source "package/olsr/Config.in"
+source "package/openntpd/Config.in"
+source "package/openssh/Config.in"
+source "package/openvpn/Config.in"
+source "package/portmap/Config.in"
+source "package/pppd/Config.in"
+source "package/pptp-linux/Config.in"
+source "package/proftpd/Config.in"
+source "package/quagga/Config.in"
+source "package/radvd/Config.in"
+source "package/rp-pppoe/Config.in"
+source "package/rsh-redone/Config.in"
+source "package/rsync/Config.in"
+source "package/samba/Config.in"
+source "package/ser2net/Config.in"
+source "package/socat/Config.in"
+source "package/spawn-fcgi/Config.in"
+source "package/squid/Config.in"
+source "package/stunnel/Config.in"
+source "package/tcpdump/Config.in"
+source "package/tcpreplay/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/tftpd/Config.in"
+source "package/thttpd/Config.in"
+source "package/tinyhttpd/Config.in"
+endif
+source "package/tn5250/Config.in"
+source "package/ttcp/Config.in"
+source "package/udpcast/Config.in"
+source "package/vpnc/Config.in"
+source "package/vsftpd/Config.in"
+source "package/vtun/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/wget/Config.in"
+endif
+source "package/wireless_tools/Config.in"
+source "package/wpa_supplicant/Config.in"
+source "package/xl2tp/Config.in"
+
+endmenu
+
+menu "Package managers"
+source "package/ipkg/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/rpm/Config.in"
+endif
+endmenu
+
+menu "Real-Time"
+source "package/xenomai/Config.in"
+source "package/rtai/Config.in"
+endmenu
+
+menu "Shell and utilities"
+source "package/at/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/bash/Config.in"
+source "package/dash/Config.in"
+endif
+source "package/dialog/Config.in"
+source "package/file/Config.in"
+source "package/inotify-tools/Config.in"
+source "package/lockfile-progs/Config.in"
+source "package/logrotate/Config.in"
+source "package/screen/Config.in"
+source "package/sudo/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/which/Config.in"
+endif
+source "package/xmlstarlet/Config.in"
+endmenu
+
+menu "System tools"
+source "package/acl/Config.in"
+source "package/attr/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/bootutils/Config.in"
+endif
+source "package/htop/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/module-init-tools/Config.in"
+source "package/procps/Config.in"
+source "package/psmisc/Config.in"
+source "package/rsyslog/Config.in"
+source "package/sysklogd/Config.in"
+source "package/sysvinit/Config.in"
+endif
+source "package/util-linux/Config.in"
+source "package/dsp-tools/Config.in"
+endmenu
+
+menu "Text editors and viewers"
+source "package/ed/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/less/Config.in"
+endif
+source "package/nano/Config.in"
+source "package/uemacs/Config.in"
+if BR2_PACKAGE_BUSYBOX_SHOW_OTHERS
+source "package/vim/Config.in"
+endif
+endmenu
+
+endmenu
diff -urN buildroot-2011.11.orig/package/games/prboom/prboom.mk buildroot-2011.11/package/games/prboom/prboom.mk
--- buildroot-2011.11.orig/package/games/prboom/prboom.mk	2011-12-20 16:31:25.000000000 +0100
+++ buildroot-2011.11/package/games/prboom/prboom.mk	2011-12-21 10:41:24.615855069 +0100
@@ -17,7 +17,8 @@
 		--with-sdl-exec-prefix=$(STAGING_DIR)/usr \
 		--disable-cpu-opt \
 		--disable-sdltest \
-		--disable-gl
+		--disable-gl \
+		--disable-i386-asm
 
 # endianness detection isn't used when cross compiling
 define PRBOOM_BIG_ENDIAN_FIXUP
diff -urN buildroot-2011.11.orig/package/links/Config.in buildroot-2011.11/package/links/Config.in
--- buildroot-2011.11.orig/package/links/Config.in	2011-12-20 16:31:25.000000000 +0100
+++ buildroot-2011.11/package/links/Config.in	2011-12-21 10:41:24.615855069 +0100
@@ -6,9 +6,8 @@
 	  http://links.twibright.com/
 
 config BR2_PACKAGE_LINKS_GRAPHICS
-	bool "use graphics (directfb)"
+	bool "use graphics"
 	depends on BR2_PACKAGE_LINKS
-	select BR2_PACKAGE_DIRECTFB
 	select BR2_PACKAGE_LIBPNG
 	help
 	  Enable graphics output.
diff -urN buildroot-2011.11.orig/package/links/links.mk buildroot-2011.11/package/links/links.mk
--- buildroot-2011.11.orig/package/links/links.mk	2011-12-20 16:31:25.000000000 +0100
+++ buildroot-2011.11/package/links/links.mk	2011-12-21 10:41:24.615855069 +0100
@@ -11,8 +11,11 @@
 
 ifeq ($(BR2_PACKAGE_LINKS_GRAPHICS),y)
 LINKS_CONF_OPT += --enable-graphics
+LINKS_DEPENDENCIES += libpng gpm
+ifeq ($(BR2_PACKAGE_DIRECTFB),y)
 LINKS_CONF_ENV = ac_cv_path_DIRECTFB_CONFIG=$(STAGING_DIR)/usr/bin/directfb-config
-LINKS_DEPENDENCIES += directfb libpng
+LINKS_DEPENDENCIES += directfb
+endif
 ifeq ($(BR2_PACKAGE_JPEG),y)
 LINKS_DEPENDENCIES += jpeg
 endif
diff -urN buildroot-2011.11.orig/package/multimedia/mplayer/mplayer.mk buildroot-2011.11/package/multimedia/mplayer/mplayer.mk
--- buildroot-2011.11.orig/package/multimedia/mplayer/mplayer.mk	2011-12-20 16:31:25.000000000 +0100
+++ buildroot-2011.11/package/multimedia/mplayer/mplayer.mk	2011-12-21 10:41:24.615855069 +0100
@@ -134,6 +134,15 @@
 		$(MPLAYER_CONF_OPTS) \
 		--enable-cross-compile \
 		--disable-ivtv \
+		--disable-cmov \
+		--disable-fast-cmov \
+		--disable-mmx \
+		--disable-mmxext \
+		--disable-3dnow \
+		--disable-3dnowext \
+		--disable-sse \
+		--disable-sse2 \
+		--disable-ssse3 \
 		--enable-dynamic-plugins \
 	)
 endef
diff -urN buildroot-2011.11.orig/package/multimedia/pulseaudio/pulseaudio-1.0-0001-mute.patch buildroot-2011.11/package/multimedia/pulseaudio/pulseaudio-1.0-0001-mute.patch
--- buildroot-2011.11.orig/package/multimedia/pulseaudio/pulseaudio-1.0-0001-mute.patch	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/package/multimedia/pulseaudio/pulseaudio-1.0-0001-mute.patch	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,34 @@
+diff -urN pulseaudio-1.0/src/utils/padsp.c pulseaudio-1.0-scc/src/utils/padsp.c
+--- pulseaudio-1.0/src/utils/padsp.c	2011-09-01 10:36:46.000000000 +0200
++++ pulseaudio-1.0-scc/src/utils/padsp.c	2011-12-19 16:20:59.000000000 +0100
+@@ -1008,6 +1008,8 @@
+ static int create_playback_stream(fd_info *i) {
+     pa_buffer_attr attr;
+     int n, flags;
++    int mute;
++    char *tmp = NULL;
+ 
+     assert(i);
+ 
+@@ -1029,6 +1031,21 @@
+     attr.minreq = (uint32_t) i->fragment_size;
+ 
+     flags = PA_STREAM_INTERPOLATE_TIMING|PA_STREAM_AUTO_TIMING_UPDATE|PA_STREAM_EARLY_REQUESTS;
++
++    tmp = getenv("PADSP_MUTE");
++    if (tmp) {
++      mute = atoi(tmp);
++    } else {
++      mute = 1;
++    }
++    debug(DEBUG_LEVEL_NORMAL, __FILE__": mute set to: %d\n", mute);
++
++    if (mute != 0) {
++       flags |= PA_STREAM_START_MUTED;
++    } else {
++       flags |= PA_STREAM_START_UNMUTED;
++    }
++
+     if (i->play_precork) {
+         flags |= PA_STREAM_START_CORKED;
+         debug(DEBUG_LEVEL_NORMAL, __FILE__": creating stream corked\n");
diff -urN buildroot-2011.11.orig/package/ncurses/ncurses.mk buildroot-2011.11/package/ncurses/ncurses.mk
--- buildroot-2011.11.orig/package/ncurses/ncurses.mk	2011-12-20 16:31:25.000000000 +0100
+++ buildroot-2011.11/package/ncurses/ncurses.mk	2011-12-21 10:41:24.615855069 +0100
@@ -35,6 +35,7 @@
 	--without-ada \
 	--without-progs \
 	--without-tests \
+	--without-gpm \
 	--disable-big-core \
 	--without-profile \
 	--disable-rpath \
diff -urN buildroot-2011.11.orig/package/scc/Config.in buildroot-2011.11/package/scc/Config.in
--- buildroot-2011.11.orig/package/scc/Config.in	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/package/scc/Config.in	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,7 @@
+menu "Single-chip cloud computer related applications"
+source "package/scc/rhid/Config.in"
+source "package/scc/gpm/Config.in"
+source "package/scc/sccapps/Config.in"
+source "package/scc/usbip/Config.in"
+source "package/scc/imaze/Config.in"
+endmenu
diff -urN buildroot-2011.11.orig/package/scc/gpm/Config.in buildroot-2011.11/package/scc/gpm/Config.in
--- buildroot-2011.11.orig/package/scc/gpm/Config.in	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/package/scc/gpm/Config.in	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,5 @@
+config BR2_PACKAGE_GPM
+	bool "gpm"
+	help
+	  Special GPM version patched to work with RHID.
+	depends on BR2_PACKAGE_RHID
diff -urN buildroot-2011.11.orig/package/scc/gpm/gpm.mk buildroot-2011.11/package/scc/gpm/gpm.mk
--- buildroot-2011.11.orig/package/scc/gpm/gpm.mk	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/package/scc/gpm/gpm.mk	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,13 @@
+#############################################################
+#
+# gpm
+#
+#############################################################
+
+GPM_VERSION := 1.20.6
+GPM_SITE :=
+GPM_SOURCE = gpm-$(GPM_VERSION)-rck.tar.bz2
+GPM_INSTALL_STAGING = YES
+GPM_INSTALL_TARGET = YES
+
+$(eval $(call AUTOTARGETS,package/scc,gpm))
diff -urN buildroot-2011.11.orig/package/scc/imaze/Config.in buildroot-2011.11/package/scc/imaze/Config.in
--- buildroot-2011.11.orig/package/scc/imaze/Config.in	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/package/scc/imaze/Config.in	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,6 @@
+config BR2_PACKAGE_IMAZE
+	bool "iMaze"
+        depends on BR2_PACKAGE_GPM
+        depends on BR2_PACKAGE_XLIB_LIBXAW
+	help
+	  iMaze is a simple multi-player network action game for TCP/IP with 3D graphics.
diff -urN buildroot-2011.11.orig/package/scc/imaze/imaze.mk buildroot-2011.11/package/scc/imaze/imaze.mk
--- buildroot-2011.11.orig/package/scc/imaze/imaze.mk	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/package/scc/imaze/imaze.mk	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,30 @@
+#############################################################
+#
+# imaze
+#
+#############################################################
+IMAZE_VERSION = 1.4
+IMAZE_SOURCE = imaze-$(IMAZE_VERSION).tar.gz
+IMAZE_SITE = http://home.tu-clausthal.de/student/iMaze/files/
+IMAZE_INSTALL_STAGING = NO
+IMAZE_INSTALL_TARGET = YES
+IMAZE_DEPENDENCIES = xlib_libXaw
+
+define IMAZE_BUILD_CMDS
+	(cd $(@D)/source && ./configure athena)
+	$(MAKE) -C $(@D)/source CC="$(TARGET_CC)"
+endef
+
+define IMAZE_INSTALL_TARGET_CMDS
+	$(MAKE) -C $(@D)/source install
+	$(INSTALL) -D -m 0755 $(@D)/imaze $(TARGET_DIR)/usr/games/
+	$(INSTALL) -D -m 0755 $(@D)/imazesrv $(TARGET_DIR)/usr/bin/
+	$(INSTALL) -D -m 0755 $(@D)/imazestat $(TARGET_DIR)/usr/bin/
+	$(INSTALL) -D -m 0755 $(@D)/ninja $(TARGET_DIR)/usr/bin/
+	cp -R $(@D)/labs $(TARGET_DIR)/usr/share/games/imaze/
+        chmod 755 $(TARGET_DIR)/usr/share/games/imaze/labs
+	cp -R $(@D)/sounds $(TARGET_DIR)/usr/share/games/imaze/
+        chmod 755 $(TARGET_DIR)/usr/share/games/imaze/sounds
+endef
+
+$(eval $(call GENTARGETS,package/scc,imaze))
diff -urN buildroot-2011.11.orig/package/scc/rhid/Config.in buildroot-2011.11/package/scc/rhid/Config.in
--- buildroot-2011.11.orig/package/scc/rhid/Config.in	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/package/scc/rhid/Config.in	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,5 @@
+config BR2_PACKAGE_RHID
+	bool "rhid"
+	help
+	  Remote Human Interface Device (keyboard/mouse/sound via ethernet) for sccDisplay.
+
diff -urN buildroot-2011.11.orig/package/scc/rhid/rhid.mk buildroot-2011.11/package/scc/rhid/rhid.mk
--- buildroot-2011.11.orig/package/scc/rhid/rhid.mk	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/package/scc/rhid/rhid.mk	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,20 @@
+#############################################################
+#
+# rhid
+#
+#############################################################
+RHID_VERSION = 0.4.0
+RHID_SOURCE = rhid-$(RHID_VERSION).tar.bz2
+RHID_SITE = 
+RHID_INSTALL_STAGING = NO
+RHID_INSTALL_TARGET = YES
+
+define RHID_BUILD_CMDS
+	$(MAKE) CC="$(TARGET_CC)" -C $(@D) all
+endef
+
+define RHID_INSTALL_TARGET_CMDS
+	$(INSTALL) -D -m 0755 $(@D)/rhid $(TARGET_DIR)/usr/bin/
+endef
+
+$(eval $(call GENTARGETS,package/scc,rhid))
diff -urN buildroot-2011.11.orig/package/scc/sccapps/Config.in buildroot-2011.11/package/scc/sccapps/Config.in
--- buildroot-2011.11.orig/package/scc/sccapps/Config.in	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/package/scc/sccapps/Config.in	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,5 @@
+config BR2_PACKAGE_SCCAPPS
+	bool "SCCAPPS"
+	help
+	  Essential SCC Applications.
+
diff -urN buildroot-2011.11.orig/package/scc/sccapps/sccapps.mk buildroot-2011.11/package/scc/sccapps/sccapps.mk
--- buildroot-2011.11.orig/package/scc/sccapps/sccapps.mk	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/package/scc/sccapps/sccapps.mk	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,30 @@
+#############################################################
+#
+# sccapps
+#
+#############################################################
+SCCAPPS_VERSION = 1.0.2
+SCCAPPS_SOURCE = sccapps-$(SCCAPPS_VERSION).tar.bz2
+SCCAPPS_SITE = 
+SCCAPPS_INSTALL_STAGING = NO
+SCCAPPS_INSTALL_TARGET = YES
+
+define SCCAPPS_BUILD_CMDS
+	$(MAKE) CC="$(TARGET_CC)" -C $(@D) all
+endef
+
+define SCCAPPS_INSTALL_TARGET_CMDS
+	$(INSTALL) -D -m 0755 $(@D)/paranoia $(TARGET_DIR)/usr/bin/
+#	$(INSTALL) -D -m 0755 $(@D)/tst-ieee754 $(TARGET_DIR)/usr/bin/
+#	$(INSTALL) -D -m 0755 $(@D)/nearestint $(TARGET_DIR)/usr/bin/
+	$(INSTALL) -D -m 0755 $(@D)/pid $(TARGET_DIR)/usr/bin/
+	$(INSTALL) -D -m 0755 $(@D)/status $(TARGET_DIR)/usr/bin/
+	$(INSTALL) -D -m 0755 $(@D)/checkMesh $(TARGET_DIR)/usr/bin/
+#	$(INSTALL) -D -m 0755 $(@D)/configPerf $(TARGET_DIR)/usr/bin/
+	$(INSTALL) -D -m 0755 $(@D)/cpuutil $(TARGET_DIR)/usr/bin/
+#	$(INSTALL) -D -m 0755 $(@D)/nettest $(TARGET_DIR)/usr/bin/
+	$(INSTALL) -D -m 0755 $(@D)/mute-stream $(TARGET_DIR)/usr/bin/
+	$(INSTALL) -D -m 0755 $(@D)/emactool $(TARGET_DIR)/usr/bin/
+endef
+
+$(eval $(call GENTARGETS,package/scc,sccapps))
diff -urN buildroot-2011.11.orig/package/scc/scc.mk buildroot-2011.11/package/scc/scc.mk
--- buildroot-2011.11.orig/package/scc/scc.mk	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/package/scc/scc.mk	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1 @@
+include package/scc/*/*.mk
diff -urN buildroot-2011.11.orig/package/scc/usbip/Config.in buildroot-2011.11/package/scc/usbip/Config.in
--- buildroot-2011.11.orig/package/scc/usbip/Config.in	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/package/scc/usbip/Config.in	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,5 @@
+config BR2_PACKAGE_USBIP
+	bool "USB-IP"
+	help
+	  USB over IP.
+
diff -urN buildroot-2011.11.orig/package/scc/usbip/usbip.mk buildroot-2011.11/package/scc/usbip/usbip.mk
--- buildroot-2011.11.orig/package/scc/usbip/usbip.mk	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/package/scc/usbip/usbip.mk	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,15 @@
+#############################################################
+#
+# usbip
+#
+#############################################################
+
+USBIP_VERSION := 0.1.7
+USBIP_SITE :=
+USBIP_SOURCE = usbip-$(USBIP_VERSION)-rck.tar.bz2
+USBIP_CONF_OPT = \
+	--prefix=/usr
+USBIP_INSTALL_STAGING = YES
+USBIP_INSTALL_TARGET = YES
+
+$(eval $(call AUTOTARGETS,package/scc,usbip))
diff -urN buildroot-2011.11.orig/selfboot/fastBoot.mt buildroot-2011.11/selfboot/fastBoot.mt
--- buildroot-2011.11.orig/selfboot/fastBoot.mt	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/selfboot/fastBoot.mt	2011-12-21 10:41:24.615855069 +0100
@@ -0,0 +1,49 @@
+# pid mch-route mch-dest-id mch-offset-base testcase
+0x00 0x00 6 0x00 ./fastBoot.obj
+0x01 0x00 6 0x01 ./fastBoot.obj
+0x02 0x00 6 0x02 ./fastBoot.obj
+0x03 0x00 6 0x03 ./fastBoot.obj
+0x04 0x00 6 0x04 ./fastBoot.obj
+0x05 0x00 6 0x05 ./fastBoot.obj
+0x06 0x05 4 0x00 ./fastBoot.obj
+0x07 0x05 4 0x01 ./fastBoot.obj
+0x08 0x05 4 0x02 ./fastBoot.obj
+0x09 0x05 4 0x03 ./fastBoot.obj
+0x0a 0x05 4 0x04 ./fastBoot.obj
+0x0b 0x05 4 0x05 ./fastBoot.obj
+0x0c 0x00 6 0x06 ./fastBoot.obj
+0x0d 0x00 6 0x07 ./fastBoot.obj
+0x0e 0x00 6 0x08 ./fastBoot.obj
+0x0f 0x00 6 0x09 ./fastBoot.obj
+0x10 0x00 6 0x0a ./fastBoot.obj
+0x11 0x00 6 0x0b ./fastBoot.obj
+0x12 0x05 4 0x06 ./fastBoot.obj
+0x13 0x05 4 0x07 ./fastBoot.obj
+0x14 0x05 4 0x08 ./fastBoot.obj
+0x15 0x05 4 0x09 ./fastBoot.obj
+0x16 0x05 4 0x0a ./fastBoot.obj
+0x17 0x05 4 0x0b ./fastBoot.obj
+0x18 0x20 6 0x00 ./fastBoot.obj
+0x19 0x20 6 0x01 ./fastBoot.obj
+0x1a 0x20 6 0x02 ./fastBoot.obj
+0x1b 0x20 6 0x03 ./fastBoot.obj
+0x1c 0x20 6 0x04 ./fastBoot.obj
+0x1d 0x20 6 0x05 ./fastBoot.obj
+0x1e 0x25 4 0x00 ./fastBoot.obj
+0x1f 0x25 4 0x01 ./fastBoot.obj
+0x20 0x25 4 0x02 ./fastBoot.obj
+0x21 0x25 4 0x03 ./fastBoot.obj
+0x22 0x25 4 0x04 ./fastBoot.obj
+0x23 0x25 4 0x05 ./fastBoot.obj
+0x24 0x20 6 0x06 ./fastBoot.obj
+0x25 0x20 6 0x07 ./fastBoot.obj
+0x26 0x20 6 0x08 ./fastBoot.obj
+0x27 0x20 6 0x09 ./fastBoot.obj
+0x28 0x20 6 0x0a ./fastBoot.obj
+0x29 0x20 6 0x0b ./fastBoot.obj
+0x2a 0x25 4 0x06 ./fastBoot.obj
+0x2b 0x25 4 0x07 ./fastBoot.obj
+0x2c 0x25 4 0x08 ./fastBoot.obj
+0x2d 0x25 4 0x09 ./fastBoot.obj
+0x2e 0x25 4 0x0a ./fastBoot.obj
+0x2f 0x25 4 0x0b ./fastBoot.obj
diff -urN buildroot-2011.11.orig/selfboot/fastBoot.obj buildroot-2011.11/selfboot/fastBoot.obj
--- buildroot-2011.11.orig/selfboot/fastBoot.obj	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/selfboot/fastBoot.obj	2011-12-21 10:41:24.628365109 +0100
@@ -0,0 +1,2885 @@
+/origin 00000000
+d88ec88c 801e010f 16010f18 01b81888
+f0010f00 68b800eb 8ed88e00 8ed08ec0
+66e88ee0 b00000bc c0200f00 ffff2566
+220f9fff 00ea66c0 60000100 00000000
+4ceb006a 48eb016a 44eb026a 40eb036a
+3ceb046a 38eb056a 34eb066a 30eb076a
+2ceb086a 28eb096a 24eb0a6a 20eb0b6a
+1ceb0c6a 18eb0d6a 14eb0e6a 10eb0f6a
+0ceb106a 08eb116a 04eb126a 00eb136a
+5452b860 15e8494e 8b000000 50202444
+00000be8 c0855800 61f40175 cf04c483
+1bb8c389 66000000 890ff8ba fcba66d8
+0000c30f 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+0000ffff 00cf9a00 0000ffff 00cf9200
+0000ffff 00cffa00 0000ffff 00cff200
+00600040 00008e00 00600044 00008e00
+00600048 00008e00 0060004c 00008e00
+00600050 00008e00 00600054 00008e00
+00600058 00008e00 0060005c 00008e00
+00600060 00008e00 00600064 00008e00
+00600068 00008e00 0060006c 00008e00
+00600070 00008e00 00600074 00008e00
+00600078 00008e00 0060007c 00008e00
+00600080 00008e00 00600084 00008e00
+00600088 00008e00 0060008c 00008e00
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+108007ff 00000000 1000007f 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00b8fcfa 8ed88e00 8ee08ec0 bcd08ee8
+17ea3000 0f000020 18801e01 8816010f
+0001b818 ebf0010f 0068b800 c08ed88e
+e08ed08e bc66e88e 00b00000 66c0200f
+ffffff25 c0220f9f 2080ea66 00600000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+e00020b8 c1008bfe c06918e8 00020000
+69e9c429 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+002100ea 00006000 
+/origin 00004000
+e483ed31 3000b8f0 36e80000 c7000000
+01730c05 01800000 0000bd00 ed850000
+d9e80574 68fffeff 00018000 01800468
+e8016a00 00000120 003001b8 0003e800
+ebf40000 b8c389fd 0000001b 0ff8ba66
+ba66d889 00c30ffc 56e58955 e8fc5d89
+00000000 9cc3815b 8d00007f 00000083
+85008b00 832074c0 838df8c4 00000000
+0489008b 00838d24 89000170 e8042444
+fffeff6c 8b08c483 c3c9fc5d 56e58955
+e8fc5d89 00000000 58c3815b 8d00007f
+00000083 85008b00 571274c0 0000838d
+008b0000 e8240489 fffeff34 fc5d8b59
+f689c3c9 8be58955 c2890845 8904c283
+408b0855 fff88304 25eb1575 8908458b
+04c283c2 8b085589 f8830440 8b1274ff
+008b0845 e474c085 8b08458b ebd0ff00
+90c3c9db 56e58955 e8fc5d89 00000000
+e0c3815b 5700007e 801c838d 008b0001
+0489008b 2a96e824 57590000 0000838d
+008b0000 e8240489 ffffff88 ff4ae859
+5d8bffff 90c3c9fc 6a10ec83 4e00e803
+006a0000 000f79e8 01006800 27e8f800
+8300000f c5890cc4 eac1ea89 0fe28303
+e9c1e989 0fe18307 8d07e583 048d491c
+455c8d5a 04fa8300 f983157d 0000b802
+057ce000 000000b8 244489ec 8320eb08
+0b7d02f9 000000b8 244489e3 b810eb08
+ef000000 00b8057d 89000000 68082444
+e0000bf8 000ec1e8 c7895900 0f41f989
+0001e988 89d23100 0de6c1ee 0000868d
+7c89d800 5c890c24 2c890424 89c38924
+6acf89d5 97e85300 8300000e c38308c4
+fd394508 7c8bed7e 5c8b0c24 2c8b0424
+00868d24 89d80010 6a042444 6fe85000
+8300000e ed8508c4 80680b75 e8f80000
+00000e56 0fdb8559 0000e384 06fb8300
+00da840f fb830000 d1840f18 83000000
+840f1efb 000000c8 8c0fff85 000000c0
+448bd231 808d0824 00000808 00009e8d
+3489d800 247c8924 89c6890c b9ed85d7
+00001000 00b90575 81000008 000008c1
+f3e851f8 8900000d b8ed85c1 00001000
+00b80575 05000008 f8000400 ff0f4c8d
+dbe85051 5600000d 000dcde8 85c18900
+1000b8ed 05750000 000800b8 04080500
+4c8df800 5051ff0f 000db5e8 00006800
+00680100 68810000 80000000 004c39e8
+00ff6800 e8530000 00000d96 4c8b006a
+e8513424 00000d8a 8334c483 8b4708c3
+390c244c 628e0fcf 8bffffff cf892434
+001000b8 75ed8500 0800b805 00050000
+50f80000 000d51e8 1000ba00 ed850000
+00ba0575 81000008 000400c2 e85250f8
+00000d3e 1424448b 00080005 27e85000
+ba00000d 00001000 0575ed85 000800ba
+08c28100 48f80004 13e85250 6800000d
+00001000 fff00068 f0006881 efe880ff
+8d000049 0008fe84 ff68d800 50000000
+000cede8 8b006a00 50342444 000ce1e8
+34c48300 05e8016a 5900000c ee89f6eb
+e90de6c1 fffffe49 bac031fb fee00280
+02890289 02890289 e000e0b8 ff00c7fe
+b80fffff fee000d0 ff25008b 0d00ffff
+01000000 e000d0ba b80289fe fee00080
+0025008b baffffff fee00080 f0b80289
+8bfee000 fd002500 000dffff ba000001
+fee000f0 50b80289 c7fee003 00002000
+31fbc300 0280b8d2 1089fee0 10891089
+e0b81089 c7fee000 ffffff00 00d0b80f
+008bfee0 ffffff25 4cb60f00 01ba0c24
+d3000000 18e2c1e2 d0bad009 89fee000
+0080b802 008bfee0 ffff0025 0080baff
+0289fee0 e000f0b8 25008bfe fffffd00
+0001000d 00f0ba00 0289fee0 2444b60f
+00000d10 20ba0002 89fee003 03e0b802
+008bfee0 0824448b ba0fe083 fee003e0
+80ba0289 8bfee003 89042444 ec83c302
+24548b08 80828d0c 39000000 834273c2
+0010247c 5c892e74 34890424 89c38924
+00b6ffd6 68fee000 000157cc 001641e8
+08c48300 3910c683 8be672de 8b04245c
+0deb2434 00008a8b c283fee0 72c23910
+57d468f3 17e80001 83000016 90c30cc4
+0424448b 0824548b c3895355 0000ab8b
+fa83fee0 50850f01 81000001 000320fb
+67840f00 81000001 000330fb 4b840f00
+81000001 000340fb 2f840f00 81000001
+000350fb 812a7400 000360fb 550d7500
+0157f068 15b8e800 20eb0000 0370fb81
+1b750000 57d86855 a3e80001 eb000015
+0868550b e8000158 00001596 f708c483
+010000c5 b8077400 0001588c 80b805eb
+50000158 015bd868 1574e800 c4830000
+60fb8108 74000003 50fb8108 75000003
+00c5f766 74000080 589cb807 05eb0001
+015894b8 00685000 e800015c 00001542
+f708c483 004000c5 b8077400 000158a8
+a4b805eb 50000158 015c3068 1520e800
+c4830000 00c5f708 74000020 58a8b807
+05eb0001 0158a4b8 5c685000 e800015c
+000014fe f708c483 001000c5 b8077400
+000158b4 acb805eb 50000158 015c9468
+14dce800 c4830000 70fb8108 74000003
+c1e88916 e08308e8 c8685007 e800015c
+000014be 8108c483 0000ffe5 f8685500
+e800015c 000014aa 5b08c483 6855c35d
+00015820 001499e8 fefee900 6855ffff
+00015838 001489e8 feeee900 6855ffff
+00015850 001479e8 08c48300 0000c5f7
+07740002 015874b8 b805eb00 00015868
+5bac6850 57e80001 e9000014 fffffebc
+53555657 8b08ec83 851c2474 48840ff6
+68000007 000158c4 001435e8 58c86800
+2be80001 68000014 000158e0 001421e8
+0020b800 188bfee0 58fc6853 0fe80001
+c1000014 685318eb 00015d24 001401e8
+0030b800 188bfee0 edc1dd89 ffe58110
+53000000 01591468 13e4e800 68550000
+00015d58 0013d9e8 dbb60f00 5d946853
+cbe80001 b8000013 fee00080 6853188b
+0001592c 0013b9e8 c1d88900 e08304e8
+c068500f e800015d 000013a6 530fe383
+015df468 1398e800 90b80000 8bfee000
+44685318 e8000159 00001386 e8c1d889
+0fe08304 5e306850 73e80001 83000013
+68530fe3 00015b00 001365e8 00a0b800
+188bfee0 595c6853 53e80001 89000013
+04e8c1d8 500fe083 015e6868 1340e800
+e3830000 a068530f e800015e 00001332
+687cc483 00015ee0 001325e8 00d0b800
+188bfee0 59746853 13e80001 c1000013
+685318eb 00015f1c 001305e8 00e0b800
+188bfee0 598c6853 f3e80001 c1000012
+68531ceb 00015b60 0012e5e8 00f0b800
+188bfee0 59a46853 d3e80001 83000012
+c7f62cc4 b8077402 000159c8 bcb805eb
+50000159 015f5468 12b4e800 c4830000
+01c7f608 c8b80774 eb000159 59bcb805
+68500001 00015f90 001295e8 dbb60f00
+5fc06853 87e80001 68000012 000159d0
+00127de8 14c48300 000100bb 00b3ff00
+68fee000 000157cc 001265e8 08c48300
+8110c383 000180fb 68e27200 000157d4
+00124de8 59e46800 43e80001 83000012
+f68508c4 80bb2574 ff000001 e00000b3
+57cc68fe 27e80001 83000012 c38308c4
+00fb8110 72000002 b815ebe2 00000180
+0000908b c083fee0 02003d10 f0720000
+0157d468 11f8e800 f8680000 e8000159
+000011ee 8508c483 bb2574f6 00000200
+0000b3ff cc68fee0 e8000157 000011d2
+8308c483 fb8110c3 00000280 15ebe272
+000200b8 00908b00 83fee000 803d10c0
+72000002 57d468f0 a3e80001 b8000011
+fee00280 00ff00c7 188b0000 5a0c6853
+8be80001 83000011 c3f70cc4 00000080
+2cb80774 eb00015a 5a24b805 68500001
+00015ff8 001169e8 08c48300 7440c3f6
+5a2cb807 05eb0001 015a24b8 34685000
+e8000160 0000114a f608c483 077420c3
+015a2cb8 b805eb00 00015a24 60706850
+2be80001 83000011 c3f608c4 b8077408
+00015a2c 24b805eb 5000015a 0160a868
+110ce800 c4830000 04c3f608 2cb80774
+eb00015a 5a24b805 68500001 000160e0
+0010ede8 08c48300 7402c3f6 5a2cb807
+05eb0001 015a24b8 14685000 e8000161
+000010ce f608c483 077401c3 015a2cb8
+b805eb00 00015a24 614c6850 afe80001
+bf000010 fee00310 00b83f8b 8bfee003
+68575318 00015a34 001095e8 18efc100
+61846857 87e80001 89000010 12e8c1d8
+5003e083 0161b868 1074e800 c4830000
+00c3f724 74000080 589cb807 05eb0001
+015894b8 00685000 e800015c 00001052
+f608c483 077440c7 015a5cb8 b805eb00
+00015a50 61f06850 33e80001 83000010
+c7f608c4 b8077410 00015a64 acb805eb
+50000158 015c9468 1014e800 c4830000
+08c7f608 7cb80774 eb00015a 5a70b805
+68500001 00016218 000ff5e8 c1d88900
+e08308e8 c8685007 e800015c 00000fe2
+53dbb60f 015cf868 0fd4e800 c4830000
+0fed8518 0001f782 83db3100 870f05fb
+000001e3 209d048b ff000152 0330b8e0
+f2890000 fff99fe8 01c9e9ff 40b80000
+89000003 f98ee8f2 b8e9ffff b8000001
+00000370 7de8f289 e9fffff9 000001a7
+000360b8 e8f28900 fffff96c 000196e9
+0350b800 388bfee0 0f01fe83 00018685
+08685700 e8000158 00000f56 f708c483
+010000c7 b8077400 0001588c 80b805eb
+50000158 015bd868 0f34e800 c4830000
+00c7f708 74000080 589cb807 05eb0001
+015894b8 00685000 e800015c 00000f12
+f708c483 004000c7 b8077400 000158a8
+a4b805eb 50000158 015c3068 0ef0e800
+c4830000 00c7f708 74000020 58a8b807
+05eb0001 0158a4b8 5c685000 e800015c
+00000ece f708c483 001000c7 b8077400
+000158b4 acb805eb 50000158 015c9468
+0eace800 f8890000 8308e8c1 685007e0
+00015cc8 000e99e8 ffe78100 57000000
+015cf868 0e88e800 a5e90000 b8000000
+fee00320 fe83388b 98850f01 57000000
+01585068 0e68e800 c4830000 00c7f708
+74000200 5874b807 05eb0001 015868b8
+ac685000 e800015b 00000e46 f708c483
+010000c7 b8077400 0001588c 80b805eb
+50000158 015bd868 0e24e800 c4830000
+00c7f708 74000010 58b4b807 05eb0001
+0158acb8 94685000 e800015c 00000e02
+e8c1f889 07e08308 5cc86850 efe80001
+8100000d 0000ffe7 f8685700 e800015c
+00000dde 4318c483 860feb39 fffffe0b
+e00380b8 6830fffe 00015a84 000dc1e8
+0390b800 30fffee0 015a9c68 0db0e800
+e0b80000 8bfee003 b4685318 e800015a
+00000d9e e9c1d989 01e18303 ead1da89
+8901e283 01e083d8 68515250 0001624c
+000d7de8 28c48300 830be383 68770bfb
+389d048b ff000152 5acc68e0 5fe80001
+eb00000d 5ad06852 53e80001 eb00000d
+5ad86846 47e80001 eb00000d 5adc683a
+3be80001 eb00000d 5ae0682e 2fe80001
+eb00000d 5ae46822 23e80001 eb00000d
+5ae86816 17e80001 eb00000d 5aec680a
+0be80001 5900000d 0158c468 0d00e800
+83590000 5d5b08c4 b8c35f5e fee00020
+30b9108b 8bfee000 0080bd19 7d8bfee0
+0090b800 008bfee0 e000a0b8 b8008bfe
+fee000d0 e0b8008b 8bfee000 00f0b800
+008bfee0 000100b8 00908b00 83fee000
+803d10c0 72000001 57d468f0 9fe80001
+5900000c 2574f685 000180bb 00b3ff00
+68fee000 000157cc 000c85e8 08c48300
+8110c383 000200fb ebe27200 0180b815
+908b0000 fee00000 3d10c083 00000200
+d468f072 e8000157 00000c56 74f68559
+0200bb25 b3ff0000 fee00000 0157cc68
+0c3ce800 c4830000 10c38308 0280fb81
+e2720000 00b815eb 8b000002 e0000090
+10c083fe 0002803d 68f07200 000157d4
+000c0de8 80b85900 8bfee002 0300b910
+198bfee0 e00310bd 00758bfe e00320bf
+b8078bfe fee00330 40b8008b 8bfee003
+0350b800 008bfee0 e00360b8 b8008bfe
+fee00370 80b8008b 8bfee003 0390b800
+008bfee0 e003e0b8 83008bfe 5d5b08c4
+90c35f5e e00320b8 81108bfe 010000ca
+ffe28100 89fffdff 00f0b810 008bfee0
+fffeff25 00f0baff 0289fee0 000090c3
+c189310f 04245469 00000c35 0d89d101
+000172f0 c139310f 0f900b7e f0053b31
+7c000172 4c8bc3f5 b60f0424 0f082444
+c281d1b7 00600000 80c51489 81000010
+ff0000e1 00c181ff 8900008e 1084c50c
+90c30000 90c3090f 90c30a0f 0424448b
+000000c7 90c30000 08244c8b 0c24448b
+1024548b 7d06f983 04f88335 fa83307d
+c12b7d02 7c830de2 74001424 00c28108
+ebd80000 18e1c112 c140048d c10119e0
+0011948d 8bc00000 89042444 5052c310
+62a06851 c7e80001 8300000a 448b10c4
+00c70424 00000000 548b90c3 028b0424
+548b90c3 448b0424 02890824 555790c3
+0c246c8b 10244c8b 1424448b bf00558b
+00000001 c085e7d3 fa090474 d7f704eb
+5589fa21 c35f5d00 03e8016a 59000000
+835790c3 448b10ec c0851824 d8681374
+e8000162 00000a5a e8006a59 00000980
+31ff3159 b8d231c9 00b01000 89241c89
+89042474 8908246c c1fbd1fb fb011eeb
+8502fbc1 dd8d0fdb 81000000 0000fbfb
+81087400 0000fefb ba0c7500 00000001
+00001fb9 8121eb00 0000fffb ba0c7500
+00000001 000007b9 850deb00 890975d2
+0000bd04 41eb00b0 e3c1fb89 00ab8d0c
+8300b010 2c8907cd b00000bd 00b38d00
+8900b010 16e5c1fd 2000c381 7c8900b0
+ef890c24 3e89cf09 1000c581 c6830000
+77f33904 247c8bed 1000050c 81470000
+000400ff 5c8c0f00 8bffffff 748b241c
+6c8b0424 b8500824 00b00000 220fc089
+c0200fd8 0000000d c0220f80 0de0200f
+00000800 58e0220f 1824448b 1374c085
+01627c68 0958e800 6a590000 087ee800
+83590000 c35f10c4 ff418e0f 117fffff
+00fbfb81 840f0000 ffffff1f ffff12e9
+7ffb83ff d231077f ffff32e9 80fb81ff
+0f000000 fffef28c 83fb81ff 7f000000
+0001ba0f 1fb90000 e9000000 ffffff18
+0084fb81 b87c0000 00bffb81 077f0000
+f8e9d231 81fffffe 0000c0fb b88c0f00
+81fffffe 0000d8fb ba0f7f00 00000001
+000087b9 fedee900 fb81ffff 000000d9
+ff7a8c0f fb81ffff 000000df d231077f
+fffebae9 e0fb81ff 0f000000 fffe7a8c
+f8fb81ff 7f000000 0001ba0f 1fb90000
+e9000000 fffffea0 00f9fb81 8c0f0000
+ffffff3c 00fafb81 077f0000 7ce9d231
+81fffffe 0000fbfb 4c840f00 81fffffe
+0000fcfb 388c0f00 81fffffe 0000fdfb
+2c8f0f00 31fffffe fe51e9d2 0000ffff
+83535556 b70f08ec 8918246c 08ebc1eb
+eac1ea89 09fa830c 000037b8 b8057f00
+00000030 b60fc201 0af983ca 0db81275
+89000000 e8042454 000004db 0424548b
+0172f8a1 08358b00 8b000173 31148808
+72f8158b 02ff0001 0172f8a1 00388100
+7c000080 0000c706 83000000 fb830fe3
+0037b809 057f0000 000030b8 0fc30100
+fa83d3b6 b80a750a 0000000d 000486e8
+72f8a100 0d8b0001 00017308 1c88108b
+f8358b0a ff000172 72f8a106 38810001
+00008000 00c7067c 00000000 e381eb89
+000000ff eac1da89 09fa8304 000037b8
+b8057f00 00000030 b60fc201 0af983ca
+0db81275 89000000 e8042454 00000427
+0424548b 0172f8a1 08358b00 8b000173
+31148808 72f8158b 02ff0001 0172f8a1
+00388100 7c000080 0000c706 83000000
+fb830fe3 0037b809 057f0000 000030b8
+0fc30100 fa83d3b6 b80a750a 0000000d
+0003d2e8 72f8a100 0d8b0001 00017308
+1c88108b f81d8b0a ff000172 72f8a103
+38810001 00008000 00c7067c 00000000
+5b08c483 90c35e5d b60f5653 c10c245c
+fb8304eb 0037b809 057f0000 000030b8
+0fc30100 fa83d3b6 b80a750a 0000000d
+000372e8 72f8a100 0d8b0001 00017308
+1c88108b f81d8b0a ff000172 72f8a103
+38810001 00008000 00c7067c 00000000
+245cb60f 0fe3830c b809fb83 00000037
+30b8057f 01000000 d3b60fc3 750afa83
+000db80a 1ce80000 a1000003 000172f8
+73080d8b 108b0001 8b0a1c88 0172f81d
+a103ff00 000172f8 80003881 067c0000
+000000c7 5b590000 565790c3 ec835355
+24548b08 c1d5891c d38910ed c118ebc1
+fa831cea 0037b809 057f0000 000030b8
+0fc20100 f983cab6 b812750a 0000000d
+04245489 0002aee8 24548b00 72f8a104
+358b0001 00017308 1488088b f8158b31
+ff000172 72f8a102 38810001 00008000
+00c7067c 00000000 830fe383 37b809fb
+7f000000 0030b805 c3010000 83d3b60f
+0a750afa 00000db8 0259e800 f8a10000
+8b000172 0173080d 88108b00 358b0a1c
+000172f8 f8a106ff 81000172 00800038
+c7067c00 00000000 81eb8900 0000ffe3
+c1da8900 fa8304ea 0037b809 057f0000
+000030b8 0fc20100 f983cab6 b812750a
+0000000d 04245489 0001fae8 24548b00
+72f8a104 358b0001 00017308 1488088b
+f8158b31 ff000172 72f8a102 38810001
+00008000 00c7067c 00000000 830fe383
+37b809fb 7f000000 0030b805 c3010000
+83d3b60f 0a750afa 00000db8 01a5e800
+f8a10000 8b000172 0173080d 88108b00
+1d8b0a1c 000172f8 f8a103ff 81000172
+00800038 c7067c00 00000000 24548b00
+eab70f1c ebc1eb89 c1ea8908 fa830cea
+0037b809 057f0000 000030b8 0fc20100
+f983cab6 b812750a 0000000d 04245489
+000142e8 24548b00 72f8a104 358b0001
+00017308 1488088b f8158b31 ff000172
+72f8a102 38810001 00008000 00c7067c
+00000000 830fe383 37b809fb 7f000000
+0030b805 c3010000 83d3b60f 0a750afa
+00000db8 00ede800 f8a10000 8b000172
+0173080d 88108b00 358b0a1c 000172f8
+f8a106ff 81000172 00800038 c7067c00
+00000000 81eb8900 0000ffe3 c1da8900
+fa8304ea 0037b809 057f0000 000030b8
+0fc20100 f983cab6 b812750a 0000000d
+04245489 00008ee8 24548b00 72f8a104
+358b0001 00017308 1488088b f8158b31
+ff000172 72f8a102 38810001 00008000
+00c7067c 00000000 830fe383 37b809fb
+7f000000 0030b805 c3010000 83d3b60f
+0a750afa 00000db8 0039e800 f8a10000
+8b000172 0173080d 88108b00 1d8b0a1c
+000172f8 f8a103ff 81000172 00800038
+c7067c00 00000000 08c48300 5f5e5d5b
+b60f90c3 53042444 0fc38956 fa83d3b6
+b80a750a 0000000d ffffeae8 72f8a1ff
+0d8b0001 00017308 1c88108b f81d8b0a
+ff000172 72f8a103 38810001 00008000
+00c7067c 00000000 90c35b59 53555657
+8b08ec83 ba1c244c 05f5e100 09b8db31
+89000000 89d689c5 f7d231c8 85c789f6
+894a75ff 00ff25e8 b60f0000 3920247c
+85047ef8 8b2f74db 0172f83d 7308a100
+3f8b0001 300704c6 72f83d8b 07ff0001
+72f83d8b 3f810001 00008000 07c7627c
+00000000 f8835aeb ebcc7401 305f8d53
+83c3b60f 12750af8 00000db8 244c8900
+ff31e804 4c8bffff f8a10424 8b000172
+01730815 88008b00 1d8b101c 000172f8
+1d8b03ff 000172f8 80003b81 067c0000
+000003c7 af0f0000 bbf929fe 00000001
+cccdb84d e6f7cccc eec1d689 81ef8903
+0000ffe7 0fff8500 ffff3a85 08c483ff
+5f5e5d5b ec8390c3 24548b0c 02b60f10
+5774c085 08245c89 04247489 d689c389
+750afb83 000db80a a8e80000 8bfffffe
+0172f80d 7308a100 098b0001 8b011c88
+0172f81d a103ff00 000172f8 80003881
+067c0000 000000c7 b60f0000 8546015e
+8bbd75db 8b08245c 83042474 90c30cc4
+b9e8006a 59000000 535590c3 0c24548b
+10244c8b 14245c8b 7d03fa83 02f9830c
+00b8187d eb800000 02f9831d 00b8077d
+eb810000 03fa8316 00b8077d eb820000
+0000b805 fa838300 83037e02 f983fdc2
+83037e01 0c8dfec1 8dca0149 1c8d1b0c
+c1d98991 2c8d04e1 08548d08 04158904
+8d000173 89080854 0172f415 c1da8900
+948d10e2 00100010 fc158900 8d000172
+890c0854 0172f815 002d8900 c1000173
+848d10e3 00900018 7308a300 c0310001
+158b0289 000172f4 5d5b0289 000090c3
+0424448b 85565356 0f5974c0 c1f708b7
+00002000 c0330675 c35e5b59 8b08708b
+f23b1050 d88b2673 5652d62b e80473ff
+000031b8 850cc483 8b557ec0 f0031053
+e472f23b b70fc38b 08708b08 89107089
+70891870 ffe18134 66ffffdf c0330889
+c35e5b59 f633c033 868bd88b 00018140
+8504c683 e80e74c0 ffffff88 057dc085
+ffffffbb 50fe83ff c38be07c c35e5b59
+508bc38b 08816608 50890200 18508910
+b8345089 ffffffff c35e5b59 6c8b5556
+748b0c24 56551424 74ff016a 05e81c24
+83000012 c63b10c4 ed330274 5e5dc58b
+448d90c3 ff500824 68082474 00018080
+011b2c68 0006e800 c4830000 9090c310
+81535657 000098ec 24bc8b00 000000a8
+ac24b48b 8b000000 00b0249c 68a10000
+0f000152 526c15b7 b70f0001 01526e0d
+24848900 0000008c 24948966 00000090
+248c8966 00000092 4824448d b424b4ff
+50000000 000d43e8 08c48300 802484c7
+00000000 89000000 8958247c c75c2474
+00942484 00000000 948d0000 00009424
+24848d00 0000008c ffff6850 52537fff
+001f6be8 10c48300 ff85f88b 02c08e0f
+948b0000 00009424 25fa8300 02a0840f
+f78b0000 277eff85 74ff5356 54ff6424
+c4836424 0fc0850c 0002ad84 24948b00
+00000094 8024b401 89000000 035c2444
+25fa83df d2851974 ff858575 848b8175
+00008024 98c48100 5b000000 33c35f5e
+244489c0 24448978 24448974 24448970
+2444896c 24448968 84896664 00008824
+13be0f00 52706852 89e80001 83000013
+c08508c4 70ba3374 8d000152 f6031234
+848bdef7 01527886 84096600 00008824
+01c38300 5213be0f 01527068 1356e800
+c4830000 75c08508 03be0fd9 0f2af883
+0001a084 0c0d8b00 c7000182 00842484
+00000000 be0f0000 d0b60f03 5134b70f
+0020c6f7 39740000 b60fd233 12348dc0
+f203f603 548df603 9489d030 00008424
+43be0f00 01c38301 0ff0b60f f7713cb7
+000020c7 810a7400 fffffffa ebe27d7f
+2ef883c9 00b6840f 44c70000 ffff7c24
+be0fffff 90685003 e8000152 000012c8
+8508c483 8e840fc0 8b000000 10be0fc3
+8801c383 008a2494 fa830000 83657468
+4b746cfa 4c247c8d 4824748d 5224148d
+be0fc38b 83565108 e85701c3 0000015c
+8510c483 8d1975c0 8d4c2454 52502404
+000913e8 08c48300 8d0fc085 fffffe1f
+ffffffb8 98c481ff 5b000000 0fc35f5e
+f88303be c6ad756c 008a2484 83710000
+a0eb01c3 8303be0f 937568f8 8a2484c6
+62000000 eb01c383 e9d2338b ffffff73
+0f01c383 f88303be 8b58742a 01820c35
+2444c700 0000007c 03be0f00 0fc8b60f
+f64e14b7 840f20c2 ffffff29 048dd233
+03c00312 8dc003c2 89d00154 0f7c2454
+830143be b60f01c3 3cb70fc8 20c7f74e
+0f000000 fffefc84 fffa81ff 7d7fffff
+8bcbebde 83482454 e28303c2 04428dfc
+8901c383 8b482444 244c890a 03be0f7c
+fffed0e9 24548bff 03c28348 8dfce283
+44890442 028b4824 097cc085 84248489
+eb000000 8c836612 00008824 d8f70400
+84248489 83000000 be0f01c3 fe7fe903
+778dffff 0ff685ff fffd5b8f fd7de9ff
+be0fffff 75c08503 e9ff3307 fffffd32
+000001bf fd28e900 ffb8ffff 81ffffff
+000098c4 5f5e5b00 909090c3 ec835356
+245c8b08 4cbe0f14 418d1c24 53f883db
+03a1870f 048b0000 0152a085 0fe0ff00
+e93e43be 000002a3 1824448b 18244c8b
+c683308b fce68303 8904568d c7068b11
+00000443 03890000 0318438b 6a202444
+43895378 19f2e814 c4830000 036ee908
+be0f0000 f8833e43 cb840f62 83000003
+840f71f8 000003a0 0f6af883 00037584
+74f88300 034e840f f8830000 836e747a
+227568f8 1824548b 8b34438b 8b18245c
+03c68332 8dfce683 0b89044e 8966168b
+031ae902 f8830000 8b21756c 8b182454
+5c8b3443 328b1824 8303c683 4e8dfce6
+8b0b8904 e9028916 000002f4 1824548b
+8b34438b 8b18245c 03c68332 8dfce683
+0b89044e 0289168b 0002d3e9 24548b00
+34438b18 18245c8b c683328b fce68303
+89044e8d 89168b0b 02b2e902 be0f0000
+f8833e43 ab840f6c 83000003 840f71f8
+00000383 0f6af883 00035b84 24748b00
+24548b18 83368b18 e68303c6 04468dfc
+068b0289 73be0f99 68fe833e 0328840f
+fe830000 11840f62 83000003 840f74fe
+000002fd 0f7afe83 0002f484 89038900
+ea830453 d08c0f00 0f000002 a83c43b7
+8b137402 8b202474 428d1853 18438901
+2b3204c6 01a815eb 748b1174 538b2024
+01428d18 c6184389 8b203204 44031843
+89512024 e8531443 00001880 e908c483
+000001fc 3e43be0f 0f6cf883 00031284
+24548b00 24748b18 83028b18 e08303c0
+04488dfc 008b0e89 8d184b8b 53890151
+245c8b18 19048820 0001c3e9 43be0f00
+6cf8833e 038a840f f8830000 62840f71
+83000003 840f6af8 0000033a 1824448b
+1824748b c083008b fce08303 8904508d
+33008b16 73be0fd2 68fe833e 0305840f
+fe830000 ed840f62 83000002 840f74fe
+000002d8 0f7afe83 0002cf84 89038900
+b70f0453 c6f73c73 00000008 c20b2b74
+f9832774 83057478 1d7558f9 2024448b
+8d18738b 53890156 0604c618 18738b30
+8901568d 0c881853 18438b06 20244403
+14438951 1792e853 c4830000 010ee908
+43c60000 6cb86c3e 83000000 840f6cf8
+00000302 1824448b 18244c8b c683308b
+fce68303 8904568d 8b168b11 53893043
+0fc08514 0002d18c 006a5000 0dbee852
+c4830000 0fc0850c 0002b584 14538b00
+4389c22b 00b6e920 be0f0000 f8833e43
+e2840f4c 8b000002 8b182444 8b182474
+03c08300 8dfce083 16890850 3bdb00dd
+0843b70f 008000a9 8b137400 8b202474
+428d1853 18438901 2d3204c6 b70f30eb
+02a83c43 748b1374 538b2024 01428d18
+c6184389 eb2b3204 7401a815 24748b11
+18538b20 8901428d 04c61843 438b2032
+24440318 43895120 e9e85314 8300000e
+2ceb08c4 20244c8b 8d18538b 43890142
+0a04c618 8519eb25 b90575c9 00000025
+8d18538b 43890142 245c8b18 130c8820
+c483c033 c35e5b08 1824548b 8b34438b
+8b18245c 03c68332 8dfce683 0b89044e
+0289168b 4c8bdaeb 748b1824 438b1824
+99098b34 8303c183 598dfce1 8b1e8904
+89018909 b8eb0451 18244c8b 1824748b
+8b34438b c1839909 fce18303 8904598d
+89098b1e 04518901 548b96eb 438b1824
+245c8b34 83328b18 e68303c6 044e8dfc
+168b0b89 75e90288 8bffffff 8b202474
+428d1853 18438901 2d3204c6 fffd4ae9
+038999ff e9045389 fffffd06 99c0be0f
+53890389 fcf8e904 bf0fffff 038999c0
+e9045389 fffffcea 1824448b 448b108b
+c2831824 fce28303 8908728d 8b028b30
+9ee90452 8bfffffc 8b182444 24448b10
+03c28318 8dfce283 30890872 528b028b
+fc7fe904 748bffff 548b1824 368b1824
+8303c683 468dfce6 8b028904 62e99906
+8bfffffc 8b182444 8b18244c 03c68330
+8dfce683 11890456 44c7068b 00000424
+04890000 3043c724 ffffffff 5024048d
+0102e853 c4830000 0fc08508 fffe9f8d
+ffffb8ff c483ffff c35e5b08 0389d233
+e9045389 fffffd2a 33c0b60f 890389d2
+1be90453 0ffffffd d233c0b7 53890389
+fd0ce904 448bffff 108b1824 1824448b
+8303c283 728dfce2 8b308908 04528b02
+fffcc0e9 24448bff 8b108b18 83182444
+e28303c2 08728dfc 028b3089 e904528b
+fffffca1 1824448b 1824748b c083008b
+fce08303 8904508d 33008b16 fc83e9d2
+438bffff fd48e930 e852ffff 00000b80
+fd3ce959 448bffff 4c8b1824 308b1824
+8303c683 568dfce6 ff118904 35e85336
+83000000 c08508c4 fdd28d0f ffb8ffff
+83ffffff 5e5b08c4 24448bc3 24748b18
+83008b18 e08303c0 0c508dfc 28db1689
+fffd19e9 909090ff 53555657 8b5cec83
+8b702474 db85305e 74246c8b 01718c0f
+be0f0000 01820405 38460300 5400158b
+b70f0001 0154040d 3db70f00 00015406
+58244489 44245489 244c8966 7c896648
+b70f4a24 04a83c46 448b0d75 f8835824
+ff870f40 8d000000 44892404 40ba5424
+89000000 85582454 af8e0fdb 33000000
+247c89ff 24548d40 24448d4c 75ff5044
+69e85200 83000003 f88b0cc4 8c0fff85
+000000e2 8500558b 830b75d2 ff85ffc7
+00d08c0f df3b0000 00cf8c0f 4c8b0000
+568b5824 17048d18 2c73c83b 5424548b
+003846c7 52000000 00cae856 c4830000
+24448908 85d08b40 b48c0fd2 c7000000
+00001846 d2330000 54245403 4c244c8d
+e8525157 000009c4 010cc483 558b187e
+0fd28500 00008484 04c58300 db85df2b
+ff5f8f0f 7c8bffff ff854024 448b1c75
+56505424 00006fe8 08c48300 ff85f88b
+d2330875 89385689 548b1856 0c8d5424
+74d13b24 1de85207 59000006 c483c78b
+5e5d5b5c e850c35f 00000820 24448959
+0fc08554 fffefe85 ffffb8ff c483ffff
+5e5d5b5c ffbfc35f ebffffff 247c8bbd
+bb97eb40 7fffffff fffe85e9 247c8bff
+8b87eb40 9083ebf8 53555657 14247c8b
+8b18478b 4f8b386f 2c578b24 6f2be82b
+2bd9f71c daf7204f 0328572b 57b70fca
+f6e9033c 407504c2 3c7eed85 387ed58b
+fb83da8b 0020be20 02770000 f685f38b
+68561d7e 00015408 ff1077ff c4830c57
+1047890c 840fc085 00000185 2b347701
+7fdb85de 18478bcd 1f7ec085 2474ff50
+1077ff1c 830c57ff 47890cc4 0fc08510
+00016684 18478b00 8b344701 c0851c47
+357e377e fb83d88b 0020be20 02770000
+f685f38b 68561d7e 0001542c ff1077ff
+c4830c57 1047890c 840fc085 00000135
+2b347701 7fdb85de 20478bcd 1e7ec085
+1477ff50 ff1077ff c4830c57 1047890c
+840fc085 00000103 0120478b 478b3447
+7ec08524 8b357e37 20fb83d8 000020be
+8b027700 7ef685f3 2c68561d ff000154
+57ff1077 0cc4830c 85104789 dc840fc0
+01000000 de2b3477 cd7fdb85 8528478b
+50227ec0 0314578b ff522057 57ff1077
+0cc4830c 85104789 9c840fc0 8b000000
+47012847 2c478b34 377ec085 d88b357e
+be20fb83 00000020 f38b0277 1d7ef685
+542c6856 77ff0001 0c57ff10 890cc483
+c0851047 007f840f 77010000 85de2b34
+0fcd7fdb a83c47b7 85357404 7e317eed
+20fd832f 000020be 8b027700 7ef685f5
+08685619 ff000154 57ff1077 0cc4830c
+85104789 011074c0 ee2b3477 d17fed85
+5d5bc033 b8c35f5e ffffffff 5f5e5d5b
+ffffb8c3 5d5bffff b8c35f5e ffffffff
+5f5e5d5b ffffb8c3 5d5bffff b8c35f5e
+ffffffff 5f5e5d5b ffffb8c3 5d5bffff
+90c35f5e 0170c0a1 74c08500 0fd0ff02
+820405be 90c30001 0170c4a1 74c08500
+b8d0ff02 00017080 909090c3 0824448d
+ff50046a e80c2474 000006d0 c30cc483
+ec835356 24748b14 70c4a120 c0850001
+d0ff0274 017080bb 74db8500 74f68531
+7140a12d c0850001 d0ff0274 017100ba
+244c8b00 245c8928 2454890c 8bc68b10
+e8242454 00000016 5b14c483 d233c35e
+448bdfeb 548b0424 4c8b0824 56570c24
+ec835355 8bf18b08 8b28245c 0fed852b
+00010e84 4eb70f00 e9be0f06 840fc085
+000001f3 04244489 33243489 33ff33c9
+10fd83db 00d28d0f 448b0000 2c8b2c24
+0fed85a8 0000c384 05be0f00 00018204
+8e0fc33b 000000b4 8101c783 000ff0ff
+a58d0f00 0f000000 b70fc2b6 85004574
+95840ff6 8b000000 00e581ee c100000f
+c6f708fd 00008000 e2810f74 ffffff00
+ff25c68b 0b000000 00c6f7d0 74000010
+08c2c103 2000c6f7 3e740000 ff25c68b
+85000000 8b0474c0 8b02ebc6 247c8bc2
+c0be0f04 833b0488 c08501c3 01b90575
+f7000000 004000c6 68850f00 85000001
+332475c9 ff47e9ff c6f7ffff 00004000
+ff3b840f 348bffff 6e896624 83c38b06
+5d5b08c4 8bc35f5e edeb2434 70e405c7
+00580001 ffb80000 83ffffff 5d5b08c4
+85c35f5e c4840fc0 f7000000 ffff80c2
+8d0c75ff 10880168 7fe9f633 f7000000
+fff800c2 8b1475ff 06f9c1ca 8dc0c983
+08880168 000001be f763eb00 ff0000c2
+8b1475ff 0cf9c1ca 8de0c983 08880168
+000002be f747eb00 e00000c2 8b1475ff
+12f9c1ca 8df0c983 08880168 000003be
+8d2beb00 c2f70168 fc000000 ca8b1175
+8318f9c1 0888f8c9 000004be 8b0feb00
+1ee9c1ca 88fcc983 0005be08 f6850000
+0c8d217e 03ce0336 fac183c9 8bffc683
+83fbd3da cb833fe3 005d8880 8501c583
+2be67ff6 83c58be8 5d5b08c4 8bc35f5e
+01545015 05b70f00 00015454 561db70f
+89000154 46896616 5e896604 83c03306
+5d5b08c4 8bc35f5e 01545015 05b70f00
+00015454 562db70f 89000154 46896616
+6e896604 0f0b8b06 002501b7 8300000f
+5d5b08c4 8bc35f5e aae92434 90fffffe
+8b535657 a1102454 000170e0 1474c085
+f28bd88b 1074f685 7408733b 105b8b0b
+f475db85 c35f5e5b 5b8bfb8b 0c478b10
+0674c085 89104f8b 478b1048 74c08510
+0c4f8b06 3b0c4889 0170e03d 8b097500
+0d89104f 000170e0 ff0477ff 65e85717
+83000000 db8508c4 b8ebaa75 69e8146a
+59000002 3374c085 0424548b 08244c8b
+000c40c7 89000000 24548b10 0448890c
+8b085089 0170e015 10508900 0374d285
+a30c4289 000170e0 b8c3c033 ffffffff
+909090c3 0170e8a1 74c08500 b8d0ff02
+000170e4 909090c3 8b555657 85102454
+8a840fd2 8d000000 458bf86a 08f88300
+007b820f 07a80000 0d8b7775 000170f0
+0474c985 3573e93b 89044d89 0170f02d
+04558b00 2174d285 0300458b 75c23bc5
+ec05c718 00000170 8b000000 028b0455
+8b004501 4d89044a 5f5e5d04 04718bc3
+0d74f685 0973f53b 768bce8b 75f68504
+8d398bf3 ee3b3934 5e5d0473 f53bc35f
+718b1b74 74f68504 10448d0c 73f03bf8
+5f5e5d04 047589c3 eb046989 89c70394
+ebe98b01 9090908c 53555657 245c8b56
+247c8b18 24448b1c 24548b20 0ff78b24
+ee8bf0af 840ff685 000000e4 840fff85
+000000d6 860ff685 00000128 8b243489
+423b1042 f6830f18 0f000000 00a902b7
+0f000004 0000d185 85ff3300 c0840fff
+8b000000 83f32bf7 428b01c6 184a8b10
+ce3bc82b f18b0473 5356ff33 022ae850
+548b0000 c4833024 104a8b0c ee2bde03
+4a8bf103 10728908 ff85f12b e8521174
+ffffec9c 2824548b 8504c483 856975c0
+8b8c75ed 7c8b2434 db331c24 f70ab70f
+000800c1 85257400 522175db 2b105a8b
+69e8085a 8bffffec 83282454 c08504c4
+b70f0775 ebdb330a 0ab70f03 c1f7eb03
+00000c00 4a8b0674 184a8910 c68bf52b
+f7f7d233 5e5d5b59 5b59c35f c35f5e5d
+5b59c033 c35f5e5d 1c247c8b 348bde8b
+8b99eb24 ff40e9f5 6a55ffff 4de8530a
+8b000001 83302454 f88b0cc4 ffff1ae9
+f9e852ff 8b000001 83282454 c08504c4
+fef58d0f 348bffff 247c8b24 e9db331c
+ffffff58 51e9db33 90ffffff 8b565557
+8d102444 e5830f68 77e83bf8 59c03306
+bac35f5d 00000008 7308fd83 8bea8b02
+0050e8c5 c0850000 108be374 c1830a8b
+73cd3bf8 044a8b07 18eb0889 00157c8d
+4a8b3889 044f8904 388b0a8b 0f89cd2b
+088b2a89 1974c985 8504418b 831274c0
+0d8904c1 000170ec 8b08c283 5f5d59c2
+ebc933c3 535690ed 158bd88b 000170ec
+5e74d285 c085028b c88b1174 6c76193b
+c283128b 850a8b04 baf175c9 000170f0
+c83b0a8b 193b0d74 518d5776 3b0a8b04
+8bf375c8 01820835 d102eb00 76de3bee
+56f38b02 0001f7e8 c0855900 30890e74
+5008c083 fffd0fe8 9eeb59ff 2674f33b
+f0b8d9eb 8b000170 74d28510 761a3bc6
+04428d1a d285108b b7ebf375 5e5bc28b
+5bc28bc3 c033c35e 5bc35e5b 9090c35e
+244c8b53 24548b08 44b60f10 d2850c24
+b60f0f76 74d83b19 01c1830c 75ffc283
+5bc033f1 5bc18bc3 909090c3 8b08ec83
+8b0c2444 8b10244c 85142454 892176d2
+6c89243c e98b0424 004db60f c0830888
+01c58301 75ffc283 243c8bef 04246c8b
+0c24448b c308c483 04244c8b 2454be0f
+01be0f08 0f74c23b 0e74c085 0141be0f
+3b01c183 8bf175c2 c033c3c1 909090c3
+0424548b 8b0abe0f 74c985c2 48be0f0b
+01c08301 f575c985 90c3c22b 0170f4a1
+74c08500 a1d0ff02 0001820c 909090c3
+748b5356 4e8b0c24 184e3b10 c0330573
+0fc35e5b d08b06b7 9002e281 fa830000
+a9207402 00008000 00ba0774 eb000002
+4200ba05 c20b0000 b8068966 ffffffff
+8bc35e5b 00e281d0 81000060 006000fa
+a97a7400 00000c00 568b0c75 4c5e8d08
+1b74d33b 568b03eb 14568908 890c568b
+000d1856 66ffff60 c0330689 68c35e5b
+00000200 fffda3e8 c08559ff 83662674
+4689400e 10468908 0200908d 56890000
+3046890c e8344689 00000e76 8b06b70f
+b5eb0856 89085e89 468d105e 0c46894d
+000e5de8 06b70f00 eb08568b 0c4e3b9c
+e8568172 ffffe928 75c08559 06b70f08
+ffff6ee9 ffffb8ff 5e5bffff 909090c3
+0424448b 037fc085 50c3c033 001a2fe8
+f8835900 c3f174ff 53555657 8b6cec83
+008024bc 2fdb0000 24b4be0f 00000084
+54247cdb 14246c8d 7461fe83 41fe8323
+478b1e74 0fc08530 0006b18c 83117500
+057467fe 7547fe83 3047c707 00000001
+6824448d b5e85057 83000006 bf0f08c4
+02fa83d0 064a840f d2850000 47c73a7e
+00000320 61fe8300 fe832774 83227465
+1d7466fe 7467fe83 5768b818 036a0001
+1477ff50 fffdd3e8 78c483ff 5f5e5d5b
+576cb8c3 e6eb0001 0f61fe83 0005d284
+41fe8300 05c9840f d2850000 c0333075
+24448966 33d23368 245489c9 244c8940
+24448b3c 548b503c 55524424 71e85756
+8100000e 000080c4 5e5d5b00 fe83c35f
+38840f61 83000003 840f41fe 0000032f
+54246cdb 571c2ddb d1d80001 769ee0df
+d9c9d90e 247cdbe0 246cdb54 0fc9d954
+68244cbf 7597d969 89b80000 f714f8b5
+1ffbc1eb 2b0dfac1 fcc283d3 85dabf0f
+9f8c0fdb 0f000002 00028d8e 282ddb00
+83000157 bf0ffce3 5c8966db d38b6824
+187ed285 c2f6c033 db087401 015680a8
+d1c9de00 0cc083fa ea7fd285 c9d9fade
+54247cdb 0f66fe83 00024584 46fe8300
+023c840f 07bb0000 03000000 45c6305f
+16b83000 8d000000 8315246c 027e16fb
+db85d88b 3fe90b7f db000005 01571c2d
+246cdb00 d9d1d854 dfd8ddc9 860f9ee0
+000001e8 0f243cd9 0d2404b7 00000c00
+08244489 08246cd9 4c2454db 8b242cd9
+834c2444 db85f8c3 2ddb1a7e 00015734
+44244489 442444db c9deeade 54247cdb
+54246cdb c583d8dd 0fc08508 0001918e
+0007be00 548d0000 c4836024 2444c7f4
+00000a08 24148900 04244489 000c07e8
+08c48300 6424448b 8330c083 4588ffc5
+24448b00 7ec08560 ffc68307 c67df685
+85ffc683 830e7cf6 45c6ffc5 c6833000
+7df685ff 08c583f2 8f0fdb85 ffffff3b
+24b4be0f 00000084 8024bc8b 0f000000
+682454b7 1424448d 448dd8f7 c283ff28
+cabf0f07 15246c8d 3c244c89 244c8966
+5dbe0f68 30fb8300 d18b1d75 83ffc083
+8966ffc2 0f682454 83014dbe f98301c5
+89e97430 833c2454 840f66fe 000000c3
+0f46fe83 0000ba84 65fe8300 00a7840f
+fe830000 9e840f45 33000000 305703d2
+3bd2bf0f 8b027dc2 cabf0fd0 4c89c985
+8c0f4024 fffffdb9 c23bd18b c28b167e
+2814be0f 7c35fa83 0039b80b 44890000
+09eb1024 000030b8 24448900 8dd18b10
+043aff52 8b17752a 0f102444 ff2a5cbe
+83ffc183 d83bffc2 4c89f174 448b4024
+f8831024 800d7539 0f012a04 682444bf
+3c244489 8d0fd285 fffffd55 3c24448b
+40244483 ffc58301 8901c083 663c2444
+68244489 fffd38e9 0001baff 5ae90000
+8bffffff 0f3c2454 c283d2bf ff4be901
+08beffff e9000000 fffffea4 be0fd8dd
+008424b4 bc8b0000 00008024 febde900
+c383ffff fdc1e90b d9ddffff 245c8966
+fd9ee968 dbf7ffff 8b03c383 fce283d3
+d8f7c28b 66d8bf0f 68245c89 8e0fd285
+000002fd c2f6c033 db147401 015680a8
+d9cade00 247cdbc9 246cdb54 d1c9d954
+0cc083fa de7fd285 55e9d9dd 83fffffd
+840f61fe 0000023d 015740b8 24448900
+30478b0c 8c0fc085 0000021f db01c083
+01571c2d 246cdb00 0f2fdb54 c9d9d0bf
+e0dfdad8 9e025a8d e0d90273 54247cdb
+24448366 45c6fc68 448d0000 db851524
+02828e0f f08b0000 06ebea8b 571c2ddb
+6cdb0001 d9de5424 0f9ee0df 00009986
+244c8d00 511c6a54 001027e8 08c48300
+54246cdb 0f243cd9 0d2404b7 00000c00
+08244489 08246cd9 4c2454db 8b242cd9
+834c247c db85f9c3 7c89127e 44db4424
+e9de4424 54247cdb 54246cdb c683d8dd
+0fff8507 0001508e 0006b900 c78b0000
+830fe083 0688ffc6 8504ffc1 83077eff
+c985ffc1 c183e87d 7cc985ff ffc6830d
+830006c6 c985ffc1 c683f37d 0fdb8507
+ffff578f 00f7e9ff bc8b0000 00008024
+8bd58b00 b4be0fc6 00008424 244c8d00
+246c8d14 8dd9f715 3bff0144 8b027dc2
+d2bf0fd0 40245489 3c245489 8c0fd285
+000000a8 167ec23b be0fc28b fa832814
+b80b7c08 0000000f 10244489 c03306eb
+10244489 3c24548b 89ffc283 3a3c2454
+21752a04 448bca8b 548b1024 be0f4024
+83ff295c c183ffc2 74d83bff 244c89f1
+2454893c 24448b40 0ff88310 448b0875
+04803c24 448b0128 c0853c24 44830f7d
+8d014024 6614246c 68244483 24448b04
+d0bf0f40 3c245489 85ff428d 8b1d7cc0
+8d0c245c 8d01054c be0f0155 b60fff41
+41881804 ffc183ff ee76d13b 8530478b
+0f307cc0 682444bf 3c244489 fffaa0e9
+24bc8bff 00000080 c68bd58b 24b4be0f
+00000084 ffff04e9 0007b9ff c3e90000
+8bfffffe 833c2444 4789ffc0 54bf0f30
+54896824 66e93c24 b8fffffa 00000021
+fffddae9 5754b8ff 44890001 bee90c24
+8bfffffd 418d144f 14478901 c661fe83
+19743001 000058b8 145f8b00 89014b8d
+0388144f 02184783 fffa0de9 0078b8ff
+e5eb0000 032047c7 83000000 277461fe
+7465fe83 66fe8322 fe831d74 b8187467
+00015770 ff50036a 8de81477 83fffff7
+5d5b78c4 b8c35f5e 00015774 47c7e6eb
+00000630 f956e900 d8ddffff fffb8ee9
+e9d9ddff fffffa7c 3ee9d8dd 90fffffe
+7c8b5657 b70f1024 e6810877 00007fff
+7ffffe81 67740000 0647b70f 1775c085
+0447b70f 0f75c085 0247b70f 0775c085
+8507b70f 853a74c0 be0575f6 00000001
+0c62e857 0f590000 810857b7 ff8000e2
+feca81ff 66ffff3f 8d085789 c002308c
+448bffff 89660c24 ffffb808 5f5effff
+244c8bc3 66d2330c c0331189 8bc35f5e
+330c2454 028966c0 064fb70f 7fffc1f7
+17750000 0447b70f 0f75c085 0247b70f
+0775c085 8507b70f b80874c0 00000002
+b8c35f5e 00000001 90c35f5e 53555657
+8b24ec83 0f38246c 3c2444be 0f58f883
+0001f484 5780ba00 54890001 f8832024
+d4840f6f 83000001 840f78f8 000001bd
+0f58f883 0001b484 000aba00 54890000
+758b1c24 047d8b00 0f64f883 00017d84
+69f88300 0174840f c68b0000 0e75c70b
+8530458b bb0775c0 00000018 c03323eb
+244c8b50 56575120 0016f3e8 10c48300
+2024548b 100cb60f 000017bb 244c8800
+50c03317 2024548b e8565752 000015d0
+8b10c483 89ca8bf0 4d890075 83f98b04
+677c00ef 6374fe0b c033ff33 448bd08b
+d02b1c24 18245489 8b55ed33 5720247c
+49e85651 83000015 7c8b10c4 e88b3824
+1824448b e5f7ca8b 748bc603 b60f2024
+44883004 c383ff1c 89f58bff 044f892f
+ef83f98b ba8c0f00 0b000000 04840fef
+85000001 8bb17fdb 8b38246c 831c2444
+697408f8 8d24048d dbf71804 5318c383
+50205d89 e81475ff fffff560 8b0cc483
+558b3045 7dd03b20 65836612 c22bef3c
+831c4589 5d5b24c4 85c35f5e 83087cc0
+5d5b24c4 0fc35f5e 833c45b7 f88314e0
+8bec7510 c22b3845 2b18452b c0851c45
+4589dd7e 24c4831c 5f5e5d5b 45b70fc3
+7408a83c 18fb8325 048d0e73 18048d24
+8310be0f 827430fa 8324048d 04c6ffc3
+048d301c ff70e918 048dffff 18048d24
+ffff65e9 246c8bff ff4de938 c78bffff
+0f00e883 fffe818d 33c68bff 8bf02bf6
+0000bfd7 fa1b0000 fffe6de9 0010baff
+54890000 47e91c24 bafffffe 00000008
+1c245489 fffe39e9 5794baff 54890001
+07e92024 8bfffffe e938246c fffffefb
+a114ec83 000170c4 0274c085 448bd0ff
+548b2424 4c8b1c24 44892024 448b0c24
+44c71824 70801024 11e80001 83000000
+90c314c4 0424448b 0824548b 0c244c8b
+53555657 8b0cec83 246c8bd9 247c8b2c
+4db70f30 006d8b06 be0f3f8b 85f28bc9
+11840fff 85000001 8c840fd2 85000002
+bd840fdb 89000002 89042444 5c892414
+ff330824 0f10f983 0000d48d 24548b00
+8a148b30 840fd285 000000c5 8101c783
+000ff0ff b68d0f00 0f000000 b70f06b6
+d2854214 00a7840f ca8b0000 0f00e181
+f9c10000 00c2f708 74000080 00e5810b
+0fffffff eb0bdab6 1000c2f7 03740000
+f708c5c1 004000c2 85617400 8b4c74c0
+8b042444 8b08245c 24148bfa 8301c683
+c7f7ffc3 00002000 ff61840f f22bffff
+0274c085 448b2889 28892c24 06488966
+0475ed85 09ebf633 0575f685 fffffdbe
+83c68bff 5d5b0cc4 f7c35f5e 002000c2
+3d840f00 e9ffffff 00000216 2000c2f7
+840f0000 ffffff2c 0424448b eb24148b
+e405c7ad 58000170 b8000000 ffffffff
+5b0cc483 c35f5e5d 840fd285 0000014f
+8b241489 8306ebf9 c38301c6 0fdb85ff
+00012384 7eff8500 3eb60f53 e281d78b
+000000c0 0080fa81 850f0000 000000f1
+8306e5c1 ef0b3fe7 0fffc183 ff85f9be
+148bc575 74c08524 8b288902 332c245c
+4b8966c9 75ed8506 ebf63304 01c68305
+c68bf22b 5b0cc483 c35f5e5d f72eb60f
+000080c5 8bc77400 e0e281d5 81000000
+0000c0fa 84840f00 8b000000 f0e281d5
+81000000 0000e0fa 8b627400 f8e281d5
+81000000 0000f0fa 8b407400 fce281d5
+81000000 0000f8fa 811e7400 0000fcfa
+04850f00 83000001 05b903e5 bf000000
+00000005 ffff65e9 03e583ff 000004b9
+0004bf00 53e90000 83ffffff 03b907e5
+bf000000 00000003 ffff41e9 0fe583ff
+000002b9 0002bf00 2fe90000 83ffffff
+01b91fe5 bf000000 00000001 ffff1de9
+e405c7ff 58000170 b8000000 ffffffff
+5b0cc483 c35f5e5d 2c24548b 89662a89
+feb8067a 83ffffff 5d5b0cc4 8bc35f5e
+0157a815 245c8b00 0db70f2c 000157ac
+ae05b70f 89000157 4b896613 43896604
+83c03306 5d5b0cc4 8bc35f5e 0157a815
+245c8b00 0db70f2c 000157ac ae05b70f
+8b000157 8930246c 4b896613 43896604
+00758b06 2506b70f 00000f00 5b0cc483
+c35f5e5d 2c24548b 89662a89 feb8064a
+83ffffff 5d5b0cc4 c7c35f5e 0170e405
+00005800 ffffb800 c483ffff 5e5d5b0c
+448bc35f 148b0424 fda0e924 9090ffff
+017140a1 74c08500 b8d0ff02 00017100
+909090c3 c0335653 838bd88b 00018140
+8504c383 e80574c0 0000000c 7250fb83
+c35b59e9 0424448b 8b555657 0fb70ff8
+7503c1f6 0001bd09 f6330000 578b15eb
+7cd28504 45e857f0 59ffffdb b70ff08b
+f6ed330f 097440c1 e80877ff ffffed48
+0847c759 00000000 0d75ed85 e80477ff
+00000bc4 74c08559 ffffbe05 578bffff
+74d28540 85e85220 59000000 0574c085
+ffffffbe 4077ffff ffed0be8 47c759ff
+00000040 d1e85700 8b000000 5e5d59c6
+be0fc35f 01716005 75c08500 0008e80c
+05c60000 00017160 f468c302 e800013e
+00000928 9090c359 8b08ec83 8b14244c
+99102444 548bf9f7 04890c24 0fd8f724
+4403c1af 44891024 048b0424 8b028924
+89042444 c28b0442 c208c483 90900004
+245c8b53 7de85308 5900000b 0475c085
+c35bc033 0c2ae853 5b590000 909090c3
+8bdb3353 81409d04 c0850001 b70f1d74
+74d28510 01c3830c 7214fb83 5bc033e6
+ff7fbac3 89660000 6ac35b10 ee5ae850
+8559ffff 89e874c0 81409d04 80ba0001
+66000000 58881089 90c35b02 0424448b
+f710b70f 000080c2 c72e7500 ffff0440
+d233ffff 8d108966 48894c48 10488908
+89144889 48893048 34488918 894c508d
+508d1c50 2050892c 3bd233c3 81409504
+10740001 8301c283 ef7214fa ebd6e850
+c359ffff 409504c7 00000181 eb000000
+909090eb 53555657 8b28ec83 0f3c245c
+402444be 4424548b 2474bf0f 6cbf0f48
+0d8b4c24 000182cc 0c244489 8901be0f
+85102454 244489f6 b80e7f08 000157b0
+10244489 000001be 24448b00 66f8830c
+0253840f f8830000 4a840f46 83000002
+840f67f8 0000022f 0f47f883 00022684
+67f88300 01d4840f f8830000 cb840f47
+83000001 840f61f8 000001b4 7541f883
+0050b809 44890000 7b8b0c24 242c8914
+10246c8b 0055b60f 8901c583 8b042454
+20538bc2 89014a8d 6c89204b 2c8b1024
+17048824 8530438b 638e0fc0 8b000001
+8b082444 2c89144b 206b8b24 8901558d
+04882053 242c8b29 8530538b 378e0fd2
+83000001 bf0fffc6 7dd03bc6 f2bf0f03
+03144b8b bf0f204b 244489c6 548b5008
+51521424 ffee03e8 0cc483ff 0824548b
+8b20438b c203304b 2b204389 244b89ca
+0c24548b 8d144b8b 16880834 01087c8d
+8c0fed85 000000d1 2b0146c6 8501c783
+bb8e0fed 33000000 24448df6 f4c48320
+082444c7 0000000a 89240489 e804246c
+00000884 8b08c483 0f242444 20246cbf
+14344488 8501c683 8bce7fed 833c245c
+227d02fe 0c24448b 7465f883 45f88305
+c78b0875 833000c6 f68501c7 c78b0875
+833000c6 f68501c7 c683147e 44b60fff
+c0831434 83078830 f68501c7 438bec7f
+20430314 3c4bb70f 7b89f82b 14e18328
+7410f983 28c48308 5f5e5d5b 18538bc3
+03205303 438b2453 2c430328 438bd003
+7dd03b38 89c22be0 c4831c43 5e5d5b28
+f633c35f ffff76e9 0146c6ff 01c7832d
+bf0fddf7 ff25e9ed 438bffff fefee920
+b70fffff 08a83c43 fe91850f eaebffff
+000070b8 24448900 fe4ce90c 538bffff
+7ed63b30 43b70f0a 7508a83c 83d68b02
+d285ffc2 5389287c 24448b30 67f8830c
+45b80e74 89000000 e90c2444 fffffe1a
+000065b8 24448900 fe0ce90c 43c7ffff
+00000030 83d2eb00 8c0ffcfd fffffdd1
+0f306b3b fffdc88d 01c583ff 0f66f883
+0001a984 46f88300 0198840f b70f0000
+08a83c43 438b0b75 7ec63b30 ebc68b07
+30438b03 2bedbf0f 0fc085c5 0001698c
+30438900 8e0fed85 000000da 4a7df53b
+24448b56 538b5014 20530314 ec1ae852
+c483ffff 20438b0c 0330538b 204389c6
+6b89ee2b 0fd28524 00008a8e 24548b00
+144b8b08 8b011488 b70f3053 43833c4b
+53890128 fea3e92c 8b55ffff 50142444
+0314538b e8522053 ffffebd0 8b0cc483
+438b204b 2bcd0330 d6bf0ff5 557ec085
+0824448b 8d147b8b 73890171 0f048820
+8b204b8b 4b033043 7cc23b14 0fc28b02
+448bf0bf 03561024 e85150c5 ffffeb8c
+8b0cc483 b70f3043 73013c4b 89c62b20
+36e92443 0ffffffe f63c4bb7 827408c1
+ffff68e9 73b70fff 204b893c 0008c6f7
+b2740000 4b8b9aeb 14538b20 8901418d
+04c62043 538b300a 7ed28530 24448b63
+207b8b08 8d144b8b 53890157 39048820
+8b30538b 3bd8f7c5 8b0b7dd0 0fd8f7c2
+c58be8bf 4389d8f7 89d50324 d63b3053
+d68b027c 8beabf0f 53031453 448b5520
+52501424 e8286b89 ffffeaf0 8b0cc483
+b70f3043 c52b3c4b e92c4389 fffffd9d
+3c43b70f ab7408a8 43c793eb 00000030
+fe8ee900 bf0fffff fe86e9ed bf0fffff
+fe7ee9ed 9090ffff 53555657 1424748b
+084eb70f 8966c033 b70f0846 ff330646
+003dd233 7d000001 6eb70f2c 46896602
+0ff88b08 660446b7 66064689 0f046e89
+89662eb7 ed33026e 832e8966 bf0ff0c2
+74ff85d2 75ff85cd 46b70f5a 80003d06
+4f730000 0f3eb70f 0f045eb7 03026eb7
+0ffbc1c0 b70fc30b b70f045e 468966c0
+c1db0306 dd0b0ffd 026eb70f 045e8966
+df8bed03 0b0ffbc1 6e8966eb 0fff0302
+8966ffb7 ffc2833e 0080003d 0fb87200
+85087eb7 0f6174ff b70f3eb7 04eb0246
+085e8966 026eb70f 045eb70f e0c1ffd1
+0ff80b0f 8966ffb7 c1fdd13e eb0b0fe3
+065eb70f 0fc5b70f 66046eb7 d1024689
+0fe3c1fd b70feb0b 8966085e b70f046e
+fdd1066e 0b0fe3c1 5eb70feb 6e896608
+01c28306 a875ebd1 084e8966 5d5bc28b
+90c35f5e 53555657 14245c8b 086bb70f
+7fffe581 748b0000 fd811824 00007fff
+0221840f ed850000 b70f2675 c0850643
+b70f1e75 c0850443 b70f1675 c0850243
+b70f0e75 75c08503 5bc03307 c35f5e5d
+0575ed85 000001bd 89e85300 59fffffe
+bf0fc503 7ef685d0 f7c28b2c 7fff05d8
+f03b0000 2ddb1f7c 00018230 0843b70f
+008000a9 d9027400 b83bdbe0 00000001
+5f5e5d5b f7c28bc3 0ff03bd8 0001dc8f
+63816600 8d800008 83ff1644 8e0fbff8
+0000015c 8d0fc085 00000154 83e8bf0f
+8f0ff0fd 00000178 0f0bb70f 330253b7
+74c085c0 0001b807 02eb0000 b70fc033
+c80b0673 8bc1b70f 138966ca 0453b70f
+02538966 04738966 8966ff33 c583067b
+edbf0f10 7ef0fd83 0fddf7c8 f685f5bf
+c0856574 01b80774 eb000000 0fc03302
+d68b2bb7 c283daf7 8bca8b10 8be7d3fd
+0bfdd3ce c7b70ff8 027bb70f e7d3ca8b
+ef0bce8b 027bb70f 8966ffd3 6bb70f2b
+d3ca8b04 0bce8be5 6bb70ffd 7b896606
+7bb70f02 8bffd304 8be5d3ca 6bd366ce
+66fd0b06 3d047b89 00008000 b70f5d7e
+01c08303 0f038966 c085c0b7 b70f4775
+c0830243 43896601 d0b70f02 2f75d285
+0443b70f 6601c083 0f044389 d285d0b7
+b70f1775 c2830653 53896601 c2b70f06
+0080003d eb617400 53b70f18 0f12eb06
+eb0653b7 53b70f0c 7406eb06 53b70f52
+c2b70f06 1e75c085 0443b70f 1675c085
+0243b70f 0e75c085 8503b70f 330775c0
+5e5d5bc0 ffb8c35f 5bffffff c35f5e5d
+8966d233 89660653 89660453 89660253
+5bc03313 c35f5e5d 08438366 0fd7eb01
+01a803b7 ff47850f b70fffff a1eb0653
+c2e9c033 0ffffffe a90643b7 00007fff
+b70f2175 c0850443 b70f1975 c0850243
+b70f1175 75c08503 0001b80a 5d5b0000
+b8c35f5e 00000002 5f5e5d5b 4bb70fc3
+00e18108 03ffff80 66ca0bd6 b8084b89
+ffffffff 5f5e5d5b 909090c3 018284a1
+c0053b00 77000172 0026e80e c0850000
+84a11d74 8b000182 8d04244c 1589ff50
+00018284 8280158b 4c890001 e8c3fc82
+00000190 a1535657 0001827c eed1f08b
+c003c603 e850c003 ffffe570 85d88b59
+8b7a74db 0172c015 03d20300 35ff52d2
+00018280 e692e853 158bffff 00018284
+82800d8b 048d0001 8dc00312 ff03363c
+fb03f803 7ca1c803 2b000182 03c003c2
+575150c0 ffe663e8 18c483ff 82800d8b
+80ba0001 3b000171 510774ca ffe2f7e8
+350159ff 00018284 82801d89 35010001
+0001827c 000001b8 5f5e5b00 5bc033c3
+90c35f5e 012bd0b8 74c08500 e8006a08
+ffffe1fc 8284a159 053b0001 0001827c
+0d8b1f73 00018280 8901508d 01828415
+8114ff00 018284a1 7c053b00 72000182
+72c0a1e1 c0850001 0d8b1c76 00018280
+89ff508d 0172c015 8154ff00 72c0a1fc
+c0850001 158be477 00018280 017180b8
+74d03b00 5de85207 59ffffe2 042474ff
+828005c7 71800001 05c70001 0001827c
+00000050 0000c3e8 3cb85900 8500012c
+a13b75c0 00018284 72c0053b 14770001
+fffeafe8 75c085ff ffffb806 a1c3ffff
+00018284 04244c8b 89ff508d 01828415
+80158b00 89000182 33fc824c 35ffc3c0
+0001801c 448b006a e8500c24 ffffe18c
+c30cc483 4de8066a 6a000000 ff02e801
+c483ffff 90909008 8b08ec83 8b14244c
+99102444 548bf9f7 04890c24 0fd8f724
+4403c1af 44891024 048b0424 8b028924
+89042444 c28b0442 c208c483 90900004
+0182a0b8 9090c300 00002be8 2474ff00
+49e85004 83000000 90c308c4 70e405c7
+00590001 90c30000 70e405c7 00590001
+ffb80000 c3ffffff 00001bb8 0ff8ba00
+b8ef0000 ffff0005 000ffcba 05c7ef00
+000170e4 00000059 ffffffb8 0000c3ff
+00001bb8 0ff8ba00 b8ef0000 ffff0006
+000ffcba 05c7ef00 000170e4 00000059
+ffffffb8 0000c3ff 00001bb8 0ff8ba00
+b8ef0000 ffff000b 000ffcba 05c7ef00
+000170e4 00000059 ffffffb8 0000c3ff
+0424548b 70e405c7 00590001 e4a10000
+85000172 854874c0 c30175d2 b902148d
+00419000 667fd13b 019000b9 7cca3b00
+85d18b02 8b1574c0 7dc23bc8 0001c608
+7cca3b41 e41589f8 c3000172 019000b9
+7dca3b00 0001c6f0 7cca3b41 b8e6ebf8
+00419000 267cc085 019000b8 7dc08500
+0000b805 00b90000 3b000190 c6087dc8
+3b410001 a3f87cc8 000172e4 ffb889eb
+c3ffffff 00001bb8 0ff8ba00 b8ef0000
+ffff000f 000ffcba 05c7ef00 000170e4
+00000059 ffffffb8 0000c3ff 8b14ec83
+8b18244c 8b1c2444 c7202454 0170e405
+00005900 02f98300 f9830574 855c7501
+317a74d2 241c89c9 0c247489 08247c89
+04246c89 cd89c389 00000fbe 3bb60f00
+54895743 67e81424 8bffffcb 83142454
+4a4504c4 f685c031 4ec0950f 3774c085
+d975d285 1c8be989 24748b24 247c8b0c
+246c8b08 83c88904 b8c314c4 0000001b
+000ff8ba c889ef00 000ffcba ffb8ef00
+83ffffff 85c314c4 eb9d75d2 ebc931c7
+000090d4 448b5657 7c8b1024 4c8b0c24
+f78b1424 8b66e08a 10e0c1d0 8bc20b66
+02e9c1d1 f303e283 f3ca8bab 5ec68baa
+5657c35f 1024448b 0c247c8b 14244c8b
+e08af78b c1d08b66 0b6610e0 c1d18bc2
+e28302e9 8babf303 8baaf3ca c35f5ec6
+7c8b5657 4c8b0c24 f78b1424 d18bc033
+8302e9c1 abf303e2 aaf3ca8b 5f5ec68b
+565790c3 1024748b 0c247c8b 14244c8b
+d18bc78b 8302e9c1 a5f303e2 a4f3ca8b
+90c35f5e 748b5657 7c8b1024 4c8b0c24
+c78b1424 e9c1d18b 03e28302 ca8ba5f3
+5f5ea4f3 565790c3 448b5355 5c8b1424
+7c8b1824 d78b1c24 8b02eac1 03e183cf
+3a74ff85 1474d285 348bff33 bb343bb8
+753f2c8d 01c7834a ee72fa3b d203d203
+0310048d 74c985d3 0fdb3315 0f032cb6
+831a3cb6 ef3b01c3 d93b0b75 c033ed72
+5f5e5d5b 3bc58bc3 b80a7ec7 00000001
+5f5e5d5b ffffb8c3 5d5bffff 8bc35f5e
+14b60ffd 0cb60f78 74d13b7b b80a7e16
+00000001 5f5e5d5b ffffb8c3 5d5bffff
+0fc35f5e 017854b6 7b4cb60f 74d13b01
+44b60f22 b60f0178 3b017b54 b80a7ec2
+00000001 5f5e5d5b ffffb8c3 5d5bffff
+0fc35f5e 027854b6 7b4cb60f 74d13b02
+b80a7e16 00000001 5f5e5d5b ffffb8c3
+5d5bffff 0fc35f5e 037844b6 7b54b60f
+7ec23b03 0001b80a 5d5b0000 b8c35f5e
+ffffffff 5f5e5d5b 565790c3 0c247c8b
+14244c8b c033f78b e9c1d18b 03e28302
+ca8babf3 c68baaf3 90c35f5e 448b5657
+7c8b1024 4c8b0c24 f78b1424 8b66e08a
+10e0c1d0 8bc20b66 02e9c1d1 f303e283
+f3ca8bab 5ec68baa 5657c35f 1024748b
+0c247c8b 14244c8b d18bc78b 8302e9c1
+a5f303e2 a4f3ca8b 90c35f5e 90c390c3
+90c390c3 909090c3 00000000 00000000
+448bc931 c0090824 01b9187d 8b000000
+f7042454 83daf7d8 548900d8 44890424
+448b0824 c0091024 e983287d 24548b01
+f7d8f70c 00d883da 0c245489 10244489
+b48d10eb 00000026 27bc8d00 00000000
+448bc931 d2311024 75c08551 24448b16
+2474f70c 8bc18910 f7082444 89102474
+8b71ebca 390c244c 751b72c8 244c8b13
+24448b10 77c13908 0001b807 54eb0000
+3104c483 00a9c3c0 75800000 c8bd0fec
+8b01c183 53102454 89c2ad0f 24448bd3
+24548b0c d0ad0f10 f3f7ead3 64f7c389
+c1891824 1424448b ca01e3f7 54390e72
+08721024 44390977 03730c24 3101eb83
+5bd889d2 75c98559 b68dc307 00000000
+d8f7daf7 c300da83 26b48d90 00000000
+c708ec83 00002404 448b0000 c0091024
+04ff167d 24548b24 f7d8f70c 00d883da
+10244489 0c245489 1824448b 2a7dc009
+1424548b daf7d8f7 8900d883 89182444
+eb142454 26748d15 27bc8d00 00000000
+c708ec83 00002404 448b0000 c0851824
+448b2075 00ba1024 f7000000 89142474
+24448bc1 2474f70c 31d08914 0087e9d2
+4c8b0000 c8391024 1c752872 14244c8b
+0c244c3b 448b1277 548b0c24 442b1024
+541b1424 61eb1824 0c24448b 1024548b
+00a957eb 75800000 c8bd0fdd 5301c183
+1824548b 89c2ad0f 24448bd3 24548b10
+d0ad0f14 f3f7ead3 64f7c389 c1891c24
+1824448b ca01e3f7 54394172 3b721424
+44390677 33721024 448bc389 d8291024
+548bd389 da191424 2444895b 24048b04
+0875c085 0424448b c308c483 0424448b
+d8f7daf7 8300da83 4bc308c4 aaebd889
+8be58955 c2890845 89fcc283 408b0855
+fff883fc 25eb1575 8908458b fcc283c2
+8b085589 f883fc40 8b1274ff 008b0845
+e474c085 8b08458b ebd0ff00 90c3c9db
+56e58955 e8fc5d89 00000000 14c3815b
+5700002e 0000838d 008b0000 e8240489
+ffffff9c fc5d8b59 f689c3c9 00000000
+00000000 00000000 00000000 00000000
+00010ccf 00010be1 00010bd0 00010bbf
+00010bae 00010b9d 00010e3d 00010e31
+00010e25 00010e19 00010e48 00010e48
+00010e48 00010e48 00010e0d 00010e01
+00010df5 00010de9 00000000 00000000
+232d2b20 00000030 00000001 00000002
+00000004 00000008 00000010 00000000
+746c6a68 00004c7a 00000000 00000000
+000122a4 000122b7 000122b7 000122b7
+000122b7 000122b7 000122b7 000122b7
+000122b7 000122b7 000122b7 000122b7
+000122b7 000122b7 000122b7 000122b7
+000122b7 000122b7 000122b7 000122b7
+000122b7 000122b7 000122b7 000122b7
+000122b7 000122b7 000122b7 000122b7
+0001221a 000122b7 000122b7 000122b7
+0001221a 0001221a 0001221a 000122b7
+000122b7 000122b7 000122b7 000122b7
+000122b7 000122b7 000122b7 000122b7
+000122b7 000122b7 000121c2 000122b7
+000122b7 000122b7 000122b7 0001210d
+000122b7 000122b7 000122b7 000122b7
+000122b7 000122b7 000122b7 000122b7
+0001221a 000122b7 000120d4 0001201e
+0001221a 0001221a 0001221a 000122b7
+0001201e 000122b7 000122b7 000122b7
+000122b7 00011f62 0001210d 00011f28
+000122b7 000122b7 00011f1f 000122b7
+0001210d 000122b7 000122b7 0001210d
+00000000 00000000 00000000 00000000
+00000000 00000000 20202020 20202020
+20202020 20202020 20202020 20202020
+20202020 20202020 00000000 30303030
+30303030 30303030 30303030 30303030
+30303030 30303030 30303030 00000000
+00000000 00000000 00000000 00000000
+00000000 00800080 00800080 00800080
+00800080 00c004c0 00c000c0 008000c0
+00800080 00800080 00800080 00800080
+00800080 00800080 00800080 00800080
+00040080 00080008 00080008 00080008
+00080008 00080008 00080008 00080008
+00210008 00210021 00210021 00210021
+00210021 00080021 00080008 00080008
+00080008 00030003 00030003 00030003
+00020002 00020002 00020002 00020002
+00020002 00020002 00020002 00020002
+00020002 00020002 00080008 00080008
+00080008 00110011 00110011 00110011
+00100010 00100010 00100010 00100010
+00100010 00100010 00100010 00100010
+00100010 00100010 00080008 00080008
+00000080 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 a0000000 00004002 00000000
+c8000000 00004005 00000000 9c400000
+0000400c 00000000 bebc2000 00004019
+04000000 8e1bc9bf 00004034 2b70b59e
+9dc5ada8 00004069 ffcfa6d5 c2781f49
+000040d3 80e98ce0 93ba47c9 000041a8
+9df9de8e aa7eebfb 00004351 a60e91c7
+e319a0ae 000046a3 81750c17 c9767586
+00004d48 c53d5de5 9e8b3b5d 00005a92
+8a20979b c4605202 00007525 00000000
+00000000 00000000 00000000 80000000
+00003fff 00000000 bebc2000 00004019
+33323130 37363534 42413938 46454443
+00000000 33323130 37363534 62613938
+66656463 00000000 00464e49 00666e69
+004e414e 006e616e 00000000 00000000
+33323130 37363534 62613938 66656463
+00000000 33323130 37363534 42413938
+46454443 00000000 00000000 00000000
+00000030 00000000 0000002e 736c6166
+00000065 65757274 00000000 58383025
+00000020 0000000a 43495041 54564c5f
+20203345 30203a20 38302578 00000a58
+43495041 54564c5f 20203245 30203a20
+38302578 00000a58 43495041 54564c5f
+20203145 30203a20 38302578 00000a58
+43495041 54564c5f 52434d50 30203a20
+38302578 00000a58 43495041 54564c5f
+20525354 30203a20 38302578 00000a58
+43495041 54564c5f 20203045 30203a20
+38302578 00000a58 2d656e6f 746f6873
+00000000 69726570 6369646f 00000000
+20746f6e 6b73616d 00006465 6b73616d
+00006465 65676465 00000000 6576656c
+0000006c 00000030 00000031 656c6469
+00000000 646e6573 6e657020 676e6964
+00000000 00000a0a 706d7544 20676e69
+43495041 67657220 65747369 000a7372
+2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d
+2d2d2d2d 0a0a2d2d 00000000 43495041
+49414c5f 20202052 30203a20 38302578
+00000a58 43495041 52564c5f 20202020
+30203a20 38302578 00000a58 43495041
+5250545f 20202020 30203a20 38302578
+00000a58 43495041 5250415f 20202020
+30203a20 38302578 00000a58 43495041
+5250505f 20202020 30203a20 38302578
+00000a58 43495041 52444c5f 20202020
+30203a20 38302578 00000a58 43495041
+5246445f 20202020 30203a20 38302578
+00000a58 43495041 4950535f 20202056
+30203a20 38302578 00000a58 61736964
+64656c62 00000000 62616e65 0064656c
+43495041 5253495f 20202020 30203a20
+00000078 43495041 524d545f 20202020
+30203a20 00000078 43495041 5252495f
+20202020 30203a20 00000078 43495041
+5253455f 20202020 30203a20 38302578
+00000a58 736c6166 00000065 65757274
+00000000 43495041 494d545f 73285443
+30203a29 38302578 30252058 000a5838
+612d6564 72657373 00000074 65737361
+00007472 646e6573 6e657020 00676964
+73796870 6c616369 00000000 69676f6c
+006c6163 43495041 494d545f 20205443
+30203a20 38302578 00000a58 43495041
+5243435f 20202020 30203a20 38302578
+00000a58 43495041 4344545f 20202052
+30203a20 38302578 00000a58 00000a31
+0a383231 00000000 000a3436 000a3233
+000a3631 00000a38 00000a34 00000a32
+00000000 00000000 00000000 00000000
+20202020 20202020 20202020 20202020
+20202020 20202020 30202020 20582578
+62726128 61727469 6e6f6974 69727020
+7469726f 75732079 6c632d62 0a737361
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+20202020 20202020 20202020 20202020
+20202020 20202020 30202020 20582578
+616c6628 31282074 62313131 726f2029
+756c6320 72657473 646f6d20 28206c65
+30303030 0a292962 00000000 20202020
+20202020 20202020 20202020 20202020
+20202020 25202020 74282073 72656d69
+646f6d20 000a2965 20202020 20202020
+20202020 20202020 20202020 20202020
+25202020 6d282073 296b7361 0000000a
+20202020 20202020 20202020 20202020
+20202020 20202020 25202020 74282073
+67676972 6d207265 2965646f 0000000a
+20202020 20202020 20202020 20202020
+20202020 20202020 25202020 72282073
+746f6d65 52492065 000a2952 20202020
+20202020 20202020 20202020 20202020
+20202020 25202020 69282073 202e746e
+75706e69 69702074 6f70206e 0a292e6c
+00000000 20202020 20202020 20202020
+20202020 20202020 20202020 25202020
+64282073 76696c65 20797265 74617473
+0a297375 00000000 20202020 20202020
+20202020 20202020 20202020 20202020
+25202020 64282064 76696c65 20797265
+65646f6d 00000a29 20202020 20202020
+20202020 20202020 20202020 20202020
+30202020 32302578 76282058 6f746365
+000a2972 20202020 20202020 20202020
+20202020 20202020 20202020 30202020
+32302578 6c282058 6c61636f 49504120
+44492043 00000a29 20202020 20202020
+20202020 20202020 20202020 20202020
+25202020 23282064 20666f20 2054564c
+72746e65 20736569 756e696d 29312073
+0000000a 20202020 20202020 20202020
+20202020 20202020 20202020 30202020
+20582578 72657628 6e6f6973 00000a29
+20202020 20202020 20202020 20202020
+20202020 20202020 30202020 20582578
+73617428 7270206b 69726f69 0a297974
+00000000 20202020 20202020 20202020
+20202020 20202020 20202020 30202020
+20582578 73617428 7270206b 69726f69
+73207974 632d6275 7373616c 0000000a
+20202020 20202020 20202020 20202020
+20202020 20202020 30202020 20582578
+62726128 61727469 6e6f6974 69727020
+7469726f 000a2979 20202020 20202020
+20202020 20202020 20202020 20202020
+30202020 20582578 6f727028 73736563
+7020726f 726f6972 29797469 0000000a
+20202020 20202020 20202020 20202020
+20202020 20202020 30202020 20582578
+6f727028 73736563 7020726f 726f6972
+20797469 2d627573 73616c63 00000a73
+43495041 494f455f 20202020 20203a20
+20202020 20202020 3c202020 6854202d
+72207369 73696765 20726574 77207369
+65746972 6c6e6f20 000a2179 20202020
+20202020 20202020 20202020 20202020
+20202020 30202020 32302578 6c282058
+6369676f 41206c61 20434950 0a294449
+00000000 20202020 20202020 20202020
+20202020 20202020 20202020 25202020
+66282073 7375636f 6f727020 73736563
+6320726f 6b636568 29676e69 0000000a
+20202020 20202020 20202020 20202020
+20202020 20202020 25202020 41282073
+20434950 74666f73 65726177 00000a29
+20202020 20202020 20202020 20202020
+20202020 20202020 30202020 32302578
+73282058 69727570 2073756f 74636576
+0a29726f 00000000 20202020 20202020
+20202020 20202020 20202020 20202020
+25202020 69282073 67656c6c 72206c61
+73696765 20726574 72646461 29737365
+0000000a 20202020 20202020 20202020
+20202020 20202020 20202020 25202020
+72282073 69656365 20646576 656c6c69
+206c6167 74636576 0a29726f 00000000
+20202020 20202020 20202020 20202020
+20202020 20202020 25202020 73282073
+20646e65 656c6c69 206c6167 74636576
+0a29726f 00000000 20202020 20202020
+20202020 20202020 20202020 20202020
+25202020 72282073 69656365 61206576
+70656363 72652074 29726f72 0000000a
+20202020 20202020 20202020 20202020
+20202020 20202020 25202020 73282073
+20646e65 65636361 65207470 726f7272
+00000a29 20202020 20202020 20202020
+20202020 20202020 20202020 25202020
+72282073 69656365 63206576 6b636568
+206d7573 6f727265 000a2972 20202020
+20202020 20202020 20202020 20202020
+20202020 25202020 73282073 20646e65
+63656863 6d75736b 72726520 0a29726f
+00000000 20202020 20202020 20202020
+20202020 20202020 20202020 30202020
+32302578 64282058 69747365 6974616e
+0a296e6f 00000000 20202020 20202020
+20202020 20202020 20202020 20202020
+25202020 64282064 69747365 6974616e
+73206e6f 74726f68 646e6168 00000a29
+20202020 20202020 20202020 20202020
+20202020 20202020 25202020 6c282073
+6c657665 00000a29 20202020 20202020
+20202020 20202020 20202020 20202020
+25202020 64282073 69747365 6974616e
+6d206e6f 2965646f 0000000a 20202020
+20202020 20202020 20202020 20202020
+20202020 25202020 25642564 64203a64
+64697669 79622065 00000020 656e6f44
+00000a21 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+6142504d 636f6c6c 6e49203a 696c6176
+6f632064 6964726f 6574616e 78282073
+6430253d 3d79202c 2c643025 726f6320
+30253d65 000a2964 6f666e49 6e492820
+61697469 657a696c 29495041 6341203a
+61766974 676e6974 67615020 2e676e69
+00202e2e 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 0001800c 00000000 65726162
+6174654d 4f49426c 00000053 0001801c
+00000001 00000000 0001806c 0001806d
+0001806c 0001806c 0001806c 0001806c
+0001804c 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00010002 00000001 000180cc 000180cd
+000180cc 000180cc 000180cc 000180cc
+000180ac 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00020802 00000002 00017020 00017070
+00017020 00017020 00017020 0001812c
+0001810c 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00018020 00018080 000180e0 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+79706f43 68676972 63282074 39312029
+322d3239 20343030 50207962 202e4a2e
+75616c50 2c726567 63696c20 65736e65
+79622064 6e694420 776d756b 2c657261
+64744c20 4c41202e 4952204c 53544847
+53455220 45565245 00002e44 00000000
+000180e0 00000006 00000200 00015462
+00000001 00000000 00000000 00000000
+00000000 80000000 00003fbd 00000000
+00000000 80000000 00007fff 00000000
+00000000 c0000000 00007fff 00000000
+00000001 80000000 00007fff 00000000
+00000000 80000000 00003fde 00000000
+00000000 b0000000 00004003 00000050
+00017180 00000050 00000000 00000000
+00000000 00000000 00000000 00000000
+000157b4 000157b4 000157b4 000157b4
+000157b4 000157b4 000157b4 7f7f7f7f
+7f7f7f7f 7f7f7f7f 00007f7f 000157b8
+000157b4 000157b4 000157b4 000157b4
+000157bc 000157c4 000157b4 000157b4
+00000000 00000000 00000000 00000000
+/origin 3ffffc00
+00b8fcfa 8ed88e00 8ee08ec0 bcd08ee8
+00ea9000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00000000 00000000 00000000 00000000
+00f00de9 00000000 00000000 00000000
+/eof
diff -urN buildroot-2011.11.orig/selfboot/linux.mt buildroot-2011.11/selfboot/linux.mt
--- buildroot-2011.11.orig/selfboot/linux.mt	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/selfboot/linux.mt	2011-12-21 10:41:24.628365109 +0100
@@ -0,0 +1,2 @@
+# pid mch-route mch-dest-id mch-offset-base testcase
+0x00 0x00 6 0x00 resources/linux.obj
diff -urN buildroot-2011.11.orig/selfboot/preMergeImage.csh buildroot-2011.11/selfboot/preMergeImage.csh
--- buildroot-2011.11.orig/selfboot/preMergeImage.csh	1970-01-01 01:00:00.000000000 +0100
+++ buildroot-2011.11/selfboot/preMergeImage.csh	2011-12-21 10:41:24.628365109 +0100
@@ -0,0 +1,32 @@
+#!/bin/tcsh
+
+# Parameter?
+if ( "$1" != "" ) then
+  setenv image $1
+else
+  echo "Error: Please provide valid argument"
+  echo ""
+  echo "Usage: $0 <Linux object>"
+  exit 255
+endif
+echo "Pre-Merging $image!"
+  
+rm -rf obj
+rm -rf resources; mkdir resources
+cp $image resources/linux.obj
+setenv slots `sccMerge -pmcs -noimage -m 8 -n 13 linux.mt | grep MAX_CODE_SLOT | sed "s/MAX_CODE_SLOT=//"`
+cp obj/mch_0_0.32.obj resources/premerge_image_0_0.32.obj
+sccMerge -1slot -broadcast -noimage -m 8 -n 12 fastBoot.mt 
+cp obj/mch_0_0.32.obj resources/copycat_0_0.32.obj
+cp obj/lut_init.dat resources/copycat.dat
+echo "We need to copy `echo $slots+1 | bc` slots (LUT entry 0x7f of Core 0x00)..."
+echo "00 2 00000bf8 00000$slots" >> resources/copycat.dat
+sccMerge -noimage -m 8 -n 12 fastBoot.mt
+grep ".. . 00000800" obj/lut_init.dat > resources/patch.dat
+grep ".. . 00001000" obj/lut_init.dat >> resources/patch.dat
+grep ".. . 00000c00" obj/lut_init.dat >> resources/patch.dat
+grep ".. . 00000c08" obj/lut_init.dat >> resources/patch.dat
+grep ".. . 00001400" obj/lut_init.dat >> resources/patch.dat
+grep ".. . 00001408" obj/lut_init.dat >> resources/patch.dat
+rm -rf obj
+echo "Done... Select ./resources/linux.obj in sccBoot or sccGui!"
